      SUBROUTINE SHEMPRE (NH)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    SHEMPRE     COMPUTE GATHER-SCATTER INT & INTERP COEF
C   PRGMMR:  J TUCCILLO         ORG: W/NMC4     DATE: 90-06-18
C
C ABSTRACT: COMPUTE GATHER-SCATTER INTEGERS AND INTER-
C   POLATION COEFFICIENTS TO BE USED BY SUBROUTINE
C   'SHEM' TO CALCULATE VARIABLE VALUES AT THE
C   'BOUNDARY' POINTS OF GRID A IN THE SOUTHERN
C   HEMISPHERE.  THE FORECAST POINT BIT VECTORS
C   FOR GRID A ARE ALSO SET UP.
C   .
C   ANY GRID SQUARE OF GRID A HAVING AT LEAST ONE CORNER IN
C   THE NORTHERN HEMISPHERE HAS 'FORECAST' POINTS AT ALL FOUR CORNERS.
C   A SET OF SURROUNDING POINTS IS NEEDED TO MAKE A FORECAST OF ONE
C   TIME STEP FOR ALL FORECAST POINTS.  THIS CODE GENERATES THE
C   MACHINERY BY WHICH SUBROUTINE  'SHEM'  , WHEN CALLED AFTER EVERY
C   FORECAST STEP FOR GRID A, WILL GENERATE THE NEEDED 'BOUNDARY'
C   POINT VARIABLES.
C   .  THE PROCEDURE USES BILINEAR INTERPOLATION TO OBTAIN
C   VALUES AT NORTHERN HEMISPHERE IMAGE POINTS.  EVEN SYMMETRY IS
C   ASSUMED FOR ZONAL VELOCITY AND MASS VARIABLES ACROSS THE EQUATOR
C   WHILE ODD SYMMETRY IS ASSUMED FOR MERIDIONAL VELOCITY.
C   .
C   .
C   MUST BE CALLED ONCE, AT THE INITIATION OF THE FORECASTING PROCESS
C   IN ANY SINGLE JOB. ( E.G. IT NEED NOT BE CALLED AGAIN
C   AFTER A CALL TO THE OUTPUT POSTPROCESSER IF FORECASTING RESUMES
C   WITHIN THAT JOB. )
C
C PROGRAM HISTORY LOG:
C   90-06-18  J TUCCILLO
C
C USAGE:  CALL SHEMPRE( NH )
C   INPUT ARGUMENT LIST:
C     NH       -  NH + .5 IS THE NUMBER OF GRID INCREMENTS
C                 ON GRID A BETWEEN POLE AND EQUATOR.
C
C   OUTPUT FILES:
C     IOUTUPRT - FOR PRINTOUT
C
C   SUBPROGRAMS CALLED:
C     UNIQUE:    - ERRPRINT
C     LIBRARY
C       COMMON   - COMBLANK
C                  COMSHEM
C
C REMARKS:
C   .
C   - - - - - - - - I N P U T   V A R I A B L E S  - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   NSHEM         ESTIMATED NUMBER OF BOUNDARY POINTS         PLI
C   .             ON GRID A FOR H, U, OR V-TYPE VBLS.
C   .
C   - - - - - - - - O U T P U T   V A R I A B L E S - - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   BITGRDH,       BIT VECTORS CONTAINING A 1 FOR FORECAST   COMMON
C   BITGRDU,AND    POINTS ON GRID A.
C   BITGRDV.
C   .
C   NSHEMH,NSHEMU, THE ACTUAL NUMBER OF BOUNDARY POINTS FOR  COMMON
C   AND NSHEMV.    H,U, AND V-TYPE VARIABLES ON GRID A.
C   .
C   ISHEMX(N,L)    GATHER AND SCATTER INTEGERS FOR           COMMON
C   .              X=H,U, OR V BOUNDARY POINTS.
C   .
C   SHX4Y          BILINEAR INTERPOLATION COEFFICIENTS TO    COMMON
C   .              OPERATE ON VARIABLE X=H,U,V TO GET
C   .              VARIABLE Y=H,U,V.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN
C   MACHINE:  CRAY Y-MP
C
C$$$
C
      include 'parmodel'
C
C...TRANSLATED BY FPP 3.00Z36 11/09/90  14:43:31
C...SWITCHES: OPTON=I47,OPTOFF=VAE0
C
C
C          BIT VECTORS FOR STORING FCST VALUES ON GRID A.
      LOGICAL BITH(IIJMAX,2),BITU(IIJMAX,2),BITV(IIJMAX,2)
C
      CHARACTER*35 ERRMSG(4)
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
C     COMMON BLOCK /COMSHEM/ CONTAINS VARIABLES NEEDED
C     FOR THE EQUATORIAL BOUNDARY CONDITIONS.
      COMMON /COMSHEM/  NSHEM, NSHEMH, NSHEMU, NSHEMV,
     1                  ISHEMH(INSHEM, 2), ISHEMU(INSHEM, 3),
     2                  ISHEMV(INSHEM, 3),
     3                  SHH4H (INSHEM, 4), SHU4U (INSHEM, 4),
     4                  SHV4U (INSHEM, 4), SHU4V (INSHEM, 4),
     5                  SHV4V (INSHEM, 4)
C
      DIMENSION R2H(IIJMAX), R2U(IIJMAX), R2V(IIJMAX),
     *          FH(IIJMAX),  FU(IIJMAX),  FV(IIJMAX),
     *          CH(IIJMAX),  CU(IIJMAX),  CV(IIJMAX)
C
C****  NOTE THAT THE CODE REFERS TO BOTH FORMS OF THE FOLLOWING
C****  EQUIVALENCED ARRAYS.
C
      EQUIVALENCE (R2H(1), SCR(1,1) ), (R2U(1), SCR(1,2) ),
     1            (R2V(1), SCR(1,3) ), (FH(1),  SCR(1,4) ),
     2            (FU(1),  SCR(1,5) )
      EQUIVALENCE (FV(1), SCR(1, 6)),
     1            (CH(1), SCR(1, 7)), (CU(1), SCR(1, 8)),
     2            (CV(1), SCR(1, 9))
C
      EQUIVALENCE (BITH,BITGRDH(1,1,1)),(BITU,BITGRDU(1,1,1)),
     1            (BITV,BITGRDV(1,1,1))
C
      DATA ONE/1.E0/
C
C     INITIALIZE NSHEM=ARRAY DIMEN IN /COMSHEM/
C
C     INITIALIZE NSHEM=ARRAY DIMEN IN /COMSHEM/
      NSHEM = INSHEM
C
C              SPECIFY THE UNIT NUMBER OF THE PRINTER.
      IOUTUPRT = 6
C
C              ZERO THE BIT VECTORS (I.E. NO FCST POINTS).
CMIC$ DO ALL SHARED(BITH, BITU, BITV) PRIVATE(IQ2, IQ1)
      DO 1002 IQ2 = 1, 20568
         BITH(IQ2,1) = .FALSE.
         BITU(IQ2,1) = .FALSE.
         BITV(IQ2,1) = .FALSE.
 1002 CONTINUE
C
      IM=2*NH+6
      JM=IM
      IJM=IM*JM
      IMM1=IM-1
      JMM1=JM-1
      DNH=FLOAT(NH)
      XP=DNH+4.E0
      YP=XP
C          SQUARE OF EQUATORIAL RADIUS IN GRID DISTANCE UNITS.
      RSQE=DNH+.5E0
      RSQE=RSQE*RSQE
C          GET SQUARED DISTANCE FROM POLE IN GRID MESH UNITS FOR H,U,V.
      IAD=0
      DJ=0.E0
      DO 20 J=1,JM
      DJ=DJ+1.E0
      Y1=DJ-YP
      YH=Y1*Y1
      Y1=Y1+.5E0
      YU=Y1*Y1
      DI=0.E0
        DO 10 I=1,IM
        IAD=IAD+1
        DI=DI+1.E0
        X1=DI-XP
        XH=X1*X1
        X1=X1+.5E0
        XV=X1*X1
        R2H(IAD)=XH+YH
        R2V(IAD)=XV+YH
        R2U(IAD)=XH+YU
   10   CONTINUE
   20 CONTINUE
C          DETERMINE FORECAST POINTS SO AS TO COVER THE N. HEMISPHERE.
CMIC$ DO ALL VECTOR SHARED(IJM, FH, FU, FV) PRIVATE(IQ2W6E)
      DO 88890 IQ2W6E=1,IJM
         FH(IQ2W6E)=0.E0
         FU(IQ2W6E)=0.E0
         FV(IQ2W6E)=0.E0
88890 CONTINUE
      DO 40 J=1,JMM1
      IADD=(J-1)*IM
        DO 30 I=1,IMM1
        IADD=IADD+1
C          IV=1,2,3 FOR H,U, AND V POINTS.
CMIC$ DO ALL VECTOR SHARED(IADD, IM, RSQE, ONE, SCR) PRIVATE(IV, IV3)
          DO 25 IV=1,3
          IV3=IV+3
          IF( SCR(IADD,IV) .LT. RSQE ) GO TO 22
          IF( SCR(IADD+1,IV) .LT. RSQE ) GO TO 22
          IF( SCR(IADD+IM,IV) .LT. RSQE ) GO TO 22
          IF( SCR(IADD+IM+1,IV) .LT. RSQE ) GO TO 22
C     NO POINTS OF THIS GRID SQUARE ARE NORTH OF THE EQUATOR.
          GO TO 25
C
C       ONE POINT IS IN NORTHERN HEMISPHERE, THEREFORE ALL FOUR
C       POINTS MUST BE FORECAST POINTS.
   22     SCR(IADD,IV3) = SCR(IADD,IV3) + ONE
          SCR(IADD+1,IV3) = SCR(IADD+1,IV3) + ONE
          SCR(IADD+IM,IV3) = SCR(IADD+IM,IV3) + ONE
          SCR(IADD+IM+1,IV3) = SCR(IADD+IM+1,IV3) + ONE
C
   25     CONTINUE
C
   30   CONTINUE
   40 CONTINUE
C          A FCST POINT NOW HAS 1.,2.,3., OR 4. IN FH(OR FU OR FV).
C
C          DETERMINE THE SURROUNDING POINTS NEEDED TO FORECAST ANY
C          FORECAST POINT.
CMIC$ DO ALL VECTOR SHARED(IJM, CH, CU, CV) PRIVATE(IQ2W6E)
      DO 88920 IQ2W6E=1,IJM
         CH(IQ2W6E)=0.E0
         CU(IQ2W6E)=0.E0
         CV(IQ2W6E)=0.E0
88920 CONTINUE
      J = 2
995   IF ( J .GT. JMM1 ) GOTO 9995
      IADD=(J-1)*IM+1
        I = 2
990     IF ( I .GT. IMM1 ) GOTO 9990
        IADD=IADD+1
        IF(FH(IADD) .LE. 0.E0)  GO TO 60
C          THIS IS AN H FCST POINT
C          SET THE H PTS NEEDED FOR THIS FCST POINT
        J1=J-1
        J2=J+1
        I1=I-1
        I2=I+1
        IRET=1
        GO TO 100
C          SET THE U PTS NEEDED FOR THIS FCST POINT
   50   J1=J-2
        GO TO 115
C          SET THE V PTS NEEDED FOR THIS FCST POINT
   55   J1=J-1
        I1=I-2
        GO TO 130
   60   IF(FU(IADD) .LE. 0.E0)   GO TO 75
C          THIS IS A U FCST POINT
C          SET THE H PTS NEEDED FOR THIS FCST POINT
        J1=J-1
        J2=J+2
        I1=I-1
        I2=I+1
        IRET=2
        GO TO 100
C          SET THE U PTS NEEDED FOR THIS FCST POINT
   65   J1=J-2
        GO TO 115
C          SET THE V PTS NEEDED FOR THIS FCST POINT
   70   J1=J-1
        I1=I-2
        GO TO 130
   75   IF(FV(IADD) .LE. 0.E0)   GO TO  90
C          THIS IS A V FCST POINT
C          SET THE H PTS NEEDED FOR THIS FCST POINT
        J1=J-1
        J2=J+1
        I1=I-1
        I2=I+2
        IRET=3
        GO TO 100
C          SET THE U PTS NEEDED FOR THIS FCST POINT
   80   J1=J-2
        GO TO 115
C          SET THE V PTS NEEDED FOR THIS FCST POINT
   85   J1=J-1
        I1=I-2
        GO TO 130
CW 90   CONTINUE
   90   I = I + 1
        GOTO 990
9990    CONTINUE
CW 95 CONTINUE
   95  J = J + 1
       GOTO 995
9995  CONTINUE
      GO TO 150
C     *****COMPUTED GO TO ROUTINES TO PUT ONES IN POINTS NEEDED TO
C          FORECAST THE FORECAST POINTS.
C
C          FIRST CHECK LIMITS ON THE H POINTS
  100 IENT=100
      IF(I1 .LT.2) GO TO 145
      IF(I2 .GT. IM) GO TO 145
      IF(J1 .LT. 2) GO TO 145
      IF(J2 .GT. JM) GO TO 145
C          OKEH
      DO 110 JJ=J1,J2
      JADD=(JJ-1)*IM
CMIC$ DO ALL VECTOR SHARED(I2, I1, JADD, CH) PRIVATE(II)
        DO 105 II=I1,I2
        CH(JADD+II)=CH(JADD+II)+1.E0
  105   CONTINUE
  110 CONTINUE
      GO TO (50, 65, 80 ) , IRET
C
C          CHECK LIMITS ON U POINTS
  115 IENT=115
      IF(I1 .LT.2) GO TO 145
      IF(I2 .GT. IM) GO TO 145
      IF(J1 .LT. 1) GO TO 145
      IF(J2 .GT. JM) GO TO 145
C          OKEH
      DO 125 JJ=J1,J2
      JADD=(JJ-1)*IM
CMIC$ DO ALL VECTOR SHARED(I2, I1, JADD, CU) PRIVATE(II)
        DO 120 II=I1,I2
        CU(JADD+II)=CU(JADD+II)+1.E0
  120   CONTINUE
  125 CONTINUE
      GO TO ( 55, 70, 85 ), IRET
C
C          CHECK LIMITS ON V POINTS
  130 IENT=130
      IF(I1 .LT.1) GO TO 145
      IF(I2 .GT. IM) GO TO 145
      IF(J1 .LT. 2) GO TO 145
      IF(J2 .GT. JM) GO TO 145
C          OKEH
      DO 140 JJ=J1,J2
      JADD=(JJ-1)*IM
CMIC$ DO ALL VECTOR SHARED(I2, I1, JADD, CV) PRIVATE(II)
        DO 135 II=I1,I2
        CV(JADD+II)=CV(JADD+II)+1.E0
  135   CONTINUE
  140 CONTINUE
C
      GO TO ( 60, 75, 90 ), IRET
C
C               A POINT IS OUT OF THE PROPER RANGE.
  145 WRITE (IOUTUPRT, 146) IENT,I1,I2,J1,J2,I,J
  146 FORMAT(1H0,2X,'**IN SR SHEMPRE COMP PT IS OUT OF RANGE,,IENT,I1,',
     1 'I2,J1,J2,I,J, ARE',7I6)
C
      CALL ERRPRINT
C
      CALL EXIT(16)
C
C     *********************************************************
C          THE S. HEMISPHERE BNDRY POINTS NOW HAVE A ZERO IN FX,
C          BUT THEY ARE GREATER THAN ZERO IN CX.
C               GET GATH-SCAT INTEGERS AND COEFFS FOR THE H POINTS,
  150 N=0
      NB=0
C          ( N AND NB WILL COUNT BNDRY POINTS AND ALL POINTS, RESP.)
CMIC$ PARALLEL SHARED(NSHEM, SHH4H, ISHEMH) PRIVATE(IQ2W6E)
CMIC$ DO PARALLEL VECTOR
      DO 88950 IQ2W6E=1,2*NSHEM
         ISHEMH(IQ2W6E,1)=0
88950 CONTINUE
CMIC$ DO PARALLEL VECTOR
      DO 88960 IQ2W6E=1,4*NSHEM
         SHH4H(IQ2W6E,1)=0.E+0
88960 CONTINUE
CMIC$ END PARALLEL
      ISCAT=0
      DO 220 J=1,JM
      DJ=FLOAT(J)
        DO 210 I=1,IM
        NB=NB+1
        ISCAT=ISCAT+1
        IF(FH(ISCAT) .GT. 0.E0) GO TO 200
C          THIS IS NOT AN H FCST POINT
        IF(CH(ISCAT) .LE. 0.E0)   GO TO 210
C          THIS IS INDEED A S. HEM. H BNDRY POINT.
        N=N+1
C          TEST ARRAY SIZE
      IF( N .LE. NSHEM ) GO TO 199
      WRITE (IOUTUPRT, 198) I,J,N,NSHEM
  198 FORMAT(1H1,2X,'*********TOO MANY H BNDRY PTS IN SHEMPRE--',
     1 3X,'I,J,N,NSHEM=',4I12)
C
      CALL ERRPRINT
C
      CALL EXIT(16)
C
  199 CONTINUE
C          INTEGER TO SCATTER BNDRY VALUE INTO THE H ARRAY.
        ISHEMH(N,1)=ISCAT
C          GET IMAGE POINT INFORMATION
        DI=FLOAT(I)
        C2=RSQE/R2H(ISCAT)
        DIINH=XP+(DI-XP)*C2
        DJJNH=YP+(DJ-YP)*C2
        IINH=INT(DIINH)
        JJNH=INT(DJJNH)
C          INTEGER TO GATHER N. HEM. H PT TO LOWER LEFT OF IMAGE PT.
        ISHEMH(N,2)=IINH+(JJNH-1)*IM
C          GET LOCATION OF IMAGE POINT WITHIN THE N. HEM. GRID BOX.
        DX=DIINH-FLOAT(IINH)
        DY=DJJNH-FLOAT(JJNH)
C          GET THE INTERPOLATION COEFFS( BILINEAR FORMULA)
        DX1=1.E0-DX
        DY1=1.E0-DY
        SHH4H(N,1) = (DX1*DY1)
        SHH4H(N,2) = (DX*DY1)
        SHH4H(N,3) = (DY*DX1)
        SHH4H(N,4) = (DX*DY)
        GO TO 210
C          FOR A FCST POINT, MUST CORRECT THE BIT VECTOR TO 1.
  200   BITH(NB, 1)= .TRUE.
  210   CONTINUE
  220 CONTINUE
C     RECORD THE NUMBER OF H BNDRY POINTS
      NSHEMH=N
C
C          NOW GET GATH-SCAT INTEGERS AND COEFFS FOR U BNDRY POINTS.
C
      N=0
      NB=0
CMIC$ PARALLEL SHARED(NSHEM, SHU4U, SHV4U, ISHEMU) PRIVATE(IQ2W6E)
CMIC$ DO PARALLEL VECTOR
      DO 88970 IQ2W6E=1,3*NSHEM
         ISHEMU(IQ2W6E,1)=0
88970 CONTINUE
CMIC$ DO PARALLEL VECTOR
      DO 88980 IQ2W6E=1,4*NSHEM
         SHU4U(IQ2W6E,1)=0.E+0
         SHV4U(IQ2W6E,1)=0.E+0
88980 CONTINUE
CMIC$ END PARALLEL
      ISCAT=0
      DO 250 J=1,JM
      DJ=FLOAT(J)
        DO 240 I=1,IM
        NB=NB+1
        ISCAT=ISCAT+1
        IF(FU(ISCAT) .GT. 0.E0)  GO TO 230
C          NOT A U FCST POINT
        IF(CU(ISCAT) .LE. 0.E0) GO TO 240
C          THIS IS A U BNDRY POINT
        N=N+1
C          TEST ARRAY SIZE
      IF( N .LE. NSHEM ) GO TO 225
      WRITE (IOUTUPRT, 224) I,J,N,NSHEM
  224 FORMAT(1H1,2X,'*********TOO MANY U BNDRY PTS IN SHEMPRE--',
     1 3X,'I,J,N,NSHEM=',4I12)
C
      CALL ERRPRINT
C
      CALL EXIT(16)
C
  225 CONTINUE
        ISHEMU(N,1)=ISCAT
        DI=FLOAT(I)
        C2=RSQE/R2U(ISCAT)
C          GET IMAGE PT. LOCATION W/R TO I,J FOR U PTS.
        C4=DI-XP
        DIINH=XP+C2*C4
        C5=DJ+.5E0-YP
        DJJNH=YP-.5E0+C2*C5
        IINH=INT(DIINH)
        JJNH=INT(DJJNH)
C          INTEGER TO GATHER U TO LOWER LEFT OF IMAGE POINT
        ISHEMU(N,2)=IINH+(JJNH-1)*IM
C          GET THE ROTATION ANGLES
        C3=1.E0/(C4*C4+C5*C5)
        SINSQ=C3*C5*C5
C          COSINE OF TWICE THE LONGITUDE.
        COS2L=1.E0-2.E0*SINSQ
C          SINE OF TWICE THE LONGITUDE.
        SIN2L=2.E0*C4*C5*C3
C          NOW GET LOCATION OF IMAGE POINT WITHIN THE IMAGE BOX.
        DX=DIINH-FLOAT(IINH)
        DY=DJJNH-FLOAT(JJNH)
        DX1=1.E0-DX
        DY1=1.E0-DY
        SHU4U(N,1) = (-DX1*DY1*COS2L)
        SHU4U(N,2) = (-DX*DY1*COS2L)
        SHU4U(N,3) = (-DY*DX1*COS2L)
        SHU4U(N,4) = (-DX*DY*COS2L)
C          NOW NEED IMAGE PT LOCATION WITH RESPECT TO V POINTS.
        DIINH=DIINH-.5E0
        DJJNH=DJJNH+.5E0
        IINH=INT(DIINH)
        JJNH=INT(DJJNH)
C          INTEGER TO GATHER V TO LOWER LEFT OF IMAGE POINT.
        ISHEMU(N,3)=IINH+(JJNH-1)*IM
C         THE INTERPOLATION COEFFS,,
        DX=DIINH-FLOAT(IINH)
        DY=DJJNH-FLOAT(JJNH)
        DX1=1.E0-DX
        DY1=1.E0-DY
        SHV4U(N,1) = (-DX1*DY1*SIN2L)
        SHV4U(N,2) = (-DX*DY1*SIN2L)
        SHV4U(N,3) = (-DY*DX1*SIN2L)
        SHV4U(N,4) = (-DX*DY*SIN2L)
        GO TO 240
C          A FORECAST POINT, CORRECT THE BIT VECTOR TO A 1.
  230   BITU(NB, 1)= .TRUE.
  240   CONTINUE
  250 CONTINUE
C          RECORD THE NUMBER OF U BNDRY POINTS.
      NSHEMU=N
C
C          GET GATH-SCAT INTEGERS AND COEFFS FOR V BNDRY POINTS.
      N=0
      NB=0
CMIC$ PARALLEL SHARED(NSHEM, SHU4V, SHV4V, ISHEMV) PRIVATE(IQ2W6E)
CMIC$ DO PARALLEL VECTOR
      DO 89000 IQ2W6E=1,3*NSHEM
         ISHEMV(IQ2W6E,1)=0
89000 CONTINUE
CMIC$ DO PARALLEL VECTOR
      DO 89010 IQ2W6E=1,4*NSHEM
         SHU4V(IQ2W6E,1)=0.E+0
         SHV4V(IQ2W6E,1)=0.E+0
89010 CONTINUE
CMIC$ END PARALLEL
      ISCAT=0
      DO 350 J=1,JM
      DJ=FLOAT(J)
        DO 340 I=1,IM
        NB=NB+1
        ISCAT=ISCAT+1
        IF(FV(ISCAT) .GT. 0.E0)  GO TO 330
C          THIS IS NOT A FORECST POINT.
        IF(CV(ISCAT) .LE. 0.E0)   GO TO 340
C          THIS IS A S. HEM. V BNDRY POINT.
        N=N+1
C          TEST ARRAY SIZE
      IF( N .LE. NSHEM ) GO TO 259
      WRITE (IOUTUPRT, 258) I,J,N,NSHEM
  258 FORMAT(1H1,2X,'*********TOO MANY V BNDRY PTS IN SHEMPRE--',
     1 3X,'I,J,N,NSHEM=',4I12)
C
      CALL ERRPRINT
C
      CALL EXIT(16)
C
  259 CONTINUE
        ISHEMV(N,1)=ISCAT
        DI=FLOAT(I)
        C2=RSQE/R2V(ISCAT)
C          IMAGE PT LOCATION WITH RESPECT TO V PT  I AND J.
        C4=DI+.5E0-XP
        DIINH=XP-.5E0+C2*C4
        C5=DJ-YP
        DJJNH=YP+C2*C5
        IINH=INT(DIINH)
        JJNH=INT(DJJNH)
C          INTEGER TO GATHER V TO LOWER LEFT OF IMAGE POINT.
        ISHEMV(N,3)=IINH+(JJNH-1)*IM
C          GET THE ROTATION ANGLES.
        C3=1.E0/(C4*C4+C5*C5)
        SINSQ=C3*C5*C5
        COS2L=1.E0-2.E0*SINSQ
        SIN2L=2.E0*C3*C4*C5
C          LOCATION OF IMAGE PT IN V BOX.
        DX=DIINH-FLOAT(IINH)
        DY=DJJNH-FLOAT(JJNH)
        DX1=1.E0-DX
        DY1=1.E0-DY
        SHV4V(N,1) = (COS2L*DX1*DY1)
        SHV4V(N,2) = (COS2L*DX*DY1 )
        SHV4V(N,3) = (COS2L*DY*DX1 )
        SHV4V(N,4) = (COS2L*DX*DY  )
C          GET LOCATION OF IMAGE POINT WITH RESPECT TO U I AND J VALS.
        DIINH=DIINH+.5E0
        DJJNH=DJJNH-.5E0
        IINH=INT(DIINH)
        JJNH=INT(DJJNH)
C          INTEGER TO GATHER U TO LOWER LEFT OF V IMAGE PT.
        ISHEMV(N,2)=IINH+(JJNH-1)*IM
        DX=DIINH-FLOAT(IINH)
        DY=DJJNH-FLOAT(JJNH)
        DX1=1.E0-DX
        DY1=1.E0-DY
        SHU4V(N,1) = (-SIN2L*DX1*DY1)
        SHU4V(N,2) = (-SIN2L*DX*DY1)
        SHU4V(N,3) = (-SIN2L*DY*DX1)
        SHU4V(N,4) = (-SIN2L*DX*DY)
        GO TO 340
C          CORRECT THE BIT VECTOR TO A 1 FOR A FCST POINT.
  330   BITV(NB, 1)= .TRUE.
  340   CONTINUE
  350 CONTINUE
C          RECORD THE NUMBER OF V BNDRY POINTS.
      NSHEMV=N
C          SHUFFLE THE ARRAYS TO AVOID BANK CONFLICT WHEN CONSECUTIVE
C            IMAGE POINTS FALL IN SAME NORTH. HEMI. GRID SQUARE.
      LS=NSHEMH-4
CMIC$ DO ALL SHARED(LS, ISHEMH, SHH4H) PRIVATE(M, MM, ISV, I, XSV)
      DO 352 M=1,LS,2
      MM=M+3
      ISV=ISHEMH(M,1)
      ISHEMH(M,1)=ISHEMH(MM,1)
      ISHEMH(MM,1)=ISV
      ISV=ISHEMH(M,2)
      ISHEMH(M,2)=ISHEMH(MM,2)
      ISHEMH(MM,2)=ISV
        DO 351 I=1,4
        XSV=SHH4H(M,I)
        SHH4H(M,I)=SHH4H(MM,I)
        SHH4H(MM,I)=XSV
  351   CONTINUE
  352 CONTINUE
C          NSHEMV AND NSHEMU SHD. BE EQUAL.
      LS=NSHEMU-4
CMIC$ DO ALL SHARED(LS, ISHEMU, ISHEMV, SHU4U, SHV4U, SHU4V, SHV4V)
CMIC$1    PRIVATE(M, MM, I, ISV, XSV)
      DO 355 M=1,LS,2
      MM=M+3
        DO 353 I=1,3
        ISV=ISHEMU(M,I)
        ISHEMU(M,I)=ISHEMU(MM,I)
        ISHEMU(MM,I)=ISV
        ISV=ISHEMV(M,I)
        ISHEMV(M,I)=ISHEMV(MM,I)
        ISHEMV(MM,I)=ISV
  353   CONTINUE
        DO 354 I=1,4
        XSV=SHU4U(M,I)
        SHU4U(M,I)=SHU4U(MM,I)
        SHU4U(MM,I)=XSV
        XSV=SHV4U(M,I)
        SHV4U(M,I)=SHV4U(MM,I)
        SHV4U(MM,I)=XSV
        XSV=SHU4V(M,I)
        SHU4V(M,I)=SHU4V(MM,I)
        SHU4V(MM,I)=XSV
        XSV=SHV4V(M,I)
        SHV4V(M,I)=SHV4V(MM,I)
        SHV4V(MM,I)=XSV
  354   CONTINUE
  355 CONTINUE
C
C               CHECK THE ARRAY SIZES.
      ISIZE=0
      IF(NSHEMH .GT. NSHEM) ISIZE=1
      IF(NSHEMU .GT. NSHEM) ISIZE=1
      IF(NSHEMV .GT. NSHEM) ISIZE=1
      WRITE (IOUTUPRT, 360) NSHEM,NSHEMU,NSHEMV,NSHEMH
  360 FORMAT(/'0', 'THE FIRST DIMENSION OF THE ARRAYS USED IN ',
     1             'THE APPLICATION OF THE EQUATORIAL BOUNDARY ',
     2             'CONDITIONS IS NSHEM =', I5, '.' /
     3        ' ', 5X, 'THE ACTUAL NUMBER OF POINTS USED FOR U, V, ',
     4             'AND H POINT FIELDS, RESPECTIVELY, IS:'/
     5        ' ', 10X, 'NSHEMU =', I5, ',   NSHEMV =', I5,
     6             ',   AND NSHEMH =', I5, '.' /)
C
      IF(ISIZE .EQ. 0) GO TO 400
      WRITE (IOUTUPRT, 365)
  365 FORMAT(1H0,40X,'*****S. HEM. ARRAYS NOT LARGE ENOUGH IN SR',
     1 ' SHEMPRE.' )
C
      CALL ERRPRINT
C
      CALL EXIT(16)
C
C
 400  RETURN
      END
