       PROGRAM MAIN
C$$$  MAIN PROGRAM DOCUMENTATION BLOCK
C
C MAIN PROGRAM: NGM_NGMINI
C   PRGMMR: ROGERS           ORG: NP22        DATE: 2000-02-09
C
C ABSTRACT:  USE IMPLICIT NORMAL MODE INITIALIZATION WITH THE NGM.
C   THIS IS BASED ON TEMPERTON*S IDEAS, BUT USES SPHERICAL HARMONICS
C   FOR THE PROJECTION OPERATIONS, INSTEAD OF SOLVING BOUNDARY VALUE
C   PROBLEMS ON THE MODEL GRIDS.  BECAUSE THE NGM IS HEMISPHERIC,
C   THIS SHOULD BE OK.  HOWEVER, FOR A LIMITED AREA MODEL, ONE SHOULD
C   SOLVE THE BOUNDARY VALUE PROBLEMS ON THE MODEL GRID.
C   THE PRIMARY INPUT ARE THE METEOROLOGICAL
C   FIELDS USED IN AN NGM FORECAST AT THE NGM GRID POINTS.
C   THE PRIMARY OUTPUT ARE THE SAME FIELDS AFTER INITIALIZATION, READY
C   TO PASS TO THE FORECAST-POSTPROCESSING MODEL (RCNGMF).
C   SUBROUTINE ONEGRID, WHICH IS THE HEART OF THE NGM FORECAST MODEL,
C   IS USED EXTENSIVELY BY THIS INITIALIZATION.
C   THIS CODE DECIDES AUTOMATICALLY, BASED ON NATURE AND AVAILABILITY
C   OF INPUT FIELDS, WHETHER OR NOT TO DO INCREMENTAL INITIALIZATION.
C   INCREMENTAL INITIALIZATION MEANS THAT ONLY THE ANALYSIS INCREMENT
C   IS INITIALIZED, WHILE THE FORECAST FIRST GUESS (NECESSARILY IN
C   NGM FORM) IS LEFT UNCHANGED.
C
C PROGRAM HISTORY LOG:
C   88-08-08  PARRISH
C   98-11-18  ERIC ROGERS MADE CODE Y2K COMPLIANT
C
C USAGE:
C
C   INPUT FILES:
C     UNIT5      - DATA CARDS SPECIFYING THE INPUT AND OUTPUT
C                  UNIT NUMBERS FOR THE DATASETS USED BY THIS PROGRAM.
C                  THE FORMAT AND INFORMATION ON THE CARDS IS
C                  DESCRIBED ON THE CARDS THEMSELVES.
C     UNIT20     - OPTIONAL FILE, CONTAINING FIRST GUESS RESTART
C                  FILE, FOR USE WITH INCREMENTAL DNI.
C     UNIT21     - THE FORECAST VARIABLES OF THE NGM ON THE NGM
C                  GRIDS, THE SPECIFICATIONS ARRAY FOR THIS JOB,
C                  AND THE LOCATION OF ICE-FREE WATER SURFACE.
C                  NOTE: THIS CAN ALSO CONTAIN ANALYSIS INCREMENTS,
C                  TO BE ADDED TO FIRST GUESS, WHEN DOING INCREMENTAL
C                  DNI.
C     UNIT22     - THE RESTART FILE, WHICH HAS THE SAME FORMAT
C                  AS UNIT21, USED HERE TO CONTAIN INITIALIZED FIELDS.
C     UNIT32     - DATA CARDS SPECIFYING THE VARIOUS OPTIONS
C                  USED WHEN MAKING THE FORECAST AND DOING THE
C                  POSTPROCESSING.
C                  THE FORMAT AND INFORMATION ON THE CARDS IS
C                  DESCRIBED ON THE CARDS THEMSELVES.
C
C   OUTPUT FILES:
C     UNIT6      - PRINTOUT FROM THE CONTROLLEE.
C     UNIT22     - THE RESTART FILE, WHICH HAS THE SAME FORMAT
C                  AS UNIT21.
C
C   SUBPROGRAMS CALLED:
C     UNIQUE:    -
C                  BITOUT
C                  ERRSTOP
C                  FILLHOLE
C                  LATBND
C                  ONEGRID
C                  P2KAP
C                  SHEM
C                  SHEMPRE
C
C   EXIT STATES:
C     COND =  0 -- SUCCESSFUL RUN.
C
C   REMARKS:  CARE SHOULD BE UTILIZED WITH UNSAFE AND VECTORIZE
C     OPTIONS.  SOME OF THE CODE HERE IS NOT HAND VECTORIZED SO
C     OPTIMIZATION IS NECESSARY FOR THE BEST PERFORMANCE.
C     ***************************************************************
C     ** FOR THIS CODE, OBSERVE THAT PLI VARIABLES NFILLER AND NPHYS*
C     ** HAVE BEEN CHANGED.  DO NOT ATTEMPT TO PLI ANY OF FCST MODEL*
C     ** IN SAME STEP WITH THIS CODE. *******************************
C     ***************************************************************
C
C ATTRIBUTES:
C   LANGUAGE:  CYBER FORTRAN WITH CDC EXTENSIONS.
C   MACHINE:   CYBER205
C
C$$$
C
C
C
C
         include "myparam"
         dimension dpfillr(idpfillr)
      CHARACTER*1  DAYMSG1(70)
      CHARACTER*6  DATASET
      CHARACTER*6  DATANAME
      CHARACTER*35 ERRMSG(4)
      CHARACTER*35 DAYMSG35(2)
      REAL ONEMSIG
      REAL CKAPPAP1
      LOGICAL LFRSTGES
C
C     COMMON BLOCK /COMCONST/ CONTAINS GRID-RELATED PARAMETERS,
C          AND A FEW OTHER COMMON CONSTANTS.
      COMMON /COMCONST/ IJMAX, KM, LVLTOT, IJRAD, LOFCLDS(2,4),
     1                  ICALLRAD, IPHYSPL, NGRDUSE, NH,
     2                  NTIME, ITIME, NSTEPS,
     3                  IMG(INGRDUSE), JMG(INGRDUSE),
     4                  IAG(INGRDUS1), JAG(INGRDUS1),
     5                  IBG(INGRDUS1), JBG(INGRDUS1),
     6                  IADDRG(INIADDRS, INGRDUSE),
     7                  NPTSFH(2, INGRDUSE),
     8                  KUMULUS, LGRIDPPT, KLIFT1, KLIFT2, IBUCKET,
     9                  XPOLEH(INGRDUSE), YPOLEH(INGRDUSE), RADIUS,
     1                  DELSIG(IKM), PR(IKM), PRESS(IKM),
     2                  SIGINT(IKMP1),
     3                  DTOVDX, ANGVEL,
     4                  SIGMACC, SIGMAGSP, SIGMADHQ, CRITCONV,
     5                  SATDEL, RHFACTOR, QBOUND,
     6                  ANEM, BLKDR, CHARN, CONAUST, DDORF, PKATO,
     7                  SCALEHT, SIGDOT, DLAMNGM
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
C     COMMON BLOCK /COMDIAG/ CONTAINS QUANTITIES SAVED FOR
C          DIAGNOSTIC PURPOSES.
      COMMON /COMDIAG/  KADIAB( IKM, INGRDUSE ),
     1                  NPTSDHQ (2, INGRDUSE),
     2                  KKCLOUD2(2, INGRDUSE), NPTSBUOY(2, INGRDUSE),
     3                  NPTSWATR(2, INGRDUSE), NPTSCC  (2, INGRDUSE),
     4                  KKGSP2  (2, INGRDUSE),
     5                  KKGSE2  (2, INGRDUSE),
     6                  NPTSSAT (IKM, 2, INGRDUSE),
     7                  NPTSEVAP(IKM, 2, INGRDUSE),
     8                  NPTSGSP (2, INGRDUSE), NUMPROF,
     9                  PPTCC   (2, INGRDUSE), PPTGSP  (2, INGRDUSE),
     1                  ALATPR  (IMAXPROF),    ALONPR  (IMAXPROF),
     2                  DESCRP  (IMAXPROF)
C
      CHARACTER*24 DESCRP
C
C     COMMON BLOCK /COMOUT/ CONTAINS OUTPUT CODE PARAMETERS
C               AND ARRAYS.
C
      CHARACTER*20 DESCRIPT
C          DESCRIPTORS USED IN SR  OUTHORIZ
C
      COMMON /COMOUT/
C
C          THE FOLLOWING ARE STORED BY OUT2FILE FROM DATA CARDS.
C          (THE LAST 6 WILL BE OVERWRITTEN BY  OUTPUT  IF KGTYPE
C          IS 5 OR 26 (I.E. AN LFM GRID DEFINED IN TABLE 7 OF
C          OFFICE NOTE 84.))
C
     1     INUNIT, IOUTUNIT,
     2     KGTYPE, IMOUT, JMOUT, DNPEQOUT, DLAMOUT, XIPOUT, YJPOUT,
C
C          THE FOLLOWING COME FROM  MAIN  READING THE DATA CARDS.
     2   LQTYPE(IMAXOUTV),   LSTYPE(IMAXOUTV),
     3   DESCRIPT(IMAXOUTV), LEVELS(ILMOUT,IMAXOUTV),  NOUTVBLS,
C
C          THE FOLLOWING ARE DERIVED BY   OUTPUT  .
     4       IJOUT, LMOUT, NFILLER, NS2, NS3NGM, NS3OUT,
     5       COSOUT,   SINOUT,    DXOUT,    ZSIGLYR(IKM),
C
C           ARRAYS  PLOUT  AND  HTFD  ARE SET BY DATA STATEMENTS IN
C           THE SR  OUTPUT  .  'PADDER' FILLS OUT TO FULL WORD BNDRY.
     6      PLOUT(ILMOUT),   HTFD( 6),  PADDER,
C
C          THE FOLLOWING ADDRESSES AND ADDRESS ARRAYS ARE SET UP
C          BY   OUTPREP  WHEN IT IS CALLED BY   OUTPUT  .
     7  J1(INGRDUSE),          J2(INGRDUSE),   JADDK2L(INGRDUSE,2),
     8  JADDFNGM(INGRDUSE), JHREC(INGRDUSE),   JHKAP(INGRDUSE),
     9  JSCR2(12),    JSCR3NGM(INGRDUSE,12),   JSCR3OUT(12),
     A  LENGD(INGRDUSE), LTYPE(ILMOUT,INGRDUSE), MB1, MB2, MINT,
     B   MSOUT1,  MSOUT2,  MZGNDOUT,  MNGM3,  MHOUT, MZFR, MZTRO,
     C      MSZGND(INGRDUSE), NGRIDATA(INGRDUSE),
C
C            NUMGDREQ, THE NUMBER OF NGM GRIDS NEEDED TO COVER THE
C            OUTPUT GRID, AND ZLOUT, ARE SET BY  OUTPREP  .
     D                NUMGDREQ,    ZLOUT(ILMOUT),
C
C          OUTPREP ALSO ASSIGNS THE FOLLOWING DESCRIPTORS TO BE
C          USED BY  OUTHORIZ  FOR HORIZONTAL INTERPOLATION.
     E    AHORD,BHORD,CHORD,DHORD, ILLD,IULD,  SCRHORD,  OUTHORD,
C
C
C          THE FOLLOWING ARRAY CONTAINS THE INTEGERS NEEDED TO
C          FORM THE LABEL THAT GOES WITH EACH OUTPUT ARRAY.
     F               LABEL84( 27 ),
C
C          THE FOLLOWING SYMBOLS REPRESENT TEMPORARY VALUES OF
C          INTEGERS TO GO INTO  LABEL84 WHEN THE OUTPUT ARRAY
C          HAS BEEN PREPARED FOR PACKING.
C
     G  LABQTYPE, LABSSUB1, LABTMARK,  S1VALUE,  S2VALUE,
     H  LABMLDIF, LABSSUB2, LABFSUB2, LABKGRID, LABNUMPT
C
C
      COMMON /COM1WAY/ ITIMSTEP, ITBOUND, INGLB
C
         INTEGER IADDRGDP(5,INGRDUSE)
         INTEGER JADDRGDP(5,3)
      DIMENSION COPYSEA(IIJMAX, INGRDUSE )
      DIMENSION COPYSNO(IIJMAX, INGRDUSE )
      DIMENSION COPYWVL(IIJMAX, INGRDUSE )
C
      DIMENSION SPECS(700)
      DIMENSION SPECOPY(700)
C
      DIMENSION ISTROFIL(IMAXOUTT), INTOFIL(IMAXOUTT)
      DIMENSION ISTPOFIL(IMAXOUTT)
      DIMENSION IOUTUOUT(IMAXOUTF, IMAXOUTT)
      DIMENSION DATASET (IMAXOUTF, IMAXOUTT)
      DIMENSION IREFOFLD(IMAXOUTT), INTOFLD (IMAXOUTT)
      DIMENSION ITIMOFLD(IMAXOUTT), ITIMCFIL(IMAXOUTT)
      DIMENSION INUOUT  (IMAXOUTT)
      DIMENSION IFILE(IMAXOUTT), NFILES  (IMAXOUTT)
C
      EQUIVALENCE (DAYMSG1(1), DAYMSG35(1))
C
      CALL W3TAGB('NGM_NGMINI',2000,0040,0098,'NP22')
C
C
C              READ THE DATA CARDS SPECIFYING FULL FIELD OR
C              INCREMENTAL INITIAIZATION AND
C              THE DATA CARDS SPECIFYING THE UNIT NUMBER
C              FOR THE PRINT PRODUCED BY THIS RUN AND INDICATING
C              ON WHAT UNIT ARE THE DATA CARDS SPECIFYING
C              FUNDAMENTAL MODEL OPTIONS.
C     READ (5, 100, END=9998) IOUTUPRT, INUOPTS
      READ (5,  50, END=9998) DATANAME
      READ (5,  75, END=9998) INCRINIT
      READ (5, 100, END=9998) NUMVERT0,NONLOOPB
         IPRTDIAG=0
         IF(NUMVERT0.LT.0) IPRTDIAG=1
         NUMVERTX=INUMVERT
         NUMVERT=MIN(IABS(NUMVERT0),NUMVERTX)
   50 FORMAT (27X, A6 )
   75 FORMAT (27X, I10 )
  100 FORMAT (27X, I10 / 27X, I10 )
         IOUTUPRT=6
         INUOPTS=32
         WRITE(6,149)NONLOOPB,NUMVERT,IPRTDIAG
149      FORMAT(' EXECUTE NGMIINI,',
     *           '  NONLOOPB=',I3,'  NUMVERT=',I3,'  IPRTDIAG=',I3,/,
     *        '   IF IPRTDIAG=0, SUPPRESS MOST OF DIAGNOSTIC PRINT.',
     *        '  TO GET DIAGNOSTIC PRINT, MAKE NUMVERT NEGATIVE ON ',
     *         'INPUT CARD')
C
C              ECHO CHECK THE DATA CARDS JUST READ IN.
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 200) IOUTUPRT, INUOPTS
  200 FORMAT ('0', 'THE UNIT NUMBER FOR THE PRINT PRODUCED BY ',
     1             'THIS RUN IS', I3, '.' /
     2        ' ', 'THE DATA CARDS SPECIFYING FUNDAMENTAL MODEL ',
     3             'OPTIONS WILL BE READ FROM UNIT', I3, '.')
C
C              READ THE DATA CARDS SPECIFYING FUNDAMENTAL MODEL
C              OPTIONS.
      READ (INUOPTS, 300, END=9998)
     1      IRUNMARK,
     2      IVERFCST,
     3      INUINPUT, IOUTURST,
     4      IREFRST,  INTRST,
     5      ISTOPTIM, ITIMSTEP,
     6      IREFSMO,  INTSMO,
     7      IREFBUCK, INTBUCK,
     8      IREFPPTO, INTPPTO,
     9      IREFSIGO, INTSIGO
C
  300 FORMAT (27X, I10   / 27X, I10   / 27X, I10 / 27X, I10 / 27X, I10 /
     1        27X, I10   / 27X, I10   / 27X, I10 / 27X, I10 / 27X, I10 /
     2        27X, I10   / 27X, I10   / 27X, I10 / 27X, I10 / 27X, I10 /
     3        27X, I10 )
C
         IREFDRY  =      0
         INTDRY   =  43200

         IREFDIAG =      0
         INTDIAG  =  21600
C
C              OVERWRITE THE VERSION GIVEN ON THE DATA CARD
C              WITH AN INTEGER GIVING THE YEAR OF THE CENTURY,
C              MONTH, DAY OF THE MONTH, HOUR OF THE DAY, AND MINUTE
C              THAT THE CONTROLLEE ASSOCIATED WITH THIS MAIN
C              PROGRAM WAS CHANGED.
      IVERFCST = 91021914
C
C              WRITE THE VERSION NUMBER OF THIS CONTROLLEE
C              TO THE DAYFILE.
C
      DAYMSG35(1) = ' THE VERSION NUMBER OF THIS CONTROL'
      DAYMSG35(2) = 'LEE IS XXXXXXXXXX.                 '
C
c     NUMBYTES = 10
c     ENCODE (NUMBYTES, 380, DAYMSG1(43)) IVERFCST
c 380 FORMAT (I10)
C
C     CALL Q5SNDMDF ('MSG=', DAYMSG1, 'LEN=', 70, 'BOTH')
C
C
C              ECHO CHECK THE DATA CARDS.
C              (OUTPUT SOME VALUES IN SECONDS AND IN HOURS.)
      SEC2HOUR = 1. / 3600.
      REFRST   = REAL(IREFRST)  * SEC2HOUR
      RSTINT   = REAL(INTRST)   * SEC2HOUR
      TIMESTOP = REAL(ISTOPTIM) * SEC2HOUR
      STEPTIME = REAL(ITIMSTEP) * SEC2HOUR
      REFSMO   = REAL(IREFSMO)  * SEC2HOUR
      SMOINT   = REAL(INTSMO)   * SEC2HOUR
      REFBUCK  = REAL(IREFBUCK) * SEC2HOUR
      BUCKINT  = REAL(INTBUCK)  * SEC2HOUR
      REFPPTO  = REAL(IREFPPTO) * SEC2HOUR
      PPTOINT  = REAL(INTPPTO)  * SEC2HOUR
      REFSIGO  = REAL(IREFSIGO) * SEC2HOUR
      SIGOINT  = REAL(INTSIGO)  * SEC2HOUR
C
      WRITE (IOUTUPRT, 400)
     1       INUOPTS,
     2       IRUNMARK,
     3       IVERFCST,
     4       INUINPUT, IOUTURST,
     5       IREFRST,  REFRST,   INTRST,   RSTINT,
     6       ISTOPTIM, TIMESTOP,
     7       ITIMSTEP, STEPTIME
C
  400 FORMAT ('0', 'THE FOLLOWING FUNDAMENTAL OPTIONS WERE ',
     1             'READ IN FROM DATA CARDS ON UNIT', I3, ':'/
     2        ' ', 5X, 'THE RUN MARKER FOR THIS RUN IS', I2,
     3             ', WHERE 2 INDICATES AN OPERATIONAL RUN.'/
     4 ' ', 5X, 'THE VERSION OF THE INITIALIZATION MODEL IS',I11, '.'/
     5        '0', 5X, 'THE UNIT NUMBER FOR  INPUT OF MODEL ',
     6             'FIELDS FOR STARTING/RESTARTING NOW IS', I3, '.'/
     7        ' ', 5X, 'THE UNIT NUMBER FOR OUTPUT OF MODEL ',
     8             'FIELDS FOR RESTARTING LATER IS', I3, '.'//
     9        ' ', 5X, 'THE REFERENCE TIME FOR OUTPUT OF ',
     1             'MODEL FIELDS FOR RESTARTING LATER IS',
     2             I8, ' SECONDS = ', F8.4, ' HOURS.'/
     3        ' ', 5X, 'THE TIME INTERVAL  FOR OUTPUT OF ',
     4             'MODEL FIELDS FOR RESTARTING LATER IS',
     5             I8, ' SECONDS = ', F8.4, ' HOURS.'//
     6        ' ', 5X, 'THE PLANNED STOP TIME FOR THE FORECAST ',
     7             'AFTER THE TIME OF THE INITIAL CONDITIONS IS',
     8             I8, ' SECONDS = ', F8.4, ' HOURS.'/
     9        ' ', 5X, 'THE TIME STEP FOR GRID A IS',
     1             I8, ' SECONDS = ', F8.4, ' HOURS.'/)
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 500)
     1       IREFSMO,  REFSMO,   INTSMO,   SMOINT,
     2       IREFBUCK, REFBUCK,  INTBUCK,  BUCKINT
C
  500 FORMAT (' ', 5X, 'THE REFERENCE TIME FOR SMOOTHING OF MODEL ',
     1             'FIELDS IS', I8, ' SECONDS = ', F8.4, ' HOURS.'/
     2        ' ', 5X, 'THE TIME INTERVAL  FOR SMOOTHING OF MODEL ',
     3             'FIELDS IS', I8, ' SECONDS = ', F8.4, ' HOURS.'//
     4        ' ', 5X, 'THE REFERENCE TIME FOR EMPTYING THE ',
     5             'PRECIPITATION BUCKETS IS',
     6             I8, ' SECONDS = ', F8.4, ' HOURS.'/
     7        ' ', 5X, 'THE TIME INTERVAL  FOR EMPTYING THE ',
     8             'PRECIPITATION BUCKETS IS',
     9             I8, ' SECONDS = ', F8.4, ' HOURS.'/ )
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 550)
     1       IREFPPTO, REFPPTO,  INTPPTO,  PPTOINT,
     2       IREFSIGO, REFSIGO,  INTSIGO,  SIGOINT
C
C
  550 FORMAT (' ', 5X, 'THE REFERENCE TIME FOR PRINTING THE ',
     1             'PRECIPITATION DIAGNOSTICS IS',
     2             I8, ' SECONDS = ', F8.4, ' HOURS.'/
     3        ' ', 5X, 'THE TIME INTERVAL  FOR PRINTING THE ',
     4             'PRECIPITATION DIAGNOSTICS IS',
     5             I8, ' SECONDS = ', F8.4, ' HOURS.'//
     6        ' ', 5X, 'THE REFERENCE TIME FOR PRINTING THE ',
     7             'POINT SURFACE PRESSURE AND RMS SIGMA DOT IS',
     8             I8, ' SECONDS = ', F8.4, ' HOURS.'/
     9        ' ', 5X, 'THE TIME INTERVAL  FOR PRINTING THE ',
     1             'POINT SURFACE PRESSURE AND RMS SIGMA DOT IS',
     2             I8, ' SECONDS = ', F8.4, ' HOURS.')
C
C              READ IN THE START/RESTART FIELDS FROM DISK.
C     READ (INUINPUT) SPECS, VBL, IBITSEA, IBITSNO, IBITWVL
C
      CALL RESTARTR( INUINPUT, IOUTUPRT, SPECS, VBL, BITSEA, BITSNO,
     *               BITWVL )
C
C              COPY ELEMENTS FROM THE SPECS ARRAY.
      IVERINPT = NINT (SPECS(1))
C
      GMT0     = SPECS(2)
      DAY0     = SPECS(3)
      AMONTH0  = SPECS(4)
      CENYEAR0 = SPECS(5)
C
      JMAXANAL = NINT(SPECS(401))
      IMAXANAL = NINT(SPECS(402))
C
      LATG = NINT (SPECS(11))
      LONF = NINT (SPECS(12))
      LEVS = NINT (SPECS(13))
      LEVH = NINT (SPECS(14))
C
      KM   = NINT (SPECS(13))
C
      DO 700 K=1, KM
         DELSIG(K) = SPECS(21 + K)
  700 CONTINUE
C
      NH      = NINT( SPECS(131))
      NGRDUSE = NINT( SPECS(132))
      DLAMNGM =       SPECS(133)
C
      DO 800 NG=1, NGRDUSE
         IMG(NG)    = NINT (SPECS(140 + NG))
         JMG(NG)    = NINT (SPECS(150 + NG))
         XPOLEH(NG) =       SPECS(200 + NG)
         YPOLEH(NG) =       SPECS(210 + NG)
  800 CONTINUE
C
      NGRDUSM1 = NGRDUSE - 1
      DO 900 NG = 1, NGRDUSM1
         IAG(NG) = NINT (SPECS(160 + NG))
         IBG(NG) = NINT (SPECS(170 + NG))
         JAG(NG) = NINT (SPECS(180 + NG))
         JBG(NG) = NINT (SPECS(190 + NG))
  900 CONTINUE
C
      IBUCKET = NINT (SPECS(243))
      BUCKETI = SPECS(243) * SEC2HOUR
C
      ITIME0  = NINT (SPECS(233))
      ITIME   = ITIME0
      TIMEHRS = REAL(ITIME) * SEC2HOUR
      TIMEI0  = SPECS(233) * SEC2HOUR
C
      NSTEPS0 = NINT (SPECS(234))
      NSTEPS  = NSTEPS0
C
C              PRINT THE VALUES OF PARAMETERS IN ARRAY SPECS READ IN
C              FROM DISK.
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1000)
     1       INUINPUT,
     2       IVERINPT,
     3       GMT0, DAY0, AMONTH0, CENYEAR0,
     4       ITIME0, TIMEI0, NSTEPS0,
     5       IBUCKET, BUCKETI
C
 1000 FORMAT ('0', 'THE FOLLOWING FUNDAMENTAL PARAMETERS WERE READ ',
     1             'IN FROM ARRAY SPECS ON UNIT', I3, ':' /
     2        ' ', 5X, 'THE VERSION OF THE INPUT MODEL IS', I11, '.' /
     3        '0', 5X, 'THE TIME OF THE INITIAL CONDITIONS IS ',
     4             F3.0, ' GMT ', F3.0, ' / ', F3.0, ' / ', F3.0 /
     5        '0', 5X, 'THE TIME SINCE THE INITIAL CONDITIONS AT ',
     6             'WHICH THE FORECAST IS BEING INITIALIZED IS',
     7             I8, ' SECONDS =', F8.4, ' HOURS.'/
     8        '0', 5X, 'THE NUMBER OF TIME STEPS INTO THE FORECAST AT',
     9             ' WHICH THE FORECAST IS BEING INITIALIZED IS',
     1             I5, '.'/
     2        '0', 5X, 'THE TIME SINCE THE INITIAL CONDITIONS AT ',
     3             'WHICH THE PRECIPITATION BUCKETS WERE LAST ',
     4             'EMPTIED IS', I8, ' SECONDS =', F8.4, ' HOURS.')
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1050)
     1       JMAXANAL, IMAXANAL,
     2       LATG, LONF, LEVS, LEVH
C
 1050 FORMAT ('0', 5X, 'THE RESOLUTION OF THE ANALYSIS ON THE ',
     1             'LATITUDE/LONGITUDE GRID WAS:'/
     2        ' ', 9X, 'NUMBER OF LATITUDES  =', I4 /
     3        ' ', 9X, 'NUMBER OF LONGITUDES =', I4 /
     4        '0', 5X, 'THE RESOLUTION OF THE INITIAL CONDITIONS ',
     5             'ON THE LATITUDE/LONGITUDE GRID WAS:'/
     6        ' ', 9X, 'LATG =', I4 /
     7        ' ', 9X, 'LONF =', I4 /
     8        ' ', 9X, 'LEVS =', I4 /
     9        ' ', 9X, 'LEVH =', I4 , '.')
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1100)
     1       KM, (K, DELSIG(K), K=KM, 1, -1)
C
 1100 FORMAT ('0', 5X, 'THE NUMBER OF FORECAST LAYERS IS', I3, '.'/
     1        '0', 5X, 'THE SIGMA THICKNESSES OF THESE LAYERS ARE:'/
     2       (' ', 9X, 'DELSIG(', I3, ') =', 1PE14.6))
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1200) NH, DLAMNGM, NGRDUSE
C
 1200 FORMAT ('0', 5X, 'THE NUMBER OF GRID POINTS (MINUS 0.5) ',
     1             'ON GRID A BETWEEN THE POLE AND THE EQUATOR ',
     2             'IS', I3, '.'/
     3        ' ', 5X, 'THE ROTATION ANGLE OF THE POSITIVE X AXIS ',
     4             'COUNTERCLOCKWISE FROM THE GREENWICH MERIDIAN ',
     5             'IS', F8.3, '.'/
     6        ' ', 5X, 'THE NUMBER OF FORECAST GRIDS IS', I2, '.'/
     7        '0', 5X, 'INDIVIDUAL GRID PARAMETERS:'/
     8        ' ', T10, 'GRID', T20, 'IMG', T30, 'JMG',
     9             T40, 'XPOLEH', T50, 'YPOLEH', T60, 'IAG',
     1             T70, 'IBG', T80, 'JAG', T90, 'JBG' /)
C
      DO 1400 NG = 1, NGRDUSE
         IF (NG .EQ. NGRDUSE) THEN
            IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1300)
     1             NG, IMG(NG), JMG(NG), XPOLEH(NG), YPOLEH(NG)
C
 1300       FORMAT (' ', T10, I3, T20, I3, T30, I3, T38, F8.3,
     1                   T48, F8.3, T60, I3, T70, I3,
     2                   T80, I3, T90, I3)
C
         ELSE
            IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1300)
     1             NG, IMG(NG), JMG(NG), XPOLEH(NG), YPOLEH(NG),
     2             IAG(NG), IBG(NG), JAG(NG), JBG(NG)
         END IF
 1400 CONTINUE
C
C             STORE INTO ARRAY SPECS THE FUNDAMENTAL MODEL OPTIONS
C             INPUT FROM DATA CARDS IN THIS STEP.  PREVIOUSLY
C             SPECIFIED VALUES OF THESE OPTIONS IN ARRAY SPECS
C             WILL BE OVERWRITTEN.
      SPECS(231) = REAL (IVERFCST)
      SPECS(232) = REAL (ITIMSTEP)
      SPECS(235) = REAL (IRUNMARK)
C
      SPECS(241) = REAL (IREFBUCK)
      SPECS(242) = REAL (INTBUCK)
C
      SPECS(251) = REAL (IREFSMO)
      SPECS(252) = REAL (INTSMO)
C
      SPECS(261) = ANEM
      SPECS(262) = ANSIN
      SPECS(263) = ANCOS
      SPECS(264) = ALIM
      SPECS(265) = SCALEHT
C
      SPECS(271) = REAL (IOUTUPRT)
      SPECS(272) = REAL (INUOPTS)
      SPECS(273) = REAL (INUINPUT)
      SPECS(274) = REAL (IOUTURST)
      SPECS(275) = REAL (IREFRST)
      SPECS(276) = REAL (INTRST)
C
      SPECS(281) = REAL (IREFSIGO)
      SPECS(282) = REAL (INTSIGO)
      SPECS(283) = REAL (IBARO)
      SPECS(284) = REAL (JBARO)
C
      SPECS(291) = REAL (IREFPPTO)
      SPECS(292) = REAL (INTPPTO)
C
C              CALCULATE THE STARTING ADDRESSES FOR THE VARIOUS
C              FIELDS OF ARRAY VBL.
      LSTART = 1
      LSTARTDP=1
C
      DO 1460 NG=1, NGRDUSE
         IJ  = IMG(NG) * JMG(NG)
         IJK = IJ * KM
C
         DO 1420 LVAR=1, 4
            IADDRG (LVAR, NG) = LSTART
            LSTART = LSTART + IJK
              IADDRGDP(LVAR,NG)=LSTARTDP
              LSTARTDP=LSTARTDP+IJK
 1420    CONTINUE
            IADDRGDP(5,NG)=LSTARTDP
            LSTARTDP=LSTARTDP+IJ
C
         DO 1440 LVAR=5, 13
            IADDRG (LVAR, NG) = LSTART
            LSTART = LSTART + IJ
 1440    CONTINUE
C
         LVAR = 14
         IADDRG (LVAR, NG) = LSTART
         LSTART = LSTART + IJK
C
         DO 1445 LVAR=15, 22
            IADDRG (LVAR, NG) = LSTART
            LSTART = LSTART + IJ
 1445    CONTINUE
C
         LVAR = 23
         IADDRG (LVAR, NG) = LSTART
         LSTART = LSTART + IJK
C
         DO 1446 LVAR=24, 37
            IADDRG (LVAR, NG) = LSTART
            LSTART = LSTART + IJ
 1446    CONTINUE
C
         LVAR = 38
         IADDRG (LVAR, NG) = LSTART
         LSTART = LSTART + IJK
C
         DO 1447 LVAR=39, 44
            IADDRG (LVAR, NG) = LSTART
            LSTART = LSTART + IJ
 1447    CONTINUE
C
 1460 CONTINUE
C
      LSTOP = LSTART - 1
      DO 1462 LEVELSTR=1,3
        DO 1461 LVAR=1,4
          JADDRGDP(LVAR,LEVELSTR)=LSTARTDP
          LSTARTDP=LSTARTDP+IIJKMAX
1461    CONTINUE
        JADDRGDP(5,LEVELSTR)=LSTARTDP
        LSTARTDP=LSTARTDP+IIJMAX
1462  CONTINUE
      LSTOPDP=LSTARTDP-1
      Ndpfillr=Idpfillr
      WRITE(6,1479)LSTOPDP,Ndpfillr
1479   FORMAT(' LSTOPDP,Ndpfillr=',2I16,/,
     *   ' IF LSTOPDP > Ndpfillr, UNPREDICTABLE RESULTS WILL FOLLOW')
C     IF(LSTOPDP.GT.Ndpfillr) STOP 'dpfillr ARRAY TOO SMALL IN HNGMDNI'
C
C              PRINT THE STARTING ADDRESSES.
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1480)
     1      ((LVAR, NG, IADDRG(LVAR, NG), LVAR=1,44), NG=1, NGRDUSE)
C
 1480 FORMAT ('0', 'THE STARTING ADDRESSES FOR THE VARIOUS FIELDS ',
     1             'OF ARRAY VBL ARE LISTED NEXT, WHERE IADDRG IS ',
     2             'IADDRG (VARIABLE NUMBER, GRID NUMBER) :' //
     3       (' ', 5X, 'IADDRG(', I2, ',', I2, ') =', I10 ))
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1490) LSTOP
 1490 FORMAT ('0', 5X, 'LAST LOCATION =', I10 / )
C
C              THE PL/I PARAMETERS THAT ARE USED IN STATEMENTS
C              BESIDE DIMENSION STATEMENTS ARE MATERIALIZED.
      IJMAX    = IIJMAX
      LMOUT    = ILMOUT
      LVLTOT   = ILVLTOT
      IJRAD    = IIJRAD
      MAXOUTF  = IMAXOUTF
      MAXOUTT  = IMAXOUTT
      MAXOUTV  = IMAXOUTV
      NSCR     = INSCR
      NSCRGEO  = INSCRGEO
      NSCR3    = INSCR3
C
C              THOSE PL/I PARAMETERS THAT ARE USED ONLY IN
C              DIMENSION STATEMENTS ARE MATERIALIZED.
      IJKMAX0  = IIJKMAX
      IJMAXB0  = IIJMAXB
      IWORDSB0 = IIWORDSB
      KM0      = IKM
      KMP10    = IKMP1
      LBCH0    = ILBCH
      LBHI0    = ILBHI
      LBUI0    = ILBUI
      LBUO0    = ILBUO
      LBVI0    = ILBVI
      LBVO0    = ILBVO
      MAXPROF  = IMAXPROF
      NGUSE0   = INGRDUSE
      NGUSM10  = INGRDUS1
      NH0      = INH
      NIADRS0  = INIADDRS
      NSHEM0   = INSHEM
      NSUMG0   = INSUMG
      NVBL0    = INVBL
C
C              PRINT THE PL/I PARAMETERS USED IN THIS COMPILATION.
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1500)
     1       IJKMAX0, IJMAX, IJMAXB0, IWORDSB0, KM0,   IJRAD,
     2       KMP10,   LBCH0, LBHI0,   LBUI0,    LBUO0, LBVI0, LBVO0
C
 1500 FORMAT(/'0', 'THE FOLLOWING PL/I PARAMETERS WERE SPECIFIED ',
     1             'BEFORE COMPILATION OF THIS INITIALIZATION CODE:'/
     2        ' ', 5X, 'IJKMAX0 =', I8, ',', 5X, 'IJMAX   =', I8, ',',
     3             5X, 'IJMAXB0 =', I8, ',',
     4             5X, 'IWORDSB0=', I8, ',', /
     5        ' ', 5X, 'KM0     =', I8, ',', 5X, 'IJRAD   =', I8, ',',
     6             5X, 'KMP10   =', I8, ',', /
     7        ' ', 5X, 'LBCH0   =', I8, ',', 5X, 'LBHI0   =', I8, ',',
     8             5X, 'LBUI0   =', I8, ',', 5X, 'LBUO0   =', I8, ','/
     9        ' ', 5X, 'LBVI0   =', I8, ',', 5X, 'LBVO0   =', I8, ',')
C
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 1600)
     1       LMOUT,  LVLTOT,  MAXOUTF, MAXOUTT, MAXOUTV,  MAXPROF,
     2       NFILLER,
     3       NGUSE0, NGUSM10, NH0,     NIADRS0, NSCR,   NSCRGEO,
     4       NSCR3,  NSHEM0,  NSUMG0,   NVBL0
C
 1600 FORMAT (' ', 5X, 'LMOUT   =', I8, ',', 5X, 'LVLTOT  =', I8, ',',
     1             5X, 'MAXOUTF =', I8, ',', 5X, 'MAXOUTT =', I8, ','/
     2        ' ', 5X, 'MAXOUTV =', I8, ',', 5X, 'MAXPROF =', I8, ','/
     3        ' ', 5X, 'NFILLER =', I8, ',', 5X, 'NGUSE0  =', I8, ','/
     4             5X, 'NGUSM10 =', I8, ',', 5X, 'NH0     =', I8, ','/
     5        ' ', 5X, 'NIADRS0 =', I8, ',',
     6             5X, 'NSCR    =', I8, ',',
     7             5X, 'NSCRGEO =', I8, ',', 5X, 'NSCR3   =', I8, ','/
     8        ' ', 5X, 'NSHEM0  =', I8, ',', 5X, 'NSUMG0  =', I8, ',',
     9           5X, 'NVBL0   =', I8, '.' / )
C
C              TEST THE CONSISTENCY OF THE PL/I PARAMETERS WITH THE
C              FUNDAMENTAL MODEL OPTIONS.
C*************
C************* THIS SECTION HAS NOT BEEN COMPLETED YET.
C*************
C
C              SPECIFY FUNDAMENTAL PHYSICAL AND GEOGRAPHICAL CONSTANTS
C              AND THEIR DERIVATIVES.
      RADIUS = 6371.22E3
      ANGVEL = 7.292116E-5
C
      RGASD    = 287.05
      CSUBP    = 1005.
C
      CKAPPA   = RGASD / CSUBP
      CKAPPAI  = CSUBP / RGASD
      CKAPPAP1 = CKAPPA+1.
C
C              CALCULATE DERIVATIVE GRID AND TIME STEPPING INFORMATION.
      DELTAXA = (2.0 * RADIUS) / (REAL(NH) + 0.5)
      DELTATA = REAL (ITIMSTEP)
      DTOVDX  = DELTATA / DELTAXA
C
C*****IJMAX = 0
C*****DO 1700 NG=1, NGRDUSE
C*****   IJMAX = MAX (IJMAX, IMG(NG) * JMG(NG))
C1700 CONTINUE
C*****
C*****IJMAX = ((IJMAX + 1) / 2) * 2
C
C              CALCULATE THE INTERFACE VALUES OF SIGMA.
      SIGINT(1) = 0.
C
      DO 1800 K=1, KM
         SIGINT(K+1) = SIGINT(K) + DELSIG(K)
 1800 CONTINUE
C
      SIGINT(KM+1) = 1.
C
C              COMPUTE PR(K), WHICH WHEN MULTIPLIED BY 2 TIMES
C              H ** KAPPA YIELDS PI, THE EXNER FUNCTION.
      PR(1) = 1.
C
      DO 1900 K=2, KM
         ONEMSIG = 1.-SIGINT(K)
         PR(K) = REAL( ONEMSIG ** CKAPPAP1)
 1900 CONTINUE
C
      C1 = 1.0 / (2. * REAL (CKAPPAP1))
C
      DO 2000 K=1, KM-1
         PR(K) = C1 * (PR(K) - PR(K+1) ) / DELSIG(K)
 2000 CONTINUE
C
      PR(KM) = C1 * PR(KM) / DELSIG(KM)
C
C              CALCULATE PRESS(K), WHICH WHEN MULTIPLIED BY
C              H (THE SURFACE PRESSURE) YIELDS THE LAYER PRESSURE.
      DO 2100 K=1, KM
         PRESS(K) = (2.*PR(K))**CKAPPAI
 2100 CONTINUE
C
C              PRINT THE VERTICAL FUNCTIONS.
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 2500) SIGINT (KM + 1)
C
 2500 FORMAT ('0', 'THE VERTICAL FUNCTIONS FOR THE FORECAST MODEL ',
     1             'ARE:'/
     2        '0', T8, 'K', T17, 'DELSIG', T32, 'SIGINT',
     3             T48, 'PRESS', T64, 'PR', T83, 'PR'/
     4        ' ', T30, 0PF9.7)
C
      DO 2700 K= KM, 1, -1
         IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 2600)
     1          K, DELSIG(K), PRESS(K), PR(K), PR(K), SIGINT(K)
C
 2600    FORMAT (' ', T6, I3, T15, F9.7, T45, F9.7, T60, F9.7,
     1                T77, 1PE13.6 /
     2           ' ', T30, 0PF9.7 )
C
 2700 CONTINUE
C
C              PLACE THE BIT VECTOR INDICATING THE LOCATION OF
C              THE SEA INTO ARRAY BITSEA.  THIS IS NECESSARY
C              BECAUSE THIS BIT VECTOR COULD NOT BE WRITTEN
C              TO DISK WITH AN UNFORMATED FORTRAN WRITE STSTEMENT.
C     DO 2750 NG=1, NGRDUSE
C        BITSEA(1, NG; IJMAX) = BITSEA0(1, NG; IJMAX)
C        BITSNO(1, NG; IJMAX) = BITSNO0(1, NG; IJMAX)
C        BITWVL(1, NG; IJMAX) = BITWVL0(1, NG; IJMAX)
C****    BITSEA(1, NG; IJMAX) = Q8VMKZ(1,1; BITSEA(1, NG; IJMAX))
C
C****    IM = IMG(NG)
C****    JM = JMG(NG)
C****1                  'BITSEA                 ')
C2750 CONTINUE
C
C              SET UP THE ARRAYS NEEDED FOR APPLYING THE EQUATORIAL
C              SYMMETRY CONDITIONS.  ALSO, BIT VECTORS ARE SET TO
C              INDICATE THE NONFORECAST POINTS NEAR THE EQUATOR.
      CALL SHEMPRE (NH)
C
      IF(NGRDUSE .GT. 1 ) THEN
C
C              FOR EACH OF THE INTERIOR GRIDS, THE BIT VECTORS
C              ARE SET TO INDICATE FORECAST POINTS.  THE
C              EXISTENCE OF A HOLE OF NONFORECAST POINTS
C              IS NOT CONSIDERED YET.
C  **********  NOTE: HOLES NOT ALLOWED FOR INITIALIZATION!!!
         DO 2800 NG=2,NGRDUSE
            CALL BITOUT (BITGRDH (1, 1, NG),
     1                   BITGRDU (1, 1, NG),
     2                   BITGRDV (1, 1, NG),
     3                   IMG(NG), JMG(NG), NG)
 2800    CONTINUE
C
C
      END IF
C
C              CALCULATE AND PRINT THE NUMBER OF H FORECAST POINTS
C              FOR EACH GRID FOR EACH PAIR OF TIME STEPS.
      IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 3150)
 3150 FORMAT ('0', 'THE NUMBER OF FORECAST POINTS ON:' )
C
      DO 3400 NG=1, NGRDUSE
         IJ = IMG(NG) * JMG(NG)
C
         DO 3300 NPAIR=1, 2
            NPTSFH(NPAIR, NG)=0
            DO 33002 I=1,IJ
              IF(BITGRDH(I,NPAIR,NG))
     *             NPTSFH(NPAIR,NG)=NPTSFH(NPAIR,NG)+1
33002       CONTINUE
            IF ((NG .EQ. 1) .AND. (NPAIR .EQ. 2)) GO TO 3300
C
            PERCENT = 100. * REAL(NPTSFH(NPAIR, NG)) / REAL(IJ)
C
            IF(IPRTDIAG.NE.0) WRITE (IOUTUPRT, 3200)
     1             NG, NPAIR, NPTSFH(NPAIR, NG), IJ, PERCENT
 3200       FORMAT (' ', 5X, 'GRID',
     1                   I2, ' FOR NPAIR=', I2, ' IS', I6,
     2                   ' OUT OF A TOTAL OF', I6, ' POINTS, WHICH IS',
     3                   F5.1, ' PERCENT.')
 3300    CONTINUE
C
 3400 CONTINUE
         KHINTERP =  2 * KM + 1
C        KHINTERP=LVLTOT-2*KM
C
C             READ IN PARAMETERS FOR PROFILER SITES
C     READ(INUOPTS, 3633, END=9998 )  NUMPROF
C3633 FORMAT (27X, I10)
C     WRITE(IOUTUPRT, 3634) NUMPROF
C3634 FORMAT('0', 'THERE ARE', I3, ' PROFILER SITES:'/)
C
C     IF( NUMPROF .GT. 0 ) THEN
C
C        DO 3637 N = 1, NUMPROF
C           READ(INUOPTS, 3635, END=9998 ) PROFLAT(N), PROFLON(N)
C3635       FORMAT(27X, F10.1, 3X, F10.1)
C
C           WRITE (IOUTUPRT, 3636) N, PROFLAT(N), PROFLON(N)
C3636       FORMAT(' ', 5X, 'PROFILER SITE NUMBER', I3,
C    1           ' HAS (LATITUDE, LONGITUDE) = (', F8.3,
C    2           ',', F9.3, ').')
C
C3637    CONTINUE
C
C     END IF
C--------
C--------MAKE SURE BOUNDARIES ARE CORRECT FOR VBL. ALSO COPY VBL.
C--------
         LHINTERP=2*KM+7
         DO 3655 NG=1,NGRDUSE
           IF(NG.GT.1) THEN
             NGM=NG-1
             CALL LATBND(NGM,LHINTERP)
           ELSE
             CALL SHEM(LHINTERP)
           END IF
           MCOPY=IADDRGDP(1,NG)
           CALL CFROMVBL(dpfillr,NG,IADDRGDP)
3655     CONTINUE
         IF(NONLOOPB.EQ.0) GO TO 3945
C              AT THIS POINT WE SHOULD HAVE ENOUGH TO START
C              INITIALIZATION ITERATIONS.
C
C-------
C------- FIRST SEE IF FIRST GUESS FIELDS ARE AVAILABLE. IF SO, THEN READ
C-------  FIRST GUESS INTO VBL AND ADJUST BOUNDARIES.
C-------
         LFRSTGES=.TRUE.
         SPECOPY(141)=0.
C
C        CALL RESTARTR(20, IOUTUPRT, SPECOPY, VBL, COPYSEA, COPYSNO,
C    *                 COPYWVL)
C
C        IF( IERR .EQ. 0) THEN
C          IF( SPECOPY(141) .NE. SPECS(141)  .OR.
C    *         SPECOPY(151) .NE. SPECS(151)  .OR.
C    *         SPECOPY(201) .NE. SPECS(201)  .OR.
C    *         SPECOPY(211) .NE. SPECS(211) ) LFRSTGES=.FALSE.
C        ELSE
C          LFRSTGES = .FALSE.
C          IF( IERR .EQ. 1 ) THEN
C            WRITE (6, 613)
C613         FORMAT(' ERROR READING FROM FIRST GUESS FILE.  DO FULL',
C    *              ' FIELD INITIALIZATION.')
C          ELSE
C            WRITE (6, 615)
C615         FORMAT(' END FILE WHILE READING FROM FIRST GUESS FILE.',
C    *              '  DO FULL FIELD INITIALIZATION.')
C          END IF
C        END IF
C
       IF( INCRINIT .EQ. 1 ) THEN
         CALL RESTARTR(20, IOUTUPRT, SPECOPY, VBL, COPYSEA, COPYSNO,
     *                 COPYWVL)
C
         IF( SPECOPY(141) .NE. SPECS(141)  .OR.
     *       SPECOPY(151) .NE. SPECS(151)  .OR.
     *       SPECOPY(201) .NE. SPECS(201)  .OR.
     *       SPECOPY(211) .NE. SPECS(211) ) LFRSTGES=.FALSE.
       ELSE
         LFRSTGES = .FALSE.
             WRITE (6, 613)
 613         FORMAT(' ONLY ONE RESTART FILE.  DO FULL FIELD ',
     *              'INITIALIZATION.')
       END IF
C
C        READ(20,ERR=612,END=614)SPECOPY,VBL,ICOPYSEA,ICOPYSNO,ICOPYWVL
C        IF(SPECOPY(141).NE.SPECS(141).OR.
C    *      SPECOPY(151).NE.SPECS(151).OR.
C    *      SPECOPY(201).NE.SPECS(201).OR.
C    *      SPECOPY(211).NE.SPECS(211)) LFRSTGES=.FALSE.
C        GO TO 616
C612      CONTINUE
C          LFRSTGES=.FALSE.
C          WRITE(6,613)
C613        FORMAT(' ERROR READING FROM FIRST GUESS FILE.  DO FULL',
C    *              ' FIELD INITIALIZATION.')
C          GO TO 616
C614      CONTINUE
C          LFRSTGES=.FALSE.
C          WRITE(6,615)
C15        FORMAT(' END FILE WHILE READING FROM FIRST GUESS FILE.  DO',
C    *              ' FULL FIELD INITIALIZATION.')
C16      CONTINUE
         IF(LFRSTGES) THEN
           WRITE(6,617)
617        FORMAT(' WE HAVE FIRST GUESS FIELDS, SO DO INCREMENT ',
     *            'INITIALIZATION.')
C----------
C----------MAKE SURE BOUNDARIES ARE CORRECT FOR FIRST GUESS FIELDS.
C----------
           DO 618 NG=1,NGRDUSE
             IF(NG.GT.1) THEN
               NGM=NG-1
               CALL LATBND(NGM,LHINTERP)
             ELSE
               CALL SHEM(LHINTERP)
             END IF
618        CONTINUE
         END IF
C
C-------- FIRST SET UP R00 FROM FIRST GUESS (SETUPR00 JUST
C-------- ZEROES OUT R00 IF FIRST GUESS NOT AVAILABLE).
C--------
         M1U=JADDRGDP(1,1)
         M1V=JADDRGDP(2,1)
         M1T=JADDRGDP(3,1)
         M1Q=JADDRGDP(4,1)
         M1H=JADDRGDP(5,1)
         M2U=JADDRGDP(1,2)
         M2V=JADDRGDP(2,2)
         M2T=JADDRGDP(3,2)
         M2Q=JADDRGDP(4,2)
         M2H=JADDRGDP(5,2)
         M3U=JADDRGDP(1,3)
         M3V=JADDRGDP(2,3)
         M3T=JADDRGDP(3,3)
         M3Q=JADDRGDP(4,3)
         M3H=JADDRGDP(5,3)
         CALL SETUPR00(dpfillr,LFRSTGES,
     *dpfillr(M1U),dpfillr(M1V),dpfillr(M1T),dpfillr(M1Q),dpfillr(M1H),
     *dpfillr(M2U),dpfillr(M2V),dpfillr(M2T),dpfillr(M2Q),dpfillr(M2H),
     *dpfillr(M3U),dpfillr(M3V),dpfillr(M3T),dpfillr(M3Q),dpfillr(M3H),
     *         IADDRGDP)
C--------
C-------- COMMUNICATE VERTICAL SIGMA STRUCTURE TO VERT-MODE PACKAGE
C--------
         CALL SETDSIG(DELSIG)
         DO 3900 LOOPBIG=1,NONLOOPB
           IF(IPRTDIAG.NE.0) WRITE(6,3740)LOOPBIG
3740       FORMAT(' BEGIN BIG LOOP FOR NGMIINI, LOOPBIG=',I3)
             CALL TIMESMOO(dpfillr,NUMVERT,
     *dpfillr(M1U),dpfillr(M1V),dpfillr(M1T),dpfillr(M1Q),dpfillr(M1H),
     *dpfillr(M2U),dpfillr(M2V),dpfillr(M2T),dpfillr(M2Q),dpfillr(M2H),
     *dpfillr(M3U),dpfillr(M3V),dpfillr(M3T),dpfillr(M3Q),dpfillr(M3H),
     *       IADDRGDP,LOOPBIG,NONLOOPB)
3900     CONTINUE
         CALL BALPRNT(NONLOOPB,NUMVERT)
C--------
C-------- RESTORE ALL BUT HU,HV,HTHETA,HQ, AND H FROM INPUT FILE.
C-------- THIS MAY BE REDUNDANT, BUT DO FOR NOW TO BE SAFE.
C--------
         DO 3920 NG=1,NGRDUSE
           MCOPY=IADDRGDP(1,NG)
           CALL CFROMVBL(dpfillr,NG,IADDRGDP)
3920     CONTINUE
         REWIND INUINPUT
C        READ (INUINPUT) SPECS, VBL, IBITSEA, IBITSNO, IBITWVL
C
         CALL RESTARTR( INUINPUT, IOUTUPRT, SPECS, VBL, BITSEA,
     *                  BITSNO, BITWVL )
C
C--------
C-------- CALL LATBND, SHEM ONCE AGAIN, SO TERRAIN IS CORRECT.
C--------
         LHINTERP=2*KM+7
         DO 3939 NG=1,NGRDUSE
           IF(NG.GT.1) THEN
             NGM=NG-1
             CALL LATBND(NGM,LHINTERP)
           ELSE
             CALL SHEM(LHINTERP)
           END IF
3939     CONTINUE
         DO 3940 NG=1,NGRDUSE
           MCOPY=IADDRGDP(1,NG)
           CALL DTOVBL(dpfillr,NG,IADDRGDP,IPRTDIAG)
3940     CONTINUE
3945     CONTINUE
            REWIND IOUTURST
C           WRITE (IOUTURST) SPECS, VBL, IBITSEA, IBITSNO, IBITWVL
C
            CALL RESTARTW( IOUTURST, IOUTUPRT, DATANAME, SPECS, VBL,
     *                     BITSEA, BITSNO, BITWVL )
C
            IF(NONLOOPB.NE.0) WRITE (IOUTUPRT, 4700)
 4700       FORMAT('0', 'INITIALIZATION COMPLETE, WITH RESTART FILE',
     1                  ' WRITTEN TO DISK.')
            IF(NONLOOPB.EQ.0) WRITE (IOUTUPRT, 4702)
 4702       FORMAT('0', 'INITIALIZATION SKIPPED, BUT RESTART FILE',
     1                  ' STILL WRITTEN TO DISK.')
C
C              THE STEP REACHED THE NORMAL TERMINATION POINT.
      WRITE (IOUTUPRT, 9000)
 9000 FORMAT ('0', 'NGMIINI TERMINATED AT THE NORMAL LOCATION IN ',
     1             'THE CODE.')
C
C              PRINT THE CURRENT WALL TIME.
C
      WRITE (IOUTUPRT, 9100)
 9100 FORMAT ('0'///)
C
C     CALL DIAGFCST
C*****************************************
C
      CALL W3TAGE('NGM_NGMINI')
C
C              TERMINATE THE JOB.  SUBROUTINE Q5TERM IS USED INSTEAD
C              OF THE STOP COMMAND TO SAVE ONE PAGE OF PAPER EACH
C              TIME THE CONTROLLEE IS EXECUTED.
C     CALL Q5TERM
C
C              THE NEXT LINE IS INCLUDED TO PREVENT A WARNING
C              MESSAGE FROM THE COMPILER.
      STOP
C
C
C
 9998 CONTINUE
C              WE HIT THE INPUT END-OF-FILE.  THIS SHOULD NOT HAVE
C              HAPPENED.
      WRITE (IOUTUPRT, 9999)
 9999 FORMAT ('0', 'INPUT END-OF-FILE ENCOUNTERED AT THE WRONG PLACE ',
     1             'WHEN READING DATA CARDS SPECIFYING ',
     2             'FUNDAMENTAL MODEL OPTIONS.'/
     3        '0', 11X, 'EXECUTION TERMINATING.' /////)
C
      CALL W3TAGE('NGM_NGMINI')
C
C              TERMINATE THE CONTROLLEE WITH A RETURN CODE OF 8.
      ERRMSG(1) = 'IN THE MAIN CODE NEAR STATEMENT NUM'
      ERRMSG(2) = 'BER 9999:                          '
      ERRMSG(3) = 'INPUT EOF ENCOUNTERED AT WRONG PLAC'
      ERRMSG(4) = 'E WHEN READING DATA CARDS.         '
C
C     CALL ERRSTOP (IOUTUPRT, ERRMSG)
C
      END
