      SUBROUTINE OUTPREP
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OUTPREP     PREPARE SCRATCH ARRAYS, ETC.
C   PRGMMR: N PHILLIPS       ORG: W/NMC22    DATE: 84-01-15
C
C ABSTRACT: WORKING SCRATCH SPACE FOR THIS SUBROUTINE, SUBROUTINE
C   OUTPUT, AND THE MANY CODES CALLED BY SR  OUTPUT  , IS SET UP
C   BY THIS SUBROUTINE. IT DOES THIS BY EQUIVALENCING THE SCRATCH
C   SPACE IN  BLANK COMMON (INCLUDED MEMBER COMBLANK) STARTING WITH
C   ARRAY  SCR(1,1).  HALF PRECISION, INTEGER AND BIT SPACE IS SET
C   UP IN ARRAYS  S,  IN,  AND BITS.  POINTER LOCATIONS IN THESE 3
C   ARRAYS ARE SET UP BY THIS CODE AND STORED IN VARIOUS ARRAYS IN
C   INCLUDED COMMON MEMBER  COMOUT  .
C   ** THIS PROCEDURE SEEMS NECESSARY TO ACCOMODATE AN OUTPUT GRID
C   ** OF VARYING DIMENSIONS WITHIN A SINGLE COMPUTER RUN AND TO ALSO
C   ** MINIMIZE PAGING BY REUSING SCRATCH SPACE FROM THE FORECAST
C   ** OPERATIONS.(NOTE THE ABSENCE OF A PLI VARIABLE FOR  IJOUT .)
C   .
C   GATHER INTEGERS AND INTERPOLATION CONSTANTS ARE ALSO SET UP
C   BY THIS ROUTINE TO ALLOW THE FOLLOWING OPERATIONS TO BE PERFORMED
C   ON ALL NGM GRIDS THAT ARE NEEDED TO 'COVER' THE OUTPUT GRID.
C   (1) BY SUBROUTINE  OUTHORIZ
C   .  INTERPOLATE HORIZONTALLY FROM THE 'H-POINTS' OF NGM GRIDS
C   .  TO THE POINTS OF THE SPECIFIED OUTPUT GRID.
C   (2) BY SUBROUTINE  OUTSIG2P
C   .  INTERPOLATE VERTICALLY, ON THE H-POINTS OF AN NGM GRID, FROM
C   .  DATA AT SIGMA LEVELS TO THE  LMOUT STANDARD PRESSURE SURFACES.
C   .
C   TESTS ARE MADE AT THREE PLACES TO VERIFY THAT THE SCRATCH SPACE
C   USED IN THE OUTPUT TASK DOES NOT EXCEED THAT AVAILABLE IN THE
C   BLANK COMMON MEMBER.(THAT MEMBER ENDS WITH A DUMMY ARRAY OF
C   LENGTH NFILLER TO ALLOW ADDITIONAL SPACE TO BE MADE AVAILABLE.)
C   .
C
C PROGRAM HISTORY LOG:
C   84-01-15  N PHILLIPS
C   88-08-24  BRIAN SCHMIDT REVISED THE DOCBLOCK
C
C USAGE:    CALL OUTPREP
C   INPUT ARGUMENT LIST: (REALLY INPUT VARIABLES)
C     IMOUT    -  HORIZONTAL DIMENSIONS OF OUTPUT GRID
C     JMOUT    -  (FROM COMOUT)
C     .
C     YJPOUT   -
C     XIPOUT   -  GEOGRAPHICAL SPECIFICATIONS OF THE POLAR
C     SINOUT   -  STEREOGRAPHIC OUTPUT GRID. (FROM COMOUT)
C     COSOUT   -
C     .
C     PLOUT    -  VALUES OF P(UNITS=1000MBS) AT THE LMOUT
C                 PRESSURE SURFACES OF OUTPUT DATA. (FROM COMOUT)
C
C   OUTPUT ARGUMENT LIST: (REALLY OUTPUT VARIABLES)
C     COMMON   -  INTEGERS AND INTEGER ARRAYS THAT POINT
C     /COMOUT/    TO ADDRESSES IN HALF-PRECISION, INTEGER,
C                 OR BIT ARRAYS IN SCRATCH SPACE. (FROM COMOUT)
C
C     COMMON   -  DESCRIPTORS FOR ARRAYS OF GATHER INTEGERS AND
C     /COMOUT/    INTERPOLATION COEFFICIENTS USED FOR HORIZONTAL
C                 INTERPOLATION TO THE OUTPUT GRID. (FROM COMOUT)
C
C SUBPROGRAMS CALLED:
C   UNIQUE:    -  ERRPRINT
C   LIBRARY:
C     COMMON   -  COMBLANK
C              -  COMCONST
C              -  COMOUT
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN
C   MACHINE:  CRAY Y-MP
C
C$$$
C
      INCLUDE 'parmodel'
C...TRANSLATED BY FPP 3.00Z36 11/09/90  15:08:51  
C...SWITCHES: OPTON=I47,OPTOFF=VAE0
      REAL R1S,R2S
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
C     COMMON BLOCK /COMCONST/ CONTAINS GRID-RELATED PARAMETERS,
C          AND A FEW OTHER COMMON CONSTANTS.
      COMMON /COMCONST/ IJMAX, KM, LVLTOT, IJRAD, LOFCLDS(2,4),
     1                  ICALLRAD, IPHYSPL, NGRDUSE, NH,
     2                  NTIME, ITIME, NSTEPS,
     3                  IMG(INGRDUSE), JMG(INGRDUSE),
     4                  IAG(INGRDUS1), JAG(INGRDUS1),
     5                  IBG(INGRDUS1), JBG(INGRDUS1),
     6                  IADDRG(INIADDRS, INGRDUSE),
     7                  NPTSFH(2, INGRDUSE),
     8                  KUMULUS, LGRIDPPT, KLIFT1, KLIFT2, IBUCKET,
     9                  XPOLEH(INGRDUSE), YPOLEH(INGRDUSE), RADIUS,
     1                  DELSIG(IKM), PR(IKM), PRESS(IKM),
     2                  SIGINT(IKMP1),
     3                  DTOVDX, ANGVEL,
     4                  SIGMACC, SIGMAGSP, SIGMADHQ, CRITCONV,
     5                  SATDEL, RHFACTOR, QBOUND,
     6                  ANEM, BLKDR, CHARN, CONAUST, DDORF, PKATO,
     7                  SCALEHT, SIGDOT, DLAMNGM
C
C     COMMON BLOCK /COMOUT/ CONTAINS OUTPUT CODE PARAMETERS
C               AND ARRAYS.
C
      COMMON/ADDRS/MIILL,MIIUL,MSA,MSB,MSC,MSD
C
      CHARACTER*20 DESCRIPT
C
      COMMON /COMOUT/
C
C          THE FOLLOWING ARE STORED BY OUT2FILE FROM DATA CARDS.
C          (THE LAST 6 WILL BE OVERWRITTEN BY  OUTPUT  IF KGTYPE
C          IS 5 OR 26 (I.E. AN LFM GRID DEFINED IN TABLE 7 OF
C          OFFICE NOTE 84.))
C
     1     INUNIT, IOUTUNIT, IOUTGRIB,
     2     KGTYPE, IMOUT, JMOUT, DNPEQOUT, DLAMOUT, XIPOUT, YJPOUT,
C
C          THE FOLLOWING COME FROM  MAIN  READING THE DATA CARDS.
     2   LQTYPE(IMAXOUTV),   LSTYPE(IMAXOUTV),
     3   DESCRIPT(IMAXOUTV), LEVELS(ILMOUT,IMAXOUTV),  NOUTVBLS,
C
C          THE FOLLOWING ARE DERIVED BY   OUTPUT  .
     4       IJOUT, LMOUT, NFILLER, NS2, NS3NGM, NS3OUT,
     5       COSOUT,   SINOUT,    DXOUT,    ZSIGLYR(IKM),
C
C           ARRAYS  PLOUT  AND  HTFD  ARE SET BY DATA STATEMENTS IN
C           THE SR  OUTPUT  .  'PADDER' FILLS OUT TO FULL WORD BNDRY.
     6      PLOUT(ILMOUT),   HTFD( 6),  PADDER,
C
C          THE FOLLOWING ADDRESSES AND ADDRESS ARRAYS ARE SET UP
C          BY   OUTPREP  WHEN IT IS CALLED BY   OUTPUT  .
     7  J1(INGRDUSE),          J2(INGRDUSE),   JADDK2L(INGRDUSE,2),
     8  JADDFNGM(INGRDUSE), JHREC(INGRDUSE),   JHKAP(INGRDUSE),
     9  JSCR2(12),    JSCR3NGM(INGRDUSE,12),   JSCR3OUT(12),
     A  LENGD(INGRDUSE), LTYPE(ILMOUT,INGRDUSE), MB1, MB2, MINT,
     B   MSOUT1,  MSOUT2,  MZGNDOUT,  MNGM3,  MHOUT, MZFR, MZTRO,
     C      MSZGND(INGRDUSE), NGRIDATA(INGRDUSE),
C
C            NUMGDREQ, THE NUMBER OF NGM GRIDS NEEDED TO COVER THE
C            OUTPUT GRID, AND ZLOUT, ARE SET BY  OUTPREP  .
     D                NUMGDREQ,    ZLOUT(ILMOUT),
C
C          OUTPREP ALSO ASSIGNS THE FOLLOWING DESCRIPTORS TO BE
C          USED BY  OUTHORIZ  FOR HORIZONTAL INTERPOLATION.
     E    AHORD,BHORD,CHORD,DHORD, ILLD,IULD,  SCRHORD,  OUTHORD,
C
C
C          THE FOLLOWING ARRAY CONTAINS THE INTEGERS NEEDED TO
C          FORM THE LABEL THAT GOES WITH EACH OUTPUT ARRAY.
     F               LABEL84( 27 ),
C
C          THE FOLLOWING SYMBOLS REPRESENT TEMPORARY VALUES OF
C          INTEGERS TO GO INTO  LABEL84 WHEN THE OUTPUT ARRAY
C          HAS BEEN PREPARED FOR PACKING.
C
     G  LABQTYPE, LABSSUB1, LABTMARK,  S1VALUE,  S2VALUE,
     H  LABMLDIF, LABSSUB2, LABFSUB2, LABKGRID, LABNUMPT
C
      LOGICAL BIT1D,BIT2D,BIT3D,BITS
C
      CHARACTER*35 ERRMSG(4)
C
C          STAGING ARRAY FOR DATA TO BE HORIZONTALLY INTERPOLATED.
      DIMENSION FNGM(INSUMG), BIT3 ( INSUMG )
      LOGICAL BIT3
C
C          LOCAL ARRAYS NEEDED TO DEVELOP THE INTERPOLATION SYSTEM.
      DIMENSION              ZMIN(IKM),             ZMAX(IKM),
     1      NEEDGD(INGRDUSE),         MSZ3(INGRDUSE)
C
C          REFERENCE SCRATCH ARRAYS TO REDEFINE SPACE IN
C                   BLANK COMMON.
      DIMENSION S(INSUMG),IN(INSUMG),BITS(INSUMG)
C
      EQUIVALENCE (SCR(1,1),S(1),IN(1),BITS(1),FNGM(1) )
C
C           COUNTER TO ALLOW REPORTS ON FIRST nine(9) CALLS.
      DATA ICALL/-9/
C
C---------------------------------------------------------------
C              SPECIFY THE UNIT NUMBER OF THE PRINTER.
C
C---------------------------------------------------------------
C              SPECIFY THE UNIT NUMBER OF THE PRINTER.
      IOUTUPRT = 6
C
      IJOUT=IMOUT * JMOUT
      KMM1=KM-1
C          GET TOTAL LENGTH OF SPACE AVAILABLE IN BLANK COMMON
C          IN HALF WORDS.
      NSCR=INSCR
      NSCRGEO=INSCRGEO
      NSCRTCH=NSCR + NSCRGEO
      LENSCR=IJMAX*NSCRTCH
      IJKMAX=IIJKMAX
      NSCR3 = INSCR3
      LENSCR3=IJKMAX * NSCR3
      LENTOT=LENSCR + LENSCR3 + NFILLER
C
C          MUST FIRST ASSIGN ADDRESSES IN SCRATCH AREA.
C          MSXXX, MIXXX, OR MBXXX WILL BE INITIAL ADDRESSES IN
C          ARRAYS  S(HALF PRECISION), IN(INTEGER),OR BITS(BIT).
C
C          THE FOLLOWING SCHEME WILL BE USED TO ASSIGN INITIAL
C          ADDRESSES  MI  IN ARRAY  IN, MS IN ARRAY MS, AND
C          MB IN ARRAY BITS.
C        1) IF   MI  IS THE 1ST UNUSED ADDRESS IN ARRAY  IN,
C           A NEW HALF PRECISION ARRAY IN  S  CAN BEGIN AT
C               S(MS), WHERE   MS = 2*MI - 1
C           OR A NEW BIT ARRAY CAN BEGIN AT BITS(MB),WHERE
C                     MB=64*MI - 63
C        2) IF   MS  IS THE 1ST UNUSED ADDRESS IN ARRAY  S,
C           A NEW INTEGER ARRAY IN  IN  CAN BEGIN AT
C               IN(MI), WHERE   MI = (MS/2) + 1
C        3) IF   MB  IS THE 1ST UNUSED ADDRESS IN ARRAY  BITS,
C           A NEW INTEGER ARRAY CAN BEGIN AT IN( MI ), WHERE
C                  MI = (MB-2)/64  + 2
C
C          ARRAY FNGM OF LENGTH NSUMG HAS ALREADY BEEN
C          EQUIVALENCED TO S(1).  DEFINE THE BIT VECTOR SPACE NEXT.
      NSUMG=INSUMG
      MS=NSUMG + 1
      MI=MS
C          ADDRESS IN BITS OF FIRST BIT ARRAY
      MB1=MI
C
C          NEED MAX OF IJMAX OR IJOUT
      MSIZEMAX=IJMAX
      IF( IJOUT .GT. IJMAX ) MSIZEMAX=IJOUT
C
C          ADDRESS OF SECOND SUCH BIT ARRAY.
      MB=MB1 + MSIZEMAX
      MI=MB
      MB2=MI
C          NEED NEXT AVAILABLE ADDRESS IN INTEGER ARRAY  IN  .
      MB=MB2 + MSIZEMAX
      MI=MB
C
C          ADDRESSES FOR 2 ARRAYS OF GATHER INTEGERS USED IN
C          HORIZONTAL INTERPOLATION TO THE OUTPUT GRID.
C
      MIILL=MI
      MIIUL=MIILL+IJOUT
C
C
      MI=MIIUL+IJOUT
C          FOUR ARRAYS FOR HORIZONTAL INTERPOLATION COEFFS.
      MSA=MI
      MSB=MSA + IJOUT
      MSC=MSB + IJOUT
      MSD=MSC + IJOUT
C          WE NEED TWO MORE ARRAYS FOR SR  OUTHORIZ  .
      MSOUT1=MSD+IJOUT
      MSOUT2=MSOUT1+IJOUT
C
C          THESE EIGHT ARRAYS WILL BE RESERVED FOR LATER USE
C          BY SR  OUTHORIZ.
C*****  S(MSOUT2) IS THE STANDARD ARRAY FOR SR  OUTHORIZ TO PUT THE
C       DATA INTERPOLATED HORIZONTALLY TO THE OUTPUT GRID.
C       THIS OUTPUT FIELD CAN BE DIRECTED TO ANOTHER ARRAY OF SIZE
C       IJOUT, BY REASSIGNING THE DESCRIPTOR  OUTHORD   TO THE
C       DESIRED ARRAY JUST PRIOR TO CALLING OUTHORIZ AT THAT TIME.
C          IN SUCH CASES, THE DESCRIPTOR  OUTHORD  SHOULD BE
C          REASSIGNED TO  S(MSOUT2;IJOUT) AS SOON AS THE SPECIAL
C          ASSIGNMENT IS OVER.
C
C          NEED 3 TEMPORARY SCRATCH ARRAYS AT THIS POINT.
      MS3=MSOUT2+IJOUT
      MS4=MS3+ IJOUT
      MS5=MS4+ IJOUT
C          NOW TWO INTEGER SCRATCH ARRAYS
      MS=MS5+IJOUT
      MII=MS
      MIJ=MII+IJOUT
C
C          CHECK LENGTH OF SCRATCH SPACE ASSIGNED SO FAR.
      MFULL=MIJ + IJOUT - 1
      MHALF=MFULL
      IF( MHALF .LE. LENTOT ) GO TO 10
C
C     ----------------------------------------------
C
C          WE HAVE EXCEEDED AVAILABLE SPACE.  MUST STOP.
      WRITE (IOUTUPRT, 5)
    5 FORMAT(1H1,20X,'***** NOT ENUF SCRATCH SPACE IN /COMSCR/',
     1 ' FOR STAGE ONE OF SR OUTPREP')
      WRITE (IOUTUPRT, 6) LENSCR,LENSCR3,NFILLER,LENTOT,IJOUT,MHALF
    6 FORMAT(1H0,2X,'LENSCR,LENSCR3,NFILLER,LENTOT,IJOUT,MHALF=',
     1           6I10, ' .')
      NEWFIL=NFILLER + MHALF-LENTOT
      WRITE (IOUTUPRT, 7) NEWFIL
    7 FORMAT(1H0,20X,'CHANGE NFILLER(PLI) TO',I10,' TO GET OVER THIS')
C
C          ENTRANCE FROM OTHER SIZE TESTS
C
   35 CONTINUE
      WRITE (IOUTUPRT, 36) KGTYPE,IMOUT,JMOUT,DNPEQOUT,
     1         DLAMOUT,XIPOUT,YJPOUT
   36 FORMAT(1H0, '  KGTYPE,IMOUT,JMOUT,DNPEQOUT,DLAMOUT,XIPOUT,',
     1            'YJPOUT=',3I8,4E14.6)
C
C*****  Code Expanded From Routine:  ERRPRINT
      PRINT 77056
77056 FORMAT (1H1, '  **********  PRINT FROM SUBROUTINE ERRPRINT ',
     1             'FOLLOWS. ***********')
C
      PRINT 77057, IJMAX, KM, LVLTOT, NGRDUSE, NH
77057 FORMAT (1H1, 2X, 'IJMAX, KM, LVLTOT, NGRDUSE, NH =', 5I10)
C
      PRINT 77058, NTIME, ITIME, NSTEPS
77058 FORMAT (1H0, 2X, 'NTIME, ITIME, NSTEPS= ', 3I10 /)
C*****  End of Code Expanded From Routine:  ERRPRINT
C
      PRINT 999
999   FORMAT(' *** IN OUTPREP, AN ARRAY SIZE IS TOO SMALL')
      CALL EXIT(16)
C
C     ---------------------------------------------
C
   10 CONTINUE
C
C           *********************************************
C
C             SUBARRAYS ASSIGNED WITHIN   S   OR   IN  OR  BITS
C                     IN SEQUENTIAL ORDER.
C   INITIAL LOCATION      LENGTH           USE
C
C   S(1)                  NSUMG       ARRAY FNGM FOR 1 LEVEL OF
C                                     DATA FROM NGM GRIDS
C                                     AS INPUT TO  OUTHORIZ
C
C   BITS(MB1) AND         MSIZEMAX    TWO SCRATCH BIT ARRAYS
C   BITS(MB2)             EACH
C
C   IN( MIILL )           IJOUT       GATHER INTEGERS FOR LOWER
C                                     LEFT POINT IN HORIZONTAL
C                                     INTERPOLATION.
C
C   IN( MIIUL )           IJOUT       THE SAME FOR THE UPPER LEFT
C                                     POINT.
C
C   S(MSA),S(MSB),        IJOUT       FOUR ARRAYS OF BILINEAR
C   S(MSC),S(MSD)         EACH        HORIZONTAL INTERPOLATION
C                                     COEFFICIENTS.
C
C   S(MSOUT1),AND         IJOUT       WORK ARRAY AND RESULTS
C   S(MSOUT2)             EACH        ARRAY FOR   OUTHORIZ.
C
C   S(MS3),S(MS4),        IJOUT       TEMPORARY SCRATCH ARRAYS.
C   AND S(MS5)            EACH
C
C          *****************************************
C
C          FIRST COMPUTE THE ADDRESSES AND INTERPOLATION COEFFS.
C          TO HORIZONTALLY INTERPOLATE FROM THE H-POINT LOCATIONS
C          ON AN NGM GRID TO THE POINTS OF THE OUTPUT GRID.
C
C          THE FOUR PARAMETERS  1) DLAM = ANGLE BETWEEN NGM AND
C          OUTPUT GRID,  2) COSOUT=COSINE(DLAM), 3) SINOUT=
C          SINE(DLAM), AND DXOUT = OUTPUT GRID'S GRID INCREMENT
C          IN METERS HAVE BEEN PUT INTO /COMOUT/ BY EARLIER
C          ROUTINES.
C
C          COMPUTE THE OUTPUT GRID POINT VALUES OF THE NGM VALUES
C          OF X AND Y DIVIDED BY DXOUT.
      IADD1=MSOUT1-1
      IADD2=MSOUT2-1
      DJ1=-YJPOUT
      DO 25 J=1,JMOUT
      DJ1=DJ1+1.E0
      DJ2=DJ1*SINOUT
      DJ3=DJ1*COSOUT
      DI1=-XIPOUT
        DO 20 I=1,IMOUT
        DI1=DI1+1.E0
        DI2=DI1*SINOUT
        DI3=DI1*COSOUT
        IADD1=IADD1+1
        IADD2=IADD2+1
        S(IADD1)=DI3 + DJ2
        S(IADD2)=DJ3 - DI2
   20   CONTINUE
   25 CONTINUE
C
C          NGM VALUES OF A VARIABLE ( AT THE H-POINTS) WILL BE
C          STORED IN AN ARRAY  'FNGM' , CONTAINING THE COMPLETE
C          IM*JM VALUES FOR FIRST GRID A, THEN GRID B, ETC.
C            THE ADDRESS ARRAYS TO BE COMPUTED NOW WILL
C          CONTAIN THE ADDRESS, IN THE ARRAY  'FNGM' , OF THE LOWER
C          LEFT AND THE UPPER LEFT H-POINTS IN THE GRID SQUARE
C          OF THE FINEST NGM GRID THAT HAS VALID DATA SURROUNDING
C          THIS OUTPUT POINT.  THE FOUR COEFFICIENT ARRAYS
C                     AHORD, BHORD, CHORD, AND DHORD
C          WILL HAVE THE BILINEAR INTERPOLATION COEFFICIENTS
C          FOR THE FOUR SURROUNDING POINTS.
C
C          TWICE DX ON GRID A
      DXNGM=4.E0*RADIUS/(FLOAT(NH) + .5E0 )
C          SET UP ADDRESS ORIGIN
      INTADDOR=0
C          SET LATERAL LIMITS OF VALID DATA.
C          LOK1 WILL EXCLUDE POINTS NEXT TO LEFT END OF J-ROW OR
C          NEXT TO BOTTOM OF A I-COLUMN.   LOK2 IS USED SIMILARLY
C          FOR THE RIGHT END OF AN J-ROW AND THE TOP OF A I-COLUMN.
C              VALUES FOR GRID A WILL BE LOK1=2 AND LOK2 = 1.
C          THIS GIVES A MAXIMUM REACH FOR GRID A.   FOR
C          OTHER GRIDS WE WILL USE THE LUXURY OF ASSIGNING THE
C          VALUES  4  TO LOK1 AND  5  TO LOK2.  THIS SEEMS TO BE
C          SUFFICIENT TO AVOID USE OF INTERPOLATED BOUNDARY VALUES
C          IN COMPUTATION OF DERIVED QUANTITIES(OMEGA,VORTICITY)
C          THAT ARE BETTER COMPUTED FROM 'FORECAST' POINTS ON THE
C          COARSER OF TWO GRIDS.
C*****(NOTE THAT THIS MEANS THAT IM(OR JM) MUST EXCEED THE SUM OF
C       OF LOK1 AND LOK2----   )
C
      LOK1NEW=5
      LOK2NEW=4
      LOK1 = 2
      LOK2 = 1
C
      IF( ICALL .LE. 0 ) THEN
         WRITE (IOUTUPRT, 48)
   48    FORMAT ('0', 5X, 'CALCULATED INFORMATION REGARDING ',
     1                'POSTPROCESSING:' /)
      END IF
C
C          NEEDGD(NG) RECORDS WHETHER DATA FROM GRID NG IS
C          NEEDED(=1) OR NOT NEEDED(=0).
C
CMIC$ DO ALL VECTOR SHARED(NGRDUSE, NEEDGD) PRIVATE(NG)
      DO 45 NG = 1,NGRDUSE
      NEEDGD(NG) = 0
   45 CONTINUE
C
      DO 50 NG=1,NGRDUSE
C          RECORD INITIAL ADDRESSES IN ARRAY  FNGM  FOR EACH GRID.
      JADDFNGM(NG)=INTADDOR + 1
C
      IMNGM=IMG(NG)
      JMNGM=JMG(NG)
      IJNGM=IMNGM * JMNGM
C          REDUCE THE NGM GRID DELTA X.
      DXNGM=.5E0 * DXNGM
C          GET THE NON-INTEGER I LOCATING AN OUTPUT GRID POINT
C          ON THE NGM GRID NUMBER NG
      C1=DXOUT/DXNGM
      XP=XPOLEH(NG)
CMIC$ DO ALL VECTOR IF (ABS(MSOUT1-MS3).GE.IJOUT .OR. MSOUT1-MS3.EQ.0)
CMIC$1    SHARED(IJOUT, C1, MSOUT1, MS3, XP, S) PRIVATE(IQ2W6E)
      DO 88890 IQ2W6E=1,IJOUT
         S(MS3+IQ2W6E-1)=C1*S(MSOUT1+IQ2W6E-1)
         S(MS3+IQ2W6E-1)=S(MS3+IQ2W6E-1)+XP
88890 CONTINUE
C          THE WHOLE NUMBER PART AND THE INTEGER
CMIC$ DO ALL VECTOR SHARED(IJOUT, MS3, MS4, MII, S, IN) PRIVATE(IQ2W6E)
      DO 88910 IQ2W6E=1,IJOUT
         S(MS4+IQ2W6E-1)=AINT( S(MS3+IQ2W6E-1) )
         IN(MII+IQ2W6E-1)=INT( S(MS4+IQ2W6E-1) )
88910 CONTINUE
C          THE X (I) FRACTIONAL INCREMENT
CMIC$ DO ALL VECTOR IF (ABS(MS3-MS5).GE.IJOUT .OR. MS3-MS5.EQ.0) SHARED(
CMIC$1   IJOUT, MS3, MS4, MS5, S) PRIVATE(IQ2W6E)
      DO 88930 IQ2W6E=1,IJOUT
         S(MS5+IQ2W6E-1)=S(MS3+IQ2W6E-1)-S(MS4+IQ2W6E-1)
88930 CONTINUE
C          CHECK FOR LOCATION IN NGM GRID I=2,(IM-1)
      IMOST=IMNGM-LOK2
CMIC$ DO ALL VECTOR IF (ABS(MB1-MB2).GE.IJOUT .OR. MB1-MB2.EQ.0) SHARED(
CMIC$1   IJOUT, MII, LOK1, MB1, IMOST, MB2, IN, BITS, BIT3) PRIVATE(
CMIC$2   IQ2W6E)
      DO 88940 IQ2W6E=1,IJOUT
         BITS(MB1+IQ2W6E-1)=IN(MII+IQ2W6E-1).GE.LOK1
         BITS(MB2+IQ2W6E-1)=IN(MII+IQ2W6E-1).LE.IMOST
         BIT3(IQ2W6E)=BITS(MB1+IQ2W6E-1).AND.BITS(MB2+IQ2W6E-1)
88940 CONTINUE
C          DO THE SAME THING FOR Y (J)
      YP=YPOLEH(NG)
CMIC$ DO ALL VECTOR IF (ABS(MSOUT2-MS4).GE.IJOUT .OR. MSOUT2-MS4.EQ.0)
CMIC$1    SHARED(IJOUT, C1, MSOUT2, MS3, YP, MS4, MIJ, S, IN) PRIVATE(
CMIC$2   IQ2W6E)
      DO 88970 IQ2W6E=1,IJOUT
         S(MS3+IQ2W6E-1)=C1*S(MSOUT2+IQ2W6E-1)
         S(MS3+IQ2W6E-1)=S(MS3+IQ2W6E-1)+YP
         S(MS4+IQ2W6E-1)=AINT( S(MS3+IQ2W6E-1) )
         IN(MIJ+IQ2W6E-1)=INT( S(MS4+IQ2W6E-1) )
         S(MS4+IQ2W6E-1)=S(MS3+IQ2W6E-1)-S(MS4+IQ2W6E-1)
88970 CONTINUE
C          CHECK THE J-RANGE
      JMOST=JMNGM-LOK2
CMIC$ DO ALL VECTOR IF (ABS(MB1-MB2).GE.IJOUT .OR. MB1-MB2.EQ.0) SHARED(
CMIC$1   IJOUT, MIJ, LOK1, MB1, JMOST, MB2, IN, BITS) PRIVATE(IQ2W6E)
      DO 89020 IQ2W6E=1,IJOUT
         BITS(MB1+IQ2W6E-1)=IN(MIJ+IQ2W6E-1).GE.LOK1
         BITS(MB2+IQ2W6E-1)=IN(MIJ+IQ2W6E-1).LE.JMOST
         BITS(MB1+IQ2W6E-1)=BITS(MB1+IQ2W6E-1).AND.BITS(MB2+IQ2W6E-1)
89020 CONTINUE
C          COMBINE THE I- AND J- BIT VECTORS.
CMIC$ DO ALL VECTOR IF (ABS(MB1-MB2).GE.IJOUT .OR. MB1-MB2.EQ.0) SHARED(
CMIC$1   IJOUT, MB1, MB2, BITS, BIT3) PRIVATE(IQ2W6E)
      DO 89050 IQ2W6E=1,IJOUT
         BITS(MB2+IQ2W6E-1)=BITS(MB1+IQ2W6E-1).AND.BIT3(IQ2W6E)
89050 CONTINUE
      ICNT = 0
      DO 1006 IQ2 = 1, IJOUT
         IF ( BITS(MB2+IQ2-1) ) ICNT = ICNT + 1
1006  CONTINUE
C          DO WE NEED THIS GRID FOR OUTPUT DATA,,,
      IF(ICNT .EQ. 0 ) GO TO 26
      NEEDGD(NG)=1
C          IF ICNT=IJOUT AND NG .GT. 1, NO LONGER NEED GRID NG-1
      IF( NG .EQ. 1 ) GO TO 26
      IF( ICNT .EQ. IJOUT ) NEEDGD(NG-1) = 0
   26 CONTINUE
C
      IF( ICALL .GT. 0 ) GO TO 27
      WRITE (IOUTUPRT, 29) NG,ICNT
   29 FORMAT(' ',10X,'GRID NG =',I2,' HAS ',I6,' POINTS FOR THE ',
     1 'OUTPUT GRID.')
   27 CONTINUE
C
C          IF THIS IS GRID A, CHECK THAT OUTPUT GRID IS
C          COMPLETELY CONTAINED WITHIN IT.
      IF( NG .GT. 1 ) GO TO 40
      IF( ICNT .EQ. IJOUT) GO TO 40
C
C       ----------------------------------------
C
C           WE HAVE A PROBLEM SEVERE ENOUGH  TO STOP.
      WRITE (IOUTUPRT, 30) ICNT,IJOUT,IJNGM
   30 FORMAT(1H1,2X,'****IN SR OUTPREP, COULD NOT FIT OUTPUT GRID',
     1 ' ON GRID A. ICNT,IJOUT,IJNMG=',3I10)
C
C          GO OFF TO STOP
      GO TO 35
C     ---------------------------------------------
C
C          COMPUTE THE ADDRESS AND STORE THE PARAMETERS
   40 CONTINUE
CMIC$ DO ALL VECTOR SHARED(IJOUT, MIJ, IMNGM, IN) PRIVATE(IQ2W6E)
      DO 89060 IQ2W6E=1,IJOUT
         IN(MIJ+IQ2W6E-1)=IN(MIJ+IQ2W6E-1)*IMNGM
89060 CONTINUE
      I1=INTADDOR-IMNGM
CMIC$ DO ALL VECTOR SHARED(IJOUT, MIJ, MII, I1, IN) PRIVATE(IQ2W6E)
      DO 89070 IQ2W6E=1,IJOUT
         IN(MIJ+IQ2W6E-1)=IN(MIJ+IQ2W6E-1)+IN(MII+IQ2W6E-1)+I1
89070 CONTINUE
C          THE LOWER LEFT POINT ADDRESS
CMIC$ DO ALL VECTOR IF (ABS(MIJ-MIILL).GE.IJOUT .OR. MIJ-MIILL.EQ.0)
CMIC$1    SHARED(IJOUT, MB2, MIJ, MIILL, BITS, IN) PRIVATE(IQ2W6E)
      DO 89080 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         IN(MIILL+IQ2W6E-1)=IN(MIJ+IQ2W6E-1)
       END IF
89080 CONTINUE
C          THE UPPER LEFT POINT ADDRESS
CMIC$ DO ALL VECTOR IF (ABS(MIJ-MIIUL).GE.IJOUT .OR. MIJ-MIIUL.EQ.0)
CMIC$1    SHARED(IJOUT, MB2, MIJ, IMNGM, MIIUL, BITS, IN) PRIVATE(IQ2W6E
CMIC$2   )
      DO 89090 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         IN(MIIUL+IQ2W6E-1)=IN(MIJ+IQ2W6E-1)+IMNGM
       END IF
89090 CONTINUE
C          1 - DX
CMIC$ DO ALL VECTOR IF (ABS(MS5-MS3).GE.IJOUT .OR. MS5-MS3.EQ.0) SHARED(
CMIC$1   IJOUT, MB2, MS5, MS3, BITS, S) PRIVATE(IQ2W6E)
      DO 89100 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MS3+IQ2W6E-1)=1.E0-S(MS5+IQ2W6E-1)
       END IF
89100 CONTINUE
C          THE UPPER LEFT COEFFICIENT =(1-DX)*DY
CMIC$ DO ALL VECTOR IF ((ABS(MS4-MSB).GE.IJOUT .OR. MS4-MSB.EQ.0) .AND. 
CMIC$1   (ABS(MS3-MSB).GE.IJOUT .OR. MS3-MSB.EQ.0)) SHARED(IJOUT, MB2, 
CMIC$2   MS4, MS3, MSB, BITS, S) PRIVATE(IQ2W6E)
      DO 89110 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MSB+IQ2W6E-1)=S(MS4+IQ2W6E-1)*S(MS3+IQ2W6E-1)
       END IF
89110 CONTINUE
C          THE UPPER RIGHT COEFFICIENT = DX * DY
CMIC$ DO ALL VECTOR IF ((ABS(MS4-MSD).GE.IJOUT .OR. MS4-MSD.EQ.0) .AND. 
CMIC$1   (ABS(MS5-MSD).GE.IJOUT .OR. MS5-MSD.EQ.0)) SHARED(IJOUT, MB2, 
CMIC$2   MS4, MS5, MSD, BITS, S) PRIVATE(IQ2W6E)
      DO 89120 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MSD+IQ2W6E-1)=S(MS4+IQ2W6E-1)*S(MS5+IQ2W6E-1)
       END IF
89120 CONTINUE
C          1 - DY
CMIC$ DO ALL VECTOR SHARED(IJOUT,MB2,MS4,MS3,BITS,S)PRIVATE(IQ2W6E)
      DO 89130 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MS3+IQ2W6E-1)=1.E0-S(MS4+IQ2W6E-1)
       END IF
89130 CONTINUE
C          THE LOWER RIGHT COEFFICIENT = DX * (1-DY)
CMIC$ DO ALL VECTOR IF ((ABS(MS5-MSC).GE.IJOUT .OR. MS5-MSC.EQ.0) .AND. 
CMIC$1   (ABS(MS3-MSC).GE.IJOUT .OR. MS3-MSC.EQ.0)) SHARED(IJOUT, MB2, 
CMIC$2   MS5, MS3, MSC, BITS, S) PRIVATE(IQ2W6E)
      DO 89140 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MSC+IQ2W6E-1)=S(MS5+IQ2W6E-1)*S(MS3+IQ2W6E-1)
       END IF
89140 CONTINUE
C          THE LOWER LEFT COEFFICIENT = (1-DX)*(1-DY)
CMIC$ DO ALL VECTOR IF ((ABS(MS3-MSA).GE.IJOUT .OR. MS3-MSA.EQ.0) .AND. 
CMIC$1   (ABS(MSC-MSA).GE.IJOUT .OR. MSC-MSA.EQ.0)) SHARED(IJOUT, MB2, 
CMIC$2   MS3, MSC, MSA, BITS, S) PRIVATE(IQ2W6E)
      DO 89150 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MSA+IQ2W6E-1)=S(MS3+IQ2W6E-1)-S(MSC+IQ2W6E-1)
       END IF
89150 CONTINUE
C
C
C          INCREMENT THE ADDRESS ORIGIN
      INTADDOR=INTADDOR + IMNGM * JMNGM
C           REPLACE LOK1 AND LOK2 FOR GRIDS B,C-
      LOK1 = LOK1NEW
      LOK2 = LOK2NEW
C
C
   50 CONTINUE
C
C          ESTABLISH THE COARSEST AND FINEST GRIDS NEEDED
C          FOR OUTPUT DATA.
C             FIRST FIND THE COARSEST GRID THAT IS NEEDED (NEED1)
      DO 51 NG=1,NGRDUSE
      NEED1=NG
      IF( NEEDGD(NG) .EQ. 1 ) GO TO 52
   51 CONTINUE
C             NOW GO BACKWARD TO FIND THE FINEST GRID THAT IS NEEDED
   52 DO 53 NNG=1,NGRDUSE
      NEED2=NGRDUSE+1-NNG
      IF( NEEDGD(NEED2) .EQ. 1 ) GO TO 54
   53 CONTINUE
   54 CONTINUE
C
C          ESTABLISH THE RANGE IN J NEEDED FOR EACH GRID AND PUT
C          THE RANGE INTO  J1  AND   J2  .
      IORIG = 0
      DO 58 NG=1,NGRDUSE
      IM=IMG(NG)
      JM=JMG(NG)
      IJ=IM*JM
C
C          J1(NG) AND J2(NG) RECORD THE J RANGE J=J1,J2 THAT
C          IS REQUIRED FROM NGM GRID  NG.
C
      J1(NG)=0
      J2(NG)=0
      LENGD(NG)=0
C
      IF( NEEDGD(NG) .EQ. 0 ) GO TO 55
C          LOOK FOR ADDRESSES IN ILLD FROM THIS GRID
      L1=IORIG + 1
      L2=IORIG + IJ
CMIC$ DO ALL VECTOR IF (ABS(MB1-MB2).GE.IJOUT .OR. MB1-MB2.EQ.0) SHARED(
CMIC$1   IJOUT, MIILL, L1, MB1, L2, MB2, IN, BITS, BIT3) PRIVATE(IQ2W6E)
      DO 89160 IQ2W6E=1,IJOUT
         BITS(MB1+IQ2W6E-1)=IN(MIILL+IQ2W6E-1).GE.L1
         BITS(MB2+IQ2W6E-1)=IN(MIILL+IQ2W6E-1).LE.L2
         BIT3(IQ2W6E)=BITS(MB1+IQ2W6E-1).AND.BITS(MB2+IQ2W6E-1)
89160 CONTINUE
      IADMIN = 1000000
      IADMAX =-1000000
      DO 3002 IQ2 = 1, IJOUT
         IF ( BIT3(IQ2) ) THEN
            IADMIN = AMIN0(IADMIN, IN(MIILL+IQ2-1) )
            IADMAX = AMAX0(IADMAX, IN(MIILL+IQ2-1) )
         END IF
3002  CONTINUE
      J1(NG)=1 +(IADMIN-L1)/IM
      J2(NG)=2 + (IADMAX -L1)/IM
      LENGD(NG)=( J2(NG) - J1(NG) + 1 )*IM
   55 IORIG = IORIG + IJ
      IF( ICALL .GT. 0 ) GO TO 60
      WRITE (IOUTUPRT, 57) NG,J1(NG),J2(NG)
   57 FORMAT(' ',10X,'GRID',I2,' IS NEEDED FOR ITS J-RANGE',I4,' -',
     1           I4, '.' )
   60 CONTINUE
C
   58 CONTINUE
C
C     ******* NOW COMPUTE THE INFORMATION AND ARRAYS NEEDED TO
C             DO SIGMA TO PRESSURE INTERPOLATION
C
C
C          THE VARIABLE
C
C             Z = -LOG( PRESSURE/100 CBS )
C
C          IS EQUAL TO  -LOG(H)  -  LOG( PRESS(K) ) .
C          THE SECOND TERM HAS BEEN PUT INTO ZSIGLYR(K) BY
C          AN EARLIER ROUTINE.
C
C
C          VALUES OF Z FOR THE OUTPUT PRESSURE SURFACES.
CMIC$ DO ALL VECTOR SHARED(LMOUT, PLOUT, ZLOUT) PRIVATE(L)
      DO 100 L=1,LMOUT
      ZLOUT(L)= - LOG( PLOUT(L) )
  100 CONTINUE
C          NEED TO DEFINE NEW SUB-ARRAY ADDRESSES IN THE SCRATCH
C          ARRAYS  S  AND  IN  FOR THE NEXT STEPS IN THIS CODE.
C          (  WE WILL OVERWRITE ARRAYS S(MS3),S(MS4), AND S(MS5).)
C
      MS=MS3
      MI=MS
C          INTEGER SCRATCH ARRAY OF LENGTH MSIZEMAX
      MINT=MI
      MI=MINT + MSIZEMAX
C          ARRAYS OF GATHER INTEGERS FOR SIGMA TO PRESSURE ON
C          NEEDED NGM GRIDS.
      DO 101 NG=1,NGRDUSE
      JADDK2L(NG,1)=0
      IF(NEEDGD(NG) .EQ. 0 ) GO TO 101
      JADDK2L(NG,1)=MI
      MI=MI + LMOUT*LENGD(NG)
  101 CONTINUE
C          ARRAYS OF INTERPOLATION COEFFS FOR SIGMA TO PRESSURE
C          ON NEEDED NGM GRIDS.
      MS=MI
      DO 102 NG=1,NGRDUSE
      JADDK2L(NG,2)=0
      IF(NEEDGD(NG) .EQ. 0 ) GO TO 102
      JADDK2L(NG,2)=MS
      MS=MS + LMOUT*LENGD(NG)
  102 CONTINUE
C          ARRAYS OF Z AT THE GROUND FOR NEEDED NGM GRIDS
C          (THESE ARRAYS, AND THE FOLLOWING ARRAYS FOR Z ON SIGMA
C          WILL HAVE THE HORIZONTAL DIMENSION LENGD(NG).  THE DATA
C          IN THE LATTER WILL, AT THE END OF THIS SUBROUTINE,
C          BE RESTORED IN FULL ARRAYS OF HORIZONTAL DIMENSION
C          IJMAX,  SO Z(SIGMA) CAN BE GATHERED IN THE HYDROSTATIC
C          COMPUTATIONS OF  HEIGHT  .
      DO 103 NG=1,NGRDUSE
      MSZGND(NG)=0
      IF(NEEDGD(NG) .EQ. 0 ) GO TO 103
      MSZGND(NG)=MS
      MS=MS + LENGD(NG)
  103 CONTINUE
C          SAVE THIS ADDRESS TO START THE NEXT BATCH OF ARRAYS
      MSNEW=MS
C          ADDRESSES FOR 3-DIMENSIONAL FIELDS OF Z ON NEEDED NGM
C          GRIDS
      DO 104 NG=1,NGRDUSE
      MSZ3(NG)=0
      IF(NEEDGD(NG) .EQ. 0 ) GO TO 104
      MSZ3(NG)=MS
      MS=MS + KM*LENGD(NG)
  104 CONTINUE
C
      MHALF = MS
C          CHECK LENGTH OF THIS SCRATCH SPACE
      IF( MHALF .LE. LENTOT ) GO TO 116
C
C      -----------------------------------------------
C
C          EXCEEDED SPACE. MUST STOP.
      WRITE (IOUTUPRT, 111)
  111 FORMAT(1H1,2X,'**** NOT ENUF SPACE IN /COMSCR/ FOR STAGE',
     1 ' TWO OF SR OUTPREP')
      NEWFIL=NFILLER+MHALF-LENTOT
      WRITE (IOUTUPRT, 109) NEWFIL
  109 FORMAT(1H0,10X,'CHANGE NFILLER(IN PLI) TO',I10,' TO OVERCOME ',
     1  'THIS')
C
  117 WRITE (IOUTUPRT, 112) LENSCR,LENSCR3,NFILLER,LENTOT,IJOUT,MHALF
  112 FORMAT('0', 5X,'LENSCR, LENSCR3, NFILLER, LENTOT, IJOUT, MHALF =',
     1            6I10, ' .')
C
  113 DO 115 NG=1,NGRDUSE
      JJ1=J1(NG)
      JJ2=J2(NG)
      IM=IMG(NG)
      NUSE=NEEDGD(NG)
      WRITE (IOUTUPRT, 114) NG,NUSE,JJ1,JJ2,IM
  114 FORMAT(1H0,5X,'NG, NEEDGD(NG), J1, J2, IM =', 5I10, ' .')
  115 CONTINUE
C
C           GO OFF TO STOP
      GO TO 35
C
C    ------------------------------------------------
C
C
  116 CONTINUE
C
C     ***********************************************
C
C     SUBARRAYS ASSIGNED WITHIN   S   OR   IN   ,
C          IN ORDER, FOLLOWING AFTER THE ARRAY  S( MSOUT2 ).
C
C   INITIAL LOCATION      LENGTH           USE
C
C       (( THE SYMBOL  LEN  REPRESENTS, FOR EACH
C          GRID, THE NUMBER  IM * ( J2-J1+1 ). ))
C
C   IN( MINT )            MSIZEMAX     THE INTEGERS 1,2,,IJMAX,,
C                                     AND LATER INTEGER SCRATCH AREA
C
C   IN( JADDK2L(NG,1) )   LMOUT * LEN   GATHER INTEGERS FOR
C                         FOR EACH      SIGMA-P INTERPOLATION.
C                         NEEDED GRID.
C
C   S(JADDK2L(NG,2) )     LMOUT * LEN  VERTICAL INTERPOLATION
C                         FOR EACH     COEFFICIENTS.
C                         NEEDED GRID.
C
C   S( MSZGND(NG) )       LEN FOR      Z=-LOG(PRESS) AT
C                         EACH NEEDED  THE GROUND.
C                         GRID.
C
C   S( MSZ3(NG) )         KM * LEN FOR  Z AT ALL K-LEVELS.
C                         EACH NEEDED
C                         GRID.
C
C          *************************************************
C
C          ESTABLISH A MORE CONVENIENT ARRAY OF THE NGM GRIDS NEEDED
C              FIRST, THE NUMBER THAT ARE NEEDED
      NUMGDREQ=NEED2-NEED1 + 1
CMIC$ DO ALL VECTOR SHARED(NGRDUSE, NGRIDATA) PRIVATE(N)
      DO 124 N=1,NGRDUSE
      NGRIDATA(N)=0
  124 CONTINUE
      NN=NEED1
CMIC$ PARALLEL SHARED(IJMAX, MINT, IN, NUMGDREQ, NN, NGRIDATA) PRIVATE(
CMIC$1   IQ2, N)
CMIC$ DO PARALLEL VECTOR
      DO 125 N = 1, NUMGDREQ
         NGRIDATA(N) = NN + N - 1
  125 CONTINUE
C
C     THE STANDARD DO LOOP ON THE NEEDED GRIDS WILL HAVE THE FORM,,,
C
C           DO 999 NN=1,NUMGDREQ
C           NG=NGRIDATA(NN)
C           IM=IMG(NG)
C           -----ET CETERA-----
C      999  CONTINUE
C
C          PUT THE INTEGERS 1,2,,,IJMAX INTO SUBARRAY  MINT , FOR
C          FORMING THE GATHER INTEGERS.
CMIC$ DO PARALLEL VECTOR
      DO 3001 IQ2 = 1, IJMAX
         IN ( MINT+IQ2-1) = IQ2
3001  CONTINUE
CMIC$ END PARALLEL
C
C          THE GATHER INTEGERS FOR THE SIGMA TO PRESSURE INTERPOLATION
C          FOR GRID  NG  , WILL GATHER THE VALUE OF THE INTERPOLATED
C          VARIABLE AT THE SIGMA LEVEL AT OR JUST BELOW THE OUTPUT
C          PRESSURE LEVEL.  IF THE OUTPUT SURFACE IS EITHER BELOW
C          SIGMA LEVEL K=1, OR ABOVE SIGMA LEVEL K=KM, THE GATHER
C          INTEGER WILL BE SET EQUAL TO  0  (AS A FLAG ).
C            THESE GATHER INTEGERS WILL BE STORED IN THE LARGE
C          SCRATCH ARRAY  IN  BEGINNING AT THE ADDRESSES ALREADY
C          STORED IN  JADDK2L( NG,1 ).
C            A COMPANION ARRAY OF VERTICAL INTERPOLATION COEFFICIENTS
C          TO ACCOMPLISH LINEAR INTERPOLATION IN
C                 Z = - LOG( PRESSURE/100 CBS )
C          WILL ALSO BE SET UP.  ITS LOCATION IN THE LARGE SCRATCH
C          ARRAY  S  IS GIVEN BY THE VALUES IN  JADDK2L(NG,2).
C
C          THE SIGMA DATA FROM AN NGM GRID  NG  NEED ONLY BE
C     PREPARED FOR THE RANGE I=1,IMG(NG),,J=J1(NG),J2(NG),,AND
C     K=1,KM.  IT MUST BE STORED, HOWEVER, IN A FULLY-DIMENSIONED
C     ARRAY IN WHICH I=1,IMG(NG),,J=1,JMG(NG), AND K=1,KM WHOSE
C     FIRST POINT (1,1,1) IS GIVEN BY JSCR3NGM(NN,NDATA) WHERE
C          NG=NGRIDATA(NN) AND
C          NDATA=1,NS3NGM DENOTES WHICH SET OF THREE-DIMENSIONAL
C          SCRATCH GRIDS IS BEING USED TO PROCESS THIS SIGMA
C          VARIABLE.(I.E. NDATA IS FIXED FOR THIS VARIABLE).
C
      DO 200 NN=1,NUMGDREQ
      NG=NGRIDATA(NN)
C          J-ROW RANGE IS GIVEN BY J1 AND J2
      JJ1=J1(NG)
      JJ2=J2(NG)
      IM=IMG(NG)
      JM=JMG(NG)
      IJ=IM*JM
C          LENGTH OF HORIZONTAL ARRAY ON P SURFACE NEEDED
C          FROM THIS GRID
      LEN=LENGD(NG)
C          ADDRESS IN THE NGM COMPACT THREE DIMENSIONAL GRID
C          OF THE POINT I,J,K = 1,JJ1,1
      IJ1=(JJ1-1)*IM + 1
C          ADDRESS IN ARRAY VBL FOR THE H FIELD AT THIS POINT.
      IADH=IADDRG(5,NG) + IJ1 -1
C          NEGATIVE LOG OF SURFACE PRESSURE (H)
      MSHLOG=MSZGND(NG)
CMIC$ DO ALL VECTOR SHARED(LEN, IADH, MSHLOG, VBL, S) PRIVATE(IQ2W6E)
      DO 89190 IQ2W6E=1,LEN
         S(MSHLOG+IQ2W6E-1)=-ALOG( VBL(IADH+IQ2W6E-1) )
89190 CONTINUE
C
C
C          GET THE Z FIELD ( -LOG(PRESSURE/100CBS) ) AND ITS RANGE
      MSZ=MSZ3(NG)
      IAD=MSZ-LEN
        DO 120 K=1,KM
        IAD=IAD+LEN
        C1=ZSIGLYR(K)
CMIC$ DO ALL VECTOR IF (ABS(MSHLOG-IAD).GE.LEN .OR. MSHLOG-IAD.EQ.0)
CMIC$1    SHARED(LEN, C1, MSHLOG, IAD, S) PRIVATE(IQ2W6E)
      DO 89200 IQ2W6E=1,LEN
         S(IAD+IQ2W6E-1)=C1+S(MSHLOG+IQ2W6E-1)
89200 CONTINUE
C
        ZZMAX = S(IAD)
        ZZMIN = S(IAD)
CMIC$ PARALLEL SHARED(LEN, ZZMAX, IAD, ZZMIN, S) PRIVATE(IQ2, R1S, R2S)
      R1S = ZZMAX
      R2S = ZZMIN
CMIC$ DO PARALLEL VECTOR
      DO 4001 IQ2 = 1, LEN
         R1S = AMAX1(R1S,S(IAD+IQ2-1))
         R2S = AMIN1(R2S,S(IAD+IQ2-1))
 4001 CONTINUE
CMIC$ GUARD
      ZZMIN = AMIN1(ZZMIN,R2S)
CMIC$ END GUARD
CMIC$ GUARD
      ZZMAX = AMAX1(ZZMAX,R1S)
CMIC$ END GUARD
CMIC$ END DO
CMIC$ END PARALLEL
C
        ZMAX(K)=ZZMAX
        ZMIN(K)=ZZMIN
C
  120   CONTINUE
C
C
C          DETERMINE THE TYPE OF OUTPUT PRESSURE SURFACE AND
C          RECORD THE TYPE IN LTYPE(L,NG)
C          -1:  HAS AT LEAST ONE POINT BELOW K=1
C           0:  HAS NO POINTS BELOW K=1 OR ABOVE K=KM
C           1:  HAS AT LEAST ONE POINT ABOVE K=KM
C
CMIC$ DO ALL VECTOR SHARED(LMOUT, NG, KM, ZLOUT, LTYPE, ZMAX, ZMIN)
CMIC$1    PRIVATE(L, ZOUT)
        DO 130 L=1,LMOUT
        ZOUT=ZLOUT(L)
C          ASSUME NORMAL SURFACE
        LTYPE(L,NG)=0
C          TEST FOR POINTS BELOW K=1
        IF( ZOUT .LT. ZMAX(1) ) LTYPE(L,NG)=-1
C          TEST FOR POINTS ABOVE K=KM
        IF( ZOUT .GT. ZMIN(KM) ) LTYPE(L,NG)=1
  130   CONTINUE
C
C          INITIAL ADDRESSES FOR THIS GRID OF THE GATHER INTEGERS
C          AND THE INTERPOLATION COEFFICIENTS, BOTH MINUS LEN.
      IADIN=JADDK2L(NG,1) - LEN
      IADS =JADDK2L(NG,2) - LEN
        DO 199 L=1,LMOUT
        IADIN=IADIN+ LEN
        IADS = IADS+ LEN
        ZOUT=ZLOUT(L)
        IF(LTYPE(L,NG) .GE. 0 ) GO TO 160
C          SOME POINTS ARE BELOW K=1.  FIRST ASSUME ALL ARE.
CMIC$ DO ALL VECTOR SHARED(LEN, IADIN, IN) PRIVATE(IQ2W6E)
      DO 89210 IQ2W6E=1,LEN
         IN(IADIN+IQ2W6E-1)=0
89210 CONTINUE
C          THE INTERPOLATION COEFF. IN THIS CASE IS ZOUT - Z(K=1)
CMIC$ DO ALL VECTOR IF (ABS(MSZ-IADS).GE.LEN .OR. MSZ-IADS.EQ.0) SHARED(
CMIC$1   LEN, ZOUT, MSZ, IADS, S) PRIVATE(IQ2W6E)
      DO 89220 IQ2W6E=1,LEN
         S(IADS+IQ2W6E-1)=ZOUT-S(MSZ+IQ2W6E-1)
89220 CONTINUE
C
C          IF ALL ZOUT POINTS ARE BELOW K=1,GO TO END OF L-LOOP.
        IF( ZMIN(1) .GE. ZOUT ) GO TO 199
C          SOME POINTS ARE ABOVE LAYER K=1.  IN THIS CASE
C          SET K1 (THE FIRST LAYER TO BE SEARCHED) =1.
        K1=1
C
C          K2 IS THE LAST LAYER TO BE SEARCHED.
C          IT WILL BE SUCH THAT ZMIN(K2+1) .GT. ZOUT
C
  135   CONTINUE
C
        K1P1=K1+1
          DO 140 K=K1P1,KM
          K2=K-1
          IF( ZMIN(K) .GT. ZOUT ) GO TO 145
  140     CONTINUE
C
  145   CONTINUE
C
C          LOOK FOR Z(K) .LE. ZOUT AND ZOUT .LT. Z(K+1)
C
  150   CONTINUE
C
C          THE ADDRESS(MINUS LEN) OF Z AT (I,J,K)=(1,JJ1,K1)
        IZAD=MSZ+(K1-2)*LEN
          DO 155 K=K1,K2
          IZAD=IZAD+LEN
CMIC$ DO ALL VECTOR IF (ABS(MB1-MB2).GE.LEN .OR. MB1-MB2.EQ.0) SHARED(
CMIC$1   LEN, ZOUT, IZAD, MB1, MB2, S, BITS) PRIVATE(IQ2W6E)
      DO 89230 IQ2W6E=1,LEN
         BITS(MB1+IQ2W6E-1)=ZOUT.GE.S(IZAD+IQ2W6E-1)
         BITS(MB2+IQ2W6E-1)=ZOUT.LT.S(IZAD+LEN+IQ2W6E-1)
         BITS(MB1+IQ2W6E-1)=BITS(MB1+IQ2W6E-1).AND.BITS(MB2+IQ2W6E-1)
89230 CONTINUE
          C1=1.E0/(ZSIGLYR(K+1)-ZSIGLYR(K) )
C          THE ADDRESS IN THE NGM GRID OF (I,J,K)=(0,JJ1,K)
          IGAD=(K-1)*IJ + (JJ1-1)*IM
C
C          STORE ADDRESS FOR I,J,K
CMIC$ DO ALL VECTOR IF (ABS(MINT-IADIN).GE.LEN .OR. MINT-IADIN.EQ.0)
CMIC$1    SHARED(LEN, MB1, IGAD, MINT, IADIN, BITS, IN) PRIVATE(IQ2W6E)
      DO 89260 IQ2W6E=1,LEN
       IF ( BITS(MB1+IQ2W6E-1) ) THEN
         IN(IADIN+IQ2W6E-1)=IGAD+IN(MINT+IQ2W6E-1)
       END IF
89260 CONTINUE
C          THE INTERPOLATION COEFF IS
C            (ZOUT-Z(K) ) / (Z(K+1)-Z(K) )
C          (THE DENOMINATOR = ZSIGLYR(K+1)-ZSIGLYR(K)  )
CMIC$ DO ALL VECTOR IF (ABS(IZAD-IADS).GE.LEN .OR. IZAD-IADS.EQ.0)
CMIC$1    SHARED(LEN, MB1, ZOUT, IZAD, IADS, C1, BITS, S) PRIVATE(IQ2W6E
CMIC$2   )
      DO 89270 IQ2W6E=1,LEN
       IF ( BITS(MB1+IQ2W6E-1) ) THEN
         S(IADS+IQ2W6E-1)=ZOUT-S(IZAD+IQ2W6E-1)
         S(IADS+IQ2W6E-1)=C1*S(IADS+IQ2W6E-1)
       END IF
89270 CONTINUE
C
C
  155     CONTINUE
C          DONE WITH LEVEL L
        GO TO 199
C
  160   CONTINUE
C          LTYPE IS .GE. 0
        IF(LTYPE(L,NG) .GT. 0 ) GO TO 175
C          ZOUT LIES COMPLETELY BETWEEN K=1 AND KM.  FIND K1.
          DO 165 K=2,KM
          K1=K-1
          IF(ZMAX(K) .GT. ZOUT ) GO TO 135
  165     CONTINUE
C
        GO TO 135
C
  175   CONTINUE
C
C          PART OF ZOUT IS ABOVE K=KM
C          FIRST ASSUME IT ALL IS ABOVE KM.
CMIC$ DO ALL VECTOR SHARED(LEN, IADIN, IN) PRIVATE(IQ2W6E)
      DO 89290 IQ2W6E=1,LEN
         IN(IADIN+IQ2W6E-1)=0
89290 CONTINUE
C          THE ADDRESS FOR Z AT (I,J,K)=(1,JJ1,KM).
        IZKMAD=MSZ+(KM-1)*LEN
CMIC$ DO ALL VECTOR IF (ABS(IZKMAD-IADS).GE.LEN .OR. IZKMAD-IADS.EQ.0)
CMIC$1    SHARED(LEN, ZOUT, IZKMAD, IADS, S) PRIVATE(IQ2W6E)
      DO 89300 IQ2W6E=1,LEN
         S(IADS+IQ2W6E-1)=ZOUT-S(IZKMAD+IQ2W6E-1)
89300 CONTINUE
C          IF ALL POINTS ARE ABOVE KM, GO TO END OF L-LOOP.
        IF( ZMAX(KM) .LE. ZOUT ) GO TO 199
C          SOME POINTS ARE BELOW KM
C               FIND K1
          DO 180 K=2,KM
          K1=K-1
          IF( ZMAX(K) .GT. ZOUT ) GO TO 185
  180     CONTINUE
C
  185   CONTINUE
        K2=KM-1
        GO TO 150
C
C          DONE WITH OUTPUT LEVEL L FOR GRID NG.
C
  199   CONTINUE
C
C           DONE WITH ALL OUTPUT LEVELS FOR GRID NG.
  200 CONTINUE
C
C
C
C
C          SET UP ADDITIONAL WORK SPACE FOR TEMPORARY USE IN
C          MAIN PART OF THE CODE.
C
C     *******************************************************
C          THERE WILL BE FOUR TYPES OF SCRATCH DATA ARRAYS.
C
C   NUMBER OF ARRAYS  SIZE OF EACH ARRAY  1ST S ADDRESS STORED IN
C
C  (NUMGDREQ*NS3NGM)  IJMAX * KM          JSCR3NGM(NGRDUSE,12)
C
C   NS3OUT            IJOUT * MAX OF      JSCR3OUT(12)
C                       KM OR LMOUT.
C   NS2               MSIZEMAX            JSCR2(12)
C
C   ONE               KM * IJMAX          MNGM3
C
C        THERE WILL ALSO BE  NUMGDREQ ARRAYS OF SIZE IJMAX FOR
C        STORAGE OF (1/H) AND (H**KAPPA) FOR EACH NEEDED NGM GRID.
C
C
C  NUMGDREQ           IJMAX              JHREC(NN)
C
C  NUMGDREQ           IJMAX              JHKAP(NN)
C
C          ALSO SINGLE ARRAYS FOR  H  AND  (-LOG(H) ) ON THE
C          OUTPUT GRID,
C      2              IJOUT              MHOUT, MZGNDOUT
C
C          AND SINGLE ARRAYS FOR -LOG(H) AT FREEZING LEVEL
C          AND AT THE TROPOPAUSE LEVEL ON THE OUTPUT GRID.
C      2              IJOUT              MZFR, MZTRO
C
C
C     *******************************************************
C
      MS=MSNEW
CMIC$ DO ALL SHARED(NGRDUSE, JSCR3OUT, JSCR2, JSCR3NGM) PRIVATE(ND, NN)
      DO 210 ND=1,12
      JSCR3OUT(ND)=0
      JSCR2(ND)=0
        DO 205 NN=1,NGRDUSE
        JSCR3NGM(NN,ND)=0
  205   CONTINUE
  210 CONTINUE
C
      MSIZE=KM*IJMAX
      IF (NS3NGM .GT. 0) THEN
         IF (NUMGDREQ .GT. 0) THEN
CMIC$       DO ALL SHARED(NS3NGM, NUMGDREQ, MS, MSIZE, JSCR3NGM)
CMIC$1          PRIVATE(NJ, NI)
            DO 220 NJ = 1, NS3NGM
               DO 77059 NI = 1, NUMGDREQ
                  JSCR3NGM(NI,NJ) = MS + MSIZE*(NUMGDREQ*(NJ-1)+NI-1)
77059          CONTINUE
  220       CONTINUE
            MS = NUMGDREQ*NS3NGM*MSIZE + MS
         ENDIF
      ENDIF
C          FOR OUTPUT OF TROPOPAUSE VBLS (AT END OF OUTPUT CODE),
C          WILL WANT TO PUT A KM*IJOUT GRID IN PLACE OF KM*IJMAX
C          GRIDS JUST SET UP ABOVE.  CHECK THAT THERE IS ROOM.
      MORE=KM*IJOUT-NS3NGM*MSIZE*NUMGDREQ
      IF( MORE .GT. 0 ) MS=MS + MORE
C
C        3-DIMEN OUTPUT GRIDS CAN BE FOR EITHER KM OR LMOUT LEVELS.
C
      MSIZE=IJOUT * MAX( KM,LMOUT)
CMIC$ DO ALL VECTOR SHARED(NS3OUT, MS, MSIZE, JSCR3OUT) PRIVATE(NI)
      DO 225 NI = 1, NS3OUT
         JSCR3OUT(NI) = MS + MSIZE*(NI-1)
  225 CONTINUE
      MS = NS3OUT*MSIZE + MS
CMIC$ DO ALL VECTOR SHARED(NS2, MS, MSIZEMAX, JSCR2) PRIVATE(NI)
      DO 230 NI = 1, NS2
         JSCR2(NI) = MS + MSIZEMAX*(NI-1)
  230 CONTINUE
      MS = NS2*MSIZEMAX + MS
CMIC$ DO ALL VECTOR SHARED(NGRDUSE, JHREC, JHKAP) PRIVATE(N)
      DO 235 N=1,NGRDUSE
      JHREC(N)=0
      JHKAP(N)=0
  235 CONTINUE
      DO 240 N=1,NUMGDREQ
      NG=NGRIDATA(N)
      JHREC(NG)=MS
      MS=MS+IJMAX
  240 CONTINUE
      DO 245 N=1,NUMGDREQ
      NG=NGRIDATA(N)
      JHKAP(NG)=MS
      MS=MS+IJMAX
  245 CONTINUE
      MZGNDOUT=MS
      MS=MS+IJOUT
      MHOUT=MS
      MS=MS+IJOUT
      MZFR=MS
      MS=MS+IJOUT
      MZTRO=MS
      MS=MS+IJOUT
      MNGM3=MS
      MS=MS + KM * IJMAX
C
C     RECORD THE SIZE ON THE FIRST nine(9) CALLS.
      MSM1=MS-1
C was IF( ICALL .GT. 0 ) GO TO 260 changed by DiMego
      IF( ICALL .LE. 0 ) THEN
        WRITE (IOUTUPRT, 250) MSM1,LENTOT,NS2,NS3NGM,NS3OUT
      end if
  250 FORMAT(' ',10X,'MS-1, LENTOT, NS2, NS3NGM, NS3OUT =',5I10, ' .')
C
C          CHECK SIZE BEFORE PROCEEDING
      MHALF=MSM1
      IF(MHALF .LE. LENTOT ) GO TO 260
C
C     -----------------------------------------------
C
C          WE ARE EXCEEDING AVAILABLE SPACE,,,PRINT AND STOP
      WRITE (IOUTUPRT, 255)
  255 FORMAT(1H1,2X,'***** NOT ENOUGH SPACE IN /COMSCR/ FOR STAGE',
     1  ' THREE OF SUBROUTINE OUTPREP.')
      NEWFIL=NFILLER+MHALF-LENTOT
      WRITE (IOUTUPRT, 256) NEWFIL
  256 FORMAT(1H0,10X,'INCREASE NFILLER(PLI) TO',I10,' TO OVERCOME THIS')
C
C                GO OFF TO STOP
      GO TO 117
C
C      -----------------------------------------------------
C
  260 CONTINUE
C
      ICALL = ICALL + 1
C
C********* THE SR OUTHYDRO THAT WILL DO HYDROSTATIC COMPUTATIONS,
C********* WILL ONLY NEED THE VALUES OF  Z  FOR J=J1,J2, BUT IT
C********* WILL NEED THESE FIELDS FOR THE NGM GRIDS STORED ON A
C          FULLY-DIMENSIONED ARRAY J=1,JM.     THEREFORE WE
C          COPY THESE FIELDS INTO  S( JSCR3NGM(NN,3) ) BEFORE
C          RETURNING.  (USE OF THE 3RD SET OF JSCR3NGM ARRAYS
C          WILL PREVENT OVERSTORING OF DATA THAT WOULD OCCUR
C          BECAUSE THE FIRST OF THESE ARRAY SETS BEGINS AT THE
C          PLACE WHERE S (MSZ3) STARTED. )
C
      DO 420 NN=1,NUMGDREQ
      NG=NGRIDATA(NN)
      IM=IMG(NG)
      JM=JMG(NG)
      IJ=IM*JM
      LEN=LENGD(NG)
      JJ1=J1(NG)
      JADDM1=(JJ1-1)*IM
C          ADDRESS(-LEN) OF FIRST NEEDED Z-VALUE IN ARRAY S(MSZ3)
      IADFROM=MSZ3(NG)-LEN
C          TARGET ADDRESS(-IJ)
      IADTO=JSCR3NGM(NN,3) + JADDM1 -IJ
        DO 410 K=1,KM
        IADFROM=IADFROM+LEN
        IADTO=IADTO+IJ
CMIC$ DO ALL VECTOR IF (ABS(IADFROM-IADTO).GE.LEN .OR. IADFROM-IADTO.EQ.
CMIC$1   0) SHARED(LEN, IADFROM, IADTO, S) PRIVATE(IQ2W6E)
      DO 89310 IQ2W6E=1,LEN
         S(IADTO+IQ2W6E-1)=S(IADFROM+IQ2W6E-1)
89310 CONTINUE
  410   CONTINUE
  420 CONTINUE
C
      RETURN
      END
