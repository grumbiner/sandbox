      SUBROUTINE FILLHOLE( NC, KHOLE )
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    FILLHOLE    FILL THE 'HOLE' ON GRID NC OF THE NGM
C   PRGMMR: JIM TUCCILLO       ORG: W/NMC4       DATE: 90-06-13
C
C ABSTRACT: FILL THE 'HOLE' ON GRID  NC OF THE
C   NESTED GRID MODEL WITH INTERPOLATED
C   VALUES FROM THE NEXT FINER GRID
C   ( NF = NC + 1)
C   .
C   COARSE GRID AND FINE GRID POINTS DO NOT COINCIDE.
C   BILINEAR INTERPOLATION IS USED TO GET FINE GRID VALUES TO
C   PUT IN THE HOLE OF THE COARSE GRID.  THIS IS NECESSARY
C   BEFORE THE COARSE GRID CAN BE SMOOTHED IN THE
C   SUBROUTINE  SMOOTH  .  (THIS PROCEDURE MIGHT ALSO BE
C   USEFUL IN OUTPUT PREPARATION.)
C
C PROGRAM HISTORY LOG:
C   90-06-13  J TUCCILLO
C
C USAGE:    CALL FILLHOLE( NC,  KHOLE )
C   INPUT ARGUMENT LIST:
C     NC       - NUMBER OF GRID WITH THE HOLE TO BE FILLED
C     KHOLE    - NUMBER OF LEVELS OF 'H-TYPE' VARIABLES
C                TO HAVE THEIR HOLES FILLED.
C
C   OUTPUT FILES:
C     IOUTUPRT - FOR PRINTOUT OF ERROR MESSAGES
C
C   SUBPROGRAMS CALLED:
C     UNIQUE:    - ERRPRINT
C     LIBRARY:
C       COMMON   - COMCONST
C                  COMBLANK
C
C REMARKS:
C   .
C   - - - - - - - - I N P U T   V A R I A B L E S  - - - - - - - - -
C   .
C   NAMES     MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----     ----------------------------------        ---------
C   .
C   IADDRG     INITIAL ADDRESSES IN VBL FOR EACH TYPE    COMMON
C              OF DATA FOR EACH GRID.
C   .
C   IAG,IBG,   GRID COORDINATES DEFINING THE 'HOLE' ON   COMMON
C   JAG,JBG    A COARSE GRID THAT IS COVERED BY THE
C              NEXT FINER GRID.
C   .
C   IMG,JMG    HORIZONTAL DIMENSIONS OF ALL GRIDS.       COMMON
C   .
C   VBL        ARRAY CONTAINING ALL VBLS FOR ALL GRIDS   COMMON
C   .
C   - - - - - - - - O U T P U T   V A R I A B L E S - - - - - - - - - -
C   .
C   NAMES     MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----     ----------------------------------        ---------
C   VBL        UPDATED VARIABLES.                        COMMON
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN
C   MACHINE:  CRAY Y-MP
C
C$$$
C
      INCLUDE 'parmodel'
C...TRANSLATED BY FPP 3.00Z36 11/09/90  15:13:15  
C...SWITCHES: OPTON=I47,OPTOFF=VAE0
C
C     COMMON BLOCK /COMCONST/ CONTAINS GRID-RELATED PARAMETERS,
 
C          AND A FEW OTHER COMMON CONSTANTS.
      COMMON /COMCONST/ IJMAX, KM, LVLTOT, IJRAD, LOFCLDS(2,4),
     1                  ICALLRAD, IPHYSPL, NGRDUSE, NH,
     2                  NTIME, ITIME, NSTEPS,
     3                  IMG(INGRDUSE), JMG(INGRDUSE),
     4                  IAG(INGRDUS1), JAG(INGRDUS1),
     5                  IBG(INGRDUS1), JBG(INGRDUS1),
     6                  IADDRG(INIADDRS, INGRDUSE),
     7                  NPTSFH(2, INGRDUSE),
     8                  KUMULUS, LGRIDPPT, KLIFT1, KLIFT2, IBUCKET,
     9                  XPOLEH(INGRDUSE), YPOLEH(INGRDUSE), RADIUS,
     1                  DELSIG(IKM), PR(IKM), PRESS(IKM),
     2                  SIGINT(IKMP1),
     3                  DTOVDX, ANGVEL,
     4                  SIGMACC, SIGMAGSP, SIGMADHQ, CRITCONV,
     5                  SATDEL, RHFACTOR, QBOUND,
     6                  ANEM, BLKDR, CHARN, CONAUST, DDORF, PKATO,
     7                  SCALEHT, SIGDOT, DLAMNGM
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
      LOGICAL BITFILL(640)
C
C          SPECIFY THE UNIT NUMBER OF THE PRINTER.
      IOUTUPRT = 6
C
C          NC CANNOT BE LARGER THAN (NGRDUSE-1).
      IF(NC .LT. NGRDUSE) GO TO 2
C          VIOLATION!
      WRITE (IOUTUPRT, 1) NC,NGRDUSE
    1 FORMAT(1H1,2X,'*****SR FILLHOLE ASKED TO FILL HOLE ON TOO FINE A
     1 GRID.  NC,NGRDUSE=',2I10)
C
C*****  Code Expanded From Routine:  ERRPRINT
      PRINT 77001
77001 FORMAT (1H1, '  **********  PRINT FROM SUBROUTINE ERRPRINT ',
     1             'FOLLOWS. ***********')
C
      PRINT 77002, IJMAX, KM, LVLTOT, NGRDUSE, NH
77002 FORMAT (1H1, 2X, 'IJMAX, KM, LVLTOT, NGRDUSE, NH =', 5I10)
C
      PRINT 77003, NTIME, ITIME, NSTEPS
77003 FORMAT (1H0, 2X, 'NTIME, ITIME, NSTEPS= ', 3I10 /)
C*****  End of Code Expanded From Routine:  ERRPRINT
      CALL EXIT(16)
C
    2 CONTINUE
C
      IA=IAG(NC)
      IB=IBG(NC)
      JA=JAG(NC)
      JB=JBG(NC)
      NF=NC+1
      IMC=IMG(NC)
      JMC=JMG(NC)
      IMF=IMG(NF)
      JMF=JMG(NF)
      IJC=IMC*JMC
      IJF=IMF*JMF
C
C          CHECK SIZE OF BITFILL ARRAY.
      IF(IMF .LE. 640 ) GO TO 5
C          NOT ENUF SPACE IN BITFILL ARRAY.
      WRITE (IOUTUPRT, 3) NC,NF,IMF
    3 FORMAT(1H1,2X,'**** IMF .GT. 640 IN SR FILLHOLE. NC,NF,IMF=',
     1 3I8)
C
C*****  Code Expanded From Routine:  ERRPRINT
      PRINT 77004
77004 FORMAT (1H1, '  **********  PRINT FROM SUBROUTINE ERRPRINT ',
     1             'FOLLOWS. ***********')
C
      PRINT 77005, IJMAX, KM, LVLTOT, NGRDUSE, NH
77005 FORMAT (1H1, 2X, 'IJMAX, KM, LVLTOT, NGRDUSE, NH =', 5I10)
C
      PRINT 77006, NTIME, ITIME, NSTEPS
77006 FORMAT (1H0, 2X, 'NTIME, ITIME, NSTEPS= ', 3I10 /)
C*****  End of Code Expanded From Routine:  ERRPRINT
      CALL EXIT(16)
C
    5 CONTINUE
C           PUT 10101.... INTO BIT VECTOR FOR USE IN COMPRESS.
CMIC$ DO ALL VECTOR SHARED(IMF, BITFILL) PRIVATE(I)
      DO 765 I = 1, IMF
         IF ( MOD ( I,2 ) .EQ. 1 ) THEN
            BITFILL ( I ) = .TRUE.
         ELSE
            BITFILL ( I ) = .FALSE.
         END IF
765   CONTINUE
C
C           DO HU FIELD FOR I=IA+1,IB-1 WITH J=JA+1,JB-2
C           ADDRESS OF FIRST COARSE GRID U POINT  MINUS IJC
      IAUC=IADDRG(1,NC)+IA+JA*IMC-IJC
C           ADDRESS OF FIRST FINE GRID U POINT MINUS IJF
      IAUF=IADDRG(1,NF)+8+9*IMF-IJF
C          LENGTHS OF COARSE AND FINE GRID VECTORS
      LENCU=IB-IA-1
      LENFU=2*LENCU-1
C
C          J-LIMITS FOR COARSE GRID U.
      J1=JA+1
      J2=JB-2
C
      DO 20 K=1,KM
      IAUC=IAUC+IJC
      IAUF=IAUF+IJF
      MAUF=IAUF
      MAUC=IAUC
        DO 10 J=J1,J2
C          GET A COARSE U FOR EACH FINE U
CMIC$ DO ALL VECTOR SHARED(LENFU, MAUF, VBL, SCR) PRIVATE(I)
        DO 86 I = 1, LENFU
           SCR(I,1) = ( VBL(I+MAUF-1) + VBL(I+MAUF) ) * 0.5
86      CONTINUE
C          COMPRESS AND PUT IN BASIC DATA ARRAY VBL.
        INEXT = MAUC
        DO 87 I = 1, LENFU
           IF ( BITFILL ( I ) ) THEN
              VBL ( INEXT ) = SCR ( I, 1 )
              INEXT = INEXT + 1
           END IF
87      CONTINUE
        IF ( (INEXT-MAUC ) .NE. LENCU ) THEN
           PRINT 491, INEXT
491        FORMAT(' *** IN FILLHOLE, INEXT TOO BIG, =',2X,I5)
           CALL EXIT(16)
        END IF
        MAUF=MAUF+2*IMF
        MAUC=MAUC+IMC
   10   CONTINUE
   20 CONTINUE
C
C          DO THE HV POINTS FOR I=IA+1,IB-2 WITH J=JA+1,JB-1
C          ADDRESS OF FIRST COARSE V POINT MINUS IJC
      IAVC=IADDRG(2,NC)+IA+JA*IMC-IJC
C          ADDRESS OF FIRST FINE GRID V MINUS IJF
      IAVF=IADDRG(2,NF)+9+8*IMF-IJF
C          LENGTHS OF COARSE AND FINE GRID VECTORS
      LENCV=IB-IA-2
      LENFV=2*LENCV-1
C
C           J-LIMITS FOR COARSE GRID V.
      J1=JA+1
      J2=JB-1
C
      DO 40 K=1,KM
      IAVC=IAVC+IJC
      IAVF=IAVF+IJF
      MAVF=IAVF
      MAVC=IAVC
        DO 30 J=J1,J2
C          COARSE GRID V FOR EACH FINE GRID V
CMIC$ DO ALL VECTOR SHARED(LENFV, MAVF, IMF, VBL, SCR) PRIVATE(IQ2W6E)
      DO 88890 IQ2W6E=1,LENFV
         SCR(IQ2W6E,1)=.5E0*(VBL(MAVF+IQ2W6E-1)+VBL(MAVF+IMF+IQ2W6E-1)
     *   )
88890 CONTINUE
C          COMPRESS AND PUT INTO THE BASIC DATA ARRAY.
        INEXT = MAVC
        DO 97 I = 1, LENFV
           IF ( BITFILL ( I ) ) THEN
              VBL ( INEXT ) = SCR ( I, 1 )
              INEXT = INEXT + 1
           END IF
97      CONTINUE
        MAVF=MAVF+2*IMF
        MAVC=MAVC+IMC
   30   CONTINUE
   40 CONTINUE
C
C          DO THE H POINTS FOR I=IA+1,IB-1 WITH J=JA+1,JB-1
C          ADDRESS OF FIRST COARSE H POINT MINUS IJC
      IAHC=IADDRG(3,NC)+IA+JA*IMC-IJC
C          ADDRESS OF FIRST FINE GRID H POINT MINUS IJF
      IAHF=IADDRG(3,NF)+8+8*IMF-IJF
C          LENGTHS OF COARSE AND FINE GRID VECTORS
      LENCH=IB-IA-1
      LENFH=2*LENCH-1
C
      J1=JA+1
      J2=JB-1
C
      DO 60 K=1,KHOLE
      IAHC=IAHC+IJC
      IAHF=IAHF+IJF
      MAHC=IAHC
      MAHF=IAHF
        DO 50 J=J1,J2
C         GET COARSE H VALUE FOR EACH FINE GRID H.
CMIC$ DO ALL VECTOR SHARED(LENFH, MAHF, IMF, VBL, SCR) PRIVATE(IQ2W6E)
      DO 88900 IQ2W6E=1,LENFH
         SCR(IQ2W6E,1)=.25E0*(VBL(MAHF+IQ2W6E-1)+VBL(MAHF+IMF+IQ2W6E-1
     *   ))
         SCR(IQ2W6E,1)=SCR(IQ2W6E,1)+.25E0*VBL(MAHF+IQ2W6E)
         SCR(IQ2W6E,1)=SCR(IQ2W6E,1)+.25E0*VBL(MAHF+IMF+IQ2W6E)
88900 CONTINUE
C          COMPRESS AND PUT INTO THE BASIC DATA ARRAY.
        INEXT = MAHC
        DO 98 I = 1, LENFH
           IF ( BITFILL ( I ) ) THEN
              VBL ( INEXT ) = SCR ( I, 1 )
              INEXT = INEXT + 1
           END IF
98      CONTINUE
        MAHC=MAHC+IMC
        MAHF=MAHF+2*IMF
   50   CONTINUE
   60 CONTINUE
C
      RETURN
      END
