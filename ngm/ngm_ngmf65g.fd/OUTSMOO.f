      SUBROUTINE OUTSMOO( JSMO )
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OUTSMOO     PERFORM A HORIZONTAL SMOOTHING OPERATION
C   PRGMMR: N PHILLIPS       ORG: W/NMC22    DATE: 84-03-30
C
C ABSTRACT: THE ARRAY TO BE SMOOTHED BEGINS AT LOCATION JSMO
C   IN THE HALF-PRECISION MASTER ARRAY  S   USED IN THE
C   OUTPUT PROGRAM OF THE NESTED GRID MODEL.  THE SMOOTHING
C   PERFORMED BY THIS CODE HAS THE FOLLOWING FEATURES.
C   .  A)  THE FOUR CORNER POINTS ARE UNTOUCHED.
C   .  B)  REMAINING BOUNDARY POINTS ARE SMOOTHED BY A SIMPLE 3-POINT
C   .      AVERAGE TAKEN ALONG THE BOUNDARY.
C   .  C)  POINTS ADJACENT TO THE BOUNDARY ARE SMOOTHED WITH THE
C   .      OPERATOR    1  PLUS 0.125 TIMES THE FINITE-DIFFERENCE
C   .      LAPLACIAN.
C   .  D)  REMAINING INTERIOR POINTS ARE SMOOTHED WITH THE OPERATOR
C   .           1  MINUS THE SQUARED OPERATOR (0.125 * LAPLACIAN)
C   .
C
C PROGRAM HISTORY LOG:
C   84-03-30  N PHILLIPS
C   88-08-26  B SCHMIDT REVISED THE DOCBLOCK
C
C USAGE:  CALL OUTSMOO ( JSMO   )
C   INPUT ARGUMENT LIST:
C     JSMO     - INITIAL LOCATION OF FIELD TO BE SMOOTHED
C
C   SUBPROGRAMS CALLED:
C     LIBRARY:
C       COMMON   - COMBLANK
C                  COMOUT
C
C REMARKS:
C   .
C   - - - - - - - - I N P U T   V A R I A B L E S  - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   NONAME        VARIABLE ARRAY TO BE SMOOTHED, BEGINNING   COMMON
C                 IN LOCATION  JSMO  OF THE  MASTER ARRAY
C                 S  (HALF PRECISION ) USED IN THE OUPUT PROGRAM.
C   .
C   IMOUT,        HORIZONTAL DIMENSIONS OF THE FIELD         COMMON
C   JMOUT
C   .
C   - - - - - - - - O U T P U T   V A R I A B L E S - - - - - - - - - -
C   .
C   NAMES       MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----       ----------------------------------        ---------
C   .
C   NONAME         SMOOTHED VARIABLE ARRAY.                   COMMON
C
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN
C   MACHINE:  CRAY Y-MP
C
C$$$
C
      INCLUDE 'parmodel'
C...TRANSLATED BY FPP 3.00Z36 11/09/90  14:45:05  
C...SWITCHES: OPTON=I47,OPTOFF=VAE0
C
C          PERFORM A HORIZONTAL SMOOTHING OPERATION
C          ON AN OUTPUT ARRAY BEFORE IT IS TO BE SENT
C          TO THE PACKER CODE FOR TRANSMITTAL TO THE
C                    OUTPUT FILES.
C          SUBROUTINE TO SMOOTH THE FIELD IN S(JSMO)
C
C     COMMON BLOCK /COMOUT/ CONTAINS OUTPUT CODE PARAMETERS
C               AND ARRAYS.
C
      CHARACTER*20 DESCRIPT
C
      COMMON /COMOUT/
C
C          THE FOLLOWING ARE STORED BY OUT2FILE FROM DATA CARDS.
C          (THE LAST 6 WILL BE OVERWRITTEN BY  OUTPUT  IF KGTYPE
C          IS 5 OR 26 (I.E. AN LFM GRID DEFINED IN TABLE 7 OF
C          OFFICE NOTE 84.))
C
     1     INUNIT, IOUTUNIT, IOUTGRIB,
     2     KGTYPE, IMOUT, JMOUT, DNPEQOUT, DLAMOUT, XIPOUT, YJPOUT,
C
C          THE FOLLOWING COME FROM  MAIN  READING THE DATA CARDS.
     2   LQTYPE(IMAXOUTV),   LSTYPE(IMAXOUTV),
     3   DESCRIPT(IMAXOUTV), LEVELS(ILMOUT,IMAXOUTV),  NOUTVBLS,
C
C          THE FOLLOWING ARE DERIVED BY   OUTPUT  .
     4       IJOUT, LMOUT, NFILLER, NS2, NS3NGM, NS3OUT,
     5       COSOUT,   SINOUT,    DXOUT,    ZSIGLYR(IKM),
C
C           ARRAYS  PLOUT  AND  HTFD  ARE SET BY DATA STATEMENTS IN
C           THE SR  OUTPUT  .  'PADDER' FILLS OUT TO FULL WORD BNDRY.
     6      PLOUT(ILMOUT),   HTFD( 6),  PADDER,
C
C          THE FOLLOWING ADDRESSES AND ADDRESS ARRAYS ARE SET UP
C          BY   OUTPREP  WHEN IT IS CALLED BY   OUTPUT  .
     7  J1(INGRDUSE),          J2(INGRDUSE),   JADDK2L(INGRDUSE,2),
     8  JADDFNGM(INGRDUSE), JHREC(INGRDUSE),   JHKAP(INGRDUSE),
     9  JSCR2(12),    JSCR3NGM(INGRDUSE,12),   JSCR3OUT(12),
     A  LENGD(INGRDUSE), LTYPE(ILMOUT,INGRDUSE), MB1, MB2, MINT,
     B   MSOUT1,  MSOUT2,  MZGNDOUT,  MNGM3,  MHOUT, MZFR, MZTRO,
     C      MSZGND(INGRDUSE), NGRIDATA(INGRDUSE),
C
C            NUMGDREQ, THE NUMBER OF NGM GRIDS NEEDED TO COVER THE
C            OUTPUT GRID, AND ZLOUT, ARE SET BY  OUTPREP  .
     D                NUMGDREQ,    ZLOUT(ILMOUT),
C
C          OUTPREP ALSO ASSIGNS THE FOLLOWING DESCRIPTORS TO BE
C          USED BY  OUTHORIZ  FOR HORIZONTAL INTERPOLATION.
     E    AHORD,BHORD,CHORD,DHORD, ILLD,IULD,  SCRHORD,  OUTHORD,
C
C
C          THE FOLLOWING ARRAY CONTAINS THE INTEGERS NEEDED TO
C          FORM THE LABEL THAT GOES WITH EACH OUTPUT ARRAY.
     F               LABEL84( 27 ),
C
C          THE FOLLOWING SYMBOLS REPRESENT TEMPORARY VALUES OF
C          INTEGERS TO GO INTO  LABEL84 WHEN THE OUTPUT ARRAY
C          HAS BEEN PREPARED FOR PACKING.
C
     G  LABQTYPE, LABSSUB1, LABTMARK,  S1VALUE,  S2VALUE,
     H  LABMLDIF, LABSSUB2, LABFSUB2, LABKGRID, LABNUMPT
C
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
      DIMENSION S(IIJMAX)
C
      LOGICAL B(IIJMAX)
C
      EQUIVALENCE ( SCR(1,1),S(1) )
C
      DATA IM/0/,JM/0/
C
C---------------------------------------------------------------
C
C                 INTEGERS IM AND JM RECORD THE VALUES OF IMOUT
C                 AND JMOUT THAT WERE USED THE LAST TIME THAT THIS
C                 SUBROUTINE WAS CALLED, SO THAT BIT VECTORS
C                 NEED NOT BE RECONSTRUCTED ON EACH CALL.
C
C          ARE THESE NEW VALUES OF IMOUT OR JMOUT???
C
      IF( IM .NE. IMOUT ) GO TO 1
      IF( JM .EQ. JMOUT ) GO TO 2
C          NEW GRID, MUST MAKE NEW BIT VECTOR, ETC.
    1 CONTINUE
C
      IM=IMOUT
      JM=JMOUT
      IJ=IM*JM
      LEN=IM-2
      JM2=JM-2
      JM1=JM-1
      K1=JSCR2(1)
      K2=JSCR2(2)
C
      LENB=(JM-4)*IM
      IONE=IM-4
C
      ICNT = 0
1001  CONTINUE
      DO 1002 II = 1, (IM-4)
         ICNT = ICNT + 1
         IF ( ICNT .GT. LENB ) GOTO 1004
         B(ICNT) = .TRUE.
1002  CONTINUE
      DO 1003 II = 1, (IM-(IM-4))
         ICNT = ICNT + 1
         IF ( ICNT .GT. LENB ) GOTO 1004
         B(ICNT) = .FALSE.
1003  CONTINUE
      GOTO 1001
1004  CONTINUE
C
    2 CONTINUE
C
C       SMOOTH BOTTOM AND TOP BNDARIES, EXCEPT CORNER PTS.
      IAD=JSMO+1
      DO 10 N=1,2
CMIC$ DO ALL VECTOR IF ((ABS(IAD+1-K1).GE.LEN .OR. IAD+1-K1.EQ.0) .AND. 
CMIC$1   (ABS(IAD-1-K1).GE.LEN .OR. IAD-1-K1.EQ.0)) SHARED(LEN, IAD, K1
CMIC$2   , S) PRIVATE(IQ2W6E)
      DO 88890 IQ2W6E=1,LEN
         S(K1+IQ2W6E-1)=.25E0*(S(IAD+IQ2W6E)+S(IAD+IQ2W6E-2))
88890 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(IAD-K1).GE.LEN .OR. IAD-K1.EQ.0) SHARED(LEN
CMIC$1   , IAD, K1, S) PRIVATE(IQ2W6E)
      DO 88891 IQ2W6E=1,LEN
         S(IAD+IQ2W6E-1)=.5E0*S(IAD+IQ2W6E-1)+S(K1+IQ2W6E-1)
88891 CONTINUE
      IAD=IAD + (JM-1)*IM
   10 CONTINUE
C
C       SMOOTH LEFT AND RIGHT BNDARIES, EXCEPT CORNER PTS.
      IAD=JSMO+IM
C
C       WILL SAVE VALUES TEMPORARILY IN XL1 AND XR1
C
      XL1=S(JSMO)
      XR1=S(JSMO+IM-1)
      DO 20 J=2,JM1
      XL=.25E0*( S(IAD+IM) + S(IAD-IM) ) +.5E0*S(IAD)
      S(IAD-IM)=XL1
      XL1=XL
      IAD=IAD+IM-1
      XR=.25E0*( S(IAD+IM) + S(IAD-IM) ) + .5E0*S(IAD)
      S(IAD-IM)=XR1
      XR1=XR
      IAD=IAD+1
   20 CONTINUE
C
C         STORE THE LAST TWO VALUES
      S(IAD-IM)=XL1
      S(IAD-1)=XR1
C
C         START TO SMOOTH INTERIOR POINTS.
C
C          GET ( 1 +.125*LAPLACIAN) * F INTO S(K1).
C
CMIC$ DO ALL VECTOR IF ((ABS(JSMO+1-K1).GE.IJ .OR. JSMO+1-K1.EQ.0)
CMIC$1    .AND. (ABS(JSMO-1-K1).GE.IJ .OR. JSMO-1-K1.EQ.0)) SHARED(IJ, 
CMIC$2   JSMO, K1, S) PRIVATE(IQ2W6E)
      DO 88910 IQ2W6E=1,IJ
         S(K1+IQ2W6E-1)=0.125E0*(S(JSMO+IQ2W6E)+S(JSMO+IQ2W6E-2))
88910 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(K1-IM-JSMO).GE.IJ .OR. K1-IM-JSMO.EQ.0)
CMIC$1    SHARED(IJ, K1, JSMO, IM, S) PRIVATE(IQ2W6E)
      DO 88911 IQ2W6E=1,IJ
         S(K1+IQ2W6E-1)=S(K1+IQ2W6E-1)+0.125E0*S(JSMO+IM+IQ2W6E-1)
88911 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(K1+IM-JSMO).GE.IJ .OR. K1+IM-JSMO.EQ.0)
CMIC$1    SHARED(IJ, K1, JSMO, IM, S) PRIVATE(IQ2W6E)
      DO 88912 IQ2W6E=1,IJ
         S(K1+IQ2W6E-1)=S(K1+IQ2W6E-1)+0.125E0*S(JSMO-IM+IQ2W6E-1)
88912 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(K1-JSMO).GE.IJ .OR. K1-JSMO.EQ.0) SHARED(IJ
CMIC$1   , K1, JSMO, S) PRIVATE(IQ2W6E)
      DO 88913 IQ2W6E=1,IJ
         S(K1+IQ2W6E-1)=S(K1+IQ2W6E-1)+0.5E0*S(JSMO+IQ2W6E-1)
88913 CONTINUE
C
C          THIS IS DESIRED RESULT FOR POINTS ADJACENT TO THE
C          BOUNDARY-- I.E.   FOR I=2 THRU (IM-1) ON ROWS J=2 AND JM-1
C
      IAD=JSMO+IM+1
CMIC$ DO ALL VECTOR IF (ABS(K1+IM+1-IAD).GE.LEN .OR. K1+IM+1-IAD.EQ.0)
CMIC$1    SHARED(LEN, K1, IM, IAD, S) PRIVATE(IQ2W6E)
      DO 88950 IQ2W6E=1,LEN
         S(IAD+IQ2W6E-1)=S(K1+IM+IQ2W6E)
88950 CONTINUE
      IAD=IAD+(JM-3)*IM
CMIC$ DO ALL VECTOR IF (ABS(K1+(JM-2)*IM+1-IAD).GE.LEN .OR. K1+(JM-2)*IM
CMIC$1   +1-IAD.EQ.0) SHARED(LEN, K1, JM, IM, IAD, S) PRIVATE(IQ2W6E)
      DO 88960 IQ2W6E=1,LEN
         S(IAD+IQ2W6E-1)=S(K1+(JM-2)*IM+IQ2W6E)
88960 CONTINUE
C        ALSO COPY FOR I=2 AND IM-1 FOR J=3 THROUGH (JM-2)
      IAD= 2*IM+1
CMIC$ DO ALL VECTOR IF ((ABS(K1+3-IM-JSMO).GE.(JM2-2)*ABS(IM) .OR. K1+3-
CMIC$1   IM-JSMO.EQ.0) .AND. (ABS(JSMO+3-IM-K1).GE.(JM2-2)*ABS(IM) .OR. 
CMIC$2   JSMO+3-IM-K1.EQ.0) .AND. (ABS(3-IM).GE.(JM2-2)*ABS(IM) .OR. 3-
CMIC$3   IM.EQ.0) .AND. (ABS(K1-JSMO).GE.(JM2-2)*ABS(IM) .OR. K1-JSMO
CMIC$4   .EQ.0)) SHARED(JM2, K1, IAD, JSMO, IM, S) PRIVATE(J)
      DO 30 J = 1, JM2 - 2
         S(JSMO+IAD+(J-1)*IM) = S(K1+IAD+(J-1)*IM)
         S(JSMO+IAD-3+J*IM) = S(K1+IAD-3+J*IM)
   30 CONTINUE
C
C              PROCEED WITH THE REMAINING INTERIOR POINTS
C
C      FIRST GET (1 -.125*LAPLACIAN) * S(K1) INTO S(K2)
C
CMIC$ DO ALL VECTOR IF ((ABS(K1+1-K2).GE.IJ .OR. K1+1-K2.EQ.0) .AND. (
CMIC$1   ABS(K1-1-K2).GE.IJ .OR. K1-1-K2.EQ.0)) SHARED(IJ, K1, K2, S)
CMIC$2    PRIVATE(IQ2W6E)
      DO 88970 IQ2W6E=1,IJ
         S(K2+IQ2W6E-1)=0.125E0*(S(K1+IQ2W6E)+S(K1+IQ2W6E-2))
88970 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(K2-IM-K1).GE.IJ .OR. K2-IM-K1.EQ.0) SHARED(
CMIC$1   IJ, K2, K1, IM, S) PRIVATE(IQ2W6E)
      DO 88971 IQ2W6E=1,IJ
         S(K2+IQ2W6E-1)=S(K2+IQ2W6E-1)+0.125E0*S(K1+IM+IQ2W6E-1)
88971 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(K2+IM-K1).GE.IJ .OR. K2+IM-K1.EQ.0) SHARED(
CMIC$1   IJ, K2, K1, IM, S) PRIVATE(IQ2W6E)
      DO 88972 IQ2W6E=1,IJ
         S(K2+IQ2W6E-1)=S(K2+IQ2W6E-1)+0.125E0*S(K1-IM+IQ2W6E-1)
88972 CONTINUE
CMIC$ DO ALL VECTOR IF (ABS(K2-K1).GE.IJ .OR. K2-K1.EQ.0) SHARED(IJ, K2
CMIC$1   , K1, S) PRIVATE(IQ2W6E)
      DO 88973 IQ2W6E=1,IJ
         S(K2+IQ2W6E-1)=-S(K2+IQ2W6E-1)+1.5E0*S(K1+IQ2W6E-1)
88973 CONTINUE
C
C       THIS IS DESIRED RESULT FOR I=3,(IM-2),,J=3,(JM-2).
C            STORE IT AT THESE POINTS IN THE ORIGINAL ARRAY.
C
      IAD=2*IM+2
C
CMIC$ DO ALL VECTOR IF (ABS(K2-JSMO).GE.LENB .OR. K2-JSMO.EQ.0) SHARED(
CMIC$1   LENB, K2, IAD, JSMO, B, S) PRIVATE(IQ2W6E)
      DO 89010 IQ2W6E=1,LENB
       IF ( B(IQ2W6E)) THEN
         S(JSMO+IAD+IQ2W6E-1)=S(K2+IAD+IQ2W6E-1)
       END IF
89010 CONTINUE
C
      RETURN
      END
