      SUBROUTINE OUTMCONV( S, IN, SIG1, SIG2 ,NCARD )
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OUTMCONV    COMPUTE VERT SIGMA AVE OF CONV OF MOIS
C   PRGMMR: N. PHILLIPS      ORG: W/NMC22    DATE: 87-12-15
C
C ABSTRACT: CONVERGENCE OF MOISTURE COMPUTED ON SIGMA LEVELS
C   AND INTEGRATED VERTICALLY FROM SIG1 TO SIG2
C   .
C
C PROGRAM HISTORY LOG:
C   87-12-15  N PHILLIPS
C   88-08-25  B SCHMIDT REVISED THE DOCBLOCK
C
C USAGE: CALL OUTMCONV(S, SIG1,SIG2, NCARD )
C   INPUT ARGUMENT LIST:
C     S        - SCRATCH ARRAY
C     SIG1     - BEGINNING VALUE OF VERTICAL RANGE OF SIGMA
C     SIG2     - ENDING VALUE OF VERTICAL RANGE OF SIGMA
C     NCARD    - NUMBER OF DATA CARD FOR THIS OUTPUT
C
C   SUBPROGRAMS CALLED:
C     UNIQUE:    - OUTHORIZ
C                  OUTNULAB
C                  OUTPACK
C     LIBRARY:
C       COMMON   - COMBLANK
C                  COMCONST
C                  COMOUT
C
C REMARKS:
C   .
C   - - - - - - - - I N P U T   V A R I A B L E S  - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   S             SCRATCH ARRAY                              ARGUMENT
C   .
C   UH,VH,QH,H    BASIC HISTORY VARIABLES IN ARRAY VBL       COMMON
C   .
C   SIG1, SIG2    VALUES OF SIGMA MARKING VERTICAL RANGE     ARGUMENT
C   .
C   NCARD         NUMBER OF DATA CARD FOR THIS OUTPUT        ARGUMENT
C   .
C   - - - - - - - - O U T P U T   V A R I A B L E S - - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   .
C   MOISTURE CONVERGENCE (OUNCES PER OUNCE ) PER SECOND    SUBROUTINE
C   .                                                       OUTPACK
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN
C   MACHINE:  CRAY Y-MP
C
C$$$
C
C
      INCLUDE 'parmodel'
C...TRANSLATED BY FPP 3.00Z36 11/09/90  14:58:57  
C...SWITCHES: OPTON=I47,OPTOFF=VAE0
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
C     COMMON BLOCK /COMCONST/ CONTAINS GRID-RELATED PARAMETERS,
C          AND A FEW OTHER COMMON CONSTANTS.
      COMMON /COMCONST/ IJMAX, KM, LVLTOT, IJRAD, LOFCLDS(2,4),
     1                  ICALLRAD, IPHYSPL, NGRDUSE, NH,
     2                  NTIME, ITIME, NSTEPS,
     3                  IMG(INGRDUSE), JMG(INGRDUSE),
     4                  IAG(INGRDUS1), JAG(INGRDUS1),
     5                  IBG(INGRDUS1), JBG(INGRDUS1),
     6                  IADDRG(INIADDRS, INGRDUSE),
     7                  NPTSFH(2, INGRDUSE),
     8                  KUMULUS, LGRIDPPT, KLIFT1, KLIFT2, IBUCKET,
     9                  XPOLEH(INGRDUSE), YPOLEH(INGRDUSE), RADIUS,
     1                  DELSIG(IKM), PR(IKM), PRESS(IKM),
     2                  SIGINT(IKMP1),
     3                  DTOVDX, ANGVEL,
     4                  SIGMACC, SIGMAGSP, SIGMADHQ, CRITCONV,
     5                  SATDEL, RHFACTOR, QBOUND,
     6                  ANEM, BLKDR, CHARN, CONAUST, DDORF, PKATO,
     7                  SCALEHT, SIGDOT, DLAMNGM
C
C     COMMON BLOCK /COMOUT/ CONTAINS OUTPUT CODE PARAMETERS
C               AND ARRAYS.
C
      CHARACTER*20 DESCRIPT
C          DESCRIPTORS USED IN SR  OUTHORIZ
C
      COMMON /COMOUT/
C
C          THE FOLLOWING ARE STORED BY OUT2FILE FROM DATA CARDS.
C          (THE LAST 6 WILL BE OVERWRITTEN BY  OUTPUT  IF KGTYPE
C          IS 5 OR 26 (I.E. AN LFM GRID DEFINED IN TABLE 7 OF
C          OFFICE NOTE 84.))
C
     1     INUNIT, IOUTUNIT, IOUTGRIB,
     2     KGTYPE, IMOUT, JMOUT, DNPEQOUT, DLAMOUT, XIPOUT, YJPOUT,
C
C          THE FOLLOWING COME FROM  MAIN  READING THE DATA CARDS.
     2   LQTYPE(IMAXOUTV),   LSTYPE(IMAXOUTV),
     3   DESCRIPT(IMAXOUTV), LEVELS(ILMOUT,IMAXOUTV),  NOUTVBLS,
C
C          THE FOLLOWING ARE DERIVED BY   OUTPUT  .
     4       IJOUT, LMOUT, NFILLER, NS2, NS3NGM, NS3OUT,
     5       COSOUT,   SINOUT,    DXOUT,    ZSIGLYR(IKM),
C
C           ARRAYS  PLOUT  AND  HTFD  ARE SET BY DATA STATEMENTS IN
C           THE SR  OUTPUT  .  'PADDER' FILLS OUT TO FULL WORD BNDRY.
     6      PLOUT(ILMOUT),   HTFD( 6),  PADDER,
C
C          THE FOLLOWING ADDRESSES AND ADDRESS ARRAYS ARE SET UP
C          BY   OUTPREP  WHEN IT IS CALLED BY   OUTPUT  .
     7  J1(INGRDUSE),          J2(INGRDUSE),   JADDK2L(INGRDUSE,2),
     8  JADDFNGM(INGRDUSE), JHREC(INGRDUSE),   JHKAP(INGRDUSE),
     9  JSCR2(12),    JSCR3NGM(INGRDUSE,12),   JSCR3OUT(12),
     A  LENGD(INGRDUSE), LTYPE(ILMOUT,INGRDUSE), MB1, MB2, MINT,
     B   MSOUT1,  MSOUT2,  MZGNDOUT,  MNGM3,  MHOUT, MZFR, MZTRO,
     C      MSZGND(INGRDUSE), NGRIDATA(INGRDUSE),
C
C            NUMGDREQ, THE NUMBER OF NGM GRIDS NEEDED TO COVER THE
C            OUTPUT GRID, AND ZLOUT, ARE SET BY  OUTPREP  .
     D                NUMGDREQ,    ZLOUT(ILMOUT),
C
C          OUTPREP ALSO ASSIGNS THE FOLLOWING DESCRIPTORS TO BE
C          USED BY  OUTHORIZ  FOR HORIZONTAL INTERPOLATION.
     E    AHORD,BHORD,CHORD,DHORD, ILLD,IULD,  SCRHORD,  OUTHORD,
C
C
C          THE FOLLOWING ARRAY CONTAINS THE INTEGERS NEEDED TO
C          FORM THE LABEL THAT GOES WITH EACH OUTPUT ARRAY.
     F               LABEL84( 27 ),
C
C          THE FOLLOWING SYMBOLS REPRESENT TEMPORARY VALUES OF
C          INTEGERS TO GO INTO  LABEL84 WHEN THE OUTPUT ARRAY
C          HAS BEEN PREPARED FOR PACKING.
C
     G  LABQTYPE, LABSSUB1, LABTMARK,  S1VALUE,  S2VALUE,
     H  LABMLDIF, LABSSUB2, LABFSUB2, LABKGRID, LABNUMPT
CER
      INTEGER IDGRBE(25)
C
      COMMON/ADDRS/MIILL,MIIUL,MSA,MSB,MSC,MSD
C
      DIMENSION S(1),DS(IKM),IN(1)
      DATA ICALL /0/,LABSIG/148/,LABMCV/103/
C
C
      IF(ICALL .GT. 0 ) GO TO 120
C            REDEFINE SIGMAS (TO AVOID REWRITING CODE )
      SIGMC1 = 1.E0 - SIG1
      SIGMC2 = 1.E0 - SIG2
C        VERTICAL INTEGRAL IS FROM SIGMC1 TO SIGMC2 WHERE NOW
C               SIGMA = PRESS DIVIDED BY GROUND PRESSURE
C              ( SIGMC1 IS LARGER THAN SIGMC2 )
C
C             LOCATE THE BOTTOM LAYER
      SIGT = 1.E0
      DO 20   L=1,KM
      L1 = L
      SIGT = SIGT - DELSIG(L)
C      HAVE FIRST LAYER AS SOON AS SIGMA AT LYR TOP IS LESS THAN SIGMC1
      IF(SIGT .LT. SIGMC1) GO TO 40
   20 CONTINUE
C
      PRINT 30
   30 FORMAT(1H0,10X,'COULD NOT FIND BOTTOM LYR IN MOIST CONVERGENCE')
      CALL EXIT(16)
C
C       BOTTOM LAYER IS L1.  SAVE APPROPRIATE DELTA SIGMA
   40 DS(L1) = SIGMC1 - SIGT
C            FIND TOP LAYER
      SIGT = 0.E0
      DO 50 KK = 1,KM
      L2 = KM - KK + 1
      SIGT = SIGT + DELSIG(L2)
C         TOP LAYER IS WHEN SIGMA AT BOTTOM OF LYR FIRST EXCEEDS SIGMC2
      IF( SIGT .GT. SIGMC2 ) GO TO 70
   50 CONTINUE
C
      PRINT 60
   60 FORMAT(1H0,2X,'*** COULD NOT FIND TOP LAYER IN OUTPUT OF',
     1 ' MOISTURE CONVERGENCE')
      CALL EXIT(16)
C              SAVE DELTA SIGMA FOR TOP LAYER
   70 DS(L2) = SIGT - SIGMC2
C            NUMBER OF LAYERS
      NLYRMC = L2 - L1 + 1
C            ESTABLISH THE LAYER WEIGHTS
      SUM = DS(L1)
      IF(NLYRMC .GT. 1 ) SUM = SUM + DS(L2)
      IF(NLYRMC .LT. 3 ) GO TO 90
C         WE HAVE SOME FULL INTERMEDIATE LAYERS
      N1 = L1 + 1
      N2 = L2 - 1
      DO 80 L = N1,N2
      DS(L) = DELSIG(L)
      SUM = SUM + DELSIG(L)
   80 CONTINUE
C             GET NORMALIZED WEIGHTS
   90 SUM = 1.E0 / SUM
CMIC$ DO ALL VECTOR SHARED(L2, L1, SUM, DS) PRIVATE(L)
      DO 110 L = L1,L2
      DS(L) = DS(L) * SUM
  110 CONTINUE
C
      ICALL = ICALL + 1
C          ENTRY AFTER INITIAL PREPARATORY WORK
  120 CONTINUE
C
      DO 170 NN=1,NUMGDREQ
      NG = NGRIDATA(NN)
      IM = IMG(NG)
      JM = JMG(NG)
      IJ = IM * JM
C        ADDRESS FOR INPUT FIELD FOR HORIZONTAL INTERPOLATION
      IADF = JADDFNGM(NG)
C          ADDRESS FOR RECIPROCAL OF H
      IADHR = JHREC(NG)
C          INITIAL ADDRESSES OF TWO-DIMENSIONAL SCRATCH ARRAYS
      IAD1 = JSCR2(1)
      IAD2 = JSCR2(2)
      IAD3 = JSCR2(3)
      IAD4 = JSCR2(4)
C
C            1 / H**2  TO ARRAY 1
CMIC$ DO ALL VECTOR IF (ABS(IADHR-IAD1).GE.IJ .OR. IADHR-IAD1.EQ.0)
CMIC$1    SHARED(IJ, IADHR, IAD1, S) PRIVATE(IQ2)
      DO 88890 IQ2=1,IJ
         S(IAD1+IQ2-1)=S(IADHR+IQ2-1)*S(IADHR+IQ2-1)
88890 CONTINUE
C         NEED MODIFIED SCALE FACTOR =  M  / ( 4 TIMES GRID INCREMENT )
      DNPNGMA = FLOAT(NH) + 0.5E0
      A2OVDEL = DNPNGMA * ( 2**(NG-1) )
      CSC1 = A2OVDEL / ( 8.E0 * RADIUS )
      CSC2 = 1.E0 / ( 8.E0 * RADIUS * A2OVDEL )
C         NEED ONE DIMENSIONAL ARRAY OF  I MINUS I(POLE)
      S(IAD2) = 1.E0 - XPOLEH(NG)
CDIR@ NEXTSCALAR
        DO 130 I = 2,IM
        S(IAD2+I-1) = S(IAD2+I-2) + 1.E0
  130   CONTINUE
CMIC$ DO ALL VECTOR SHARED(IM, IAD2, S) PRIVATE(I)
        DO 140 I = 1,IM
        S(IAD2+I-1) = S(IAD2+I-1)*S(IAD2+I-1)
  140   CONTINUE
C          EXTEND OVER ALL J ROWS, BEGINNING WITH J = 2
      YTERM = 1.E0 - YPOLEH(NG)
      IAD = IAD2
        DO 150 J = 2,JM
        IAD = IAD + IM
        YTERM = YTERM + 1.E0
        YTERM2 = YTERM*YTERM
CMIC$ DO ALL VECTOR IF (ABS(IAD2-IAD).GE.IM .OR. IAD2-IAD.EQ.0) SHARED(
CMIC$1   IM, IAD2, YTERM2, IAD, S) PRIVATE(IQ2)
      DO 88900 IQ2=1,IM
         S(IAD+IQ2-1)=S(IAD2+IQ2-1)+YTERM2
88900 CONTINUE
  150   CONTINUE
C            CAN NOW DO THE FIRST J ROW
      YTERM = 1.E0 - YPOLEH(NG)
      YTERM2 = YTERM*YTERM
CMIC$ PARALLEL SHARED(IJ, CSC2, IAD2, CSC1, S, IM, YTERM2) PRIVATE(IQ2)
CMIC$ DO PARALLEL VECTOR
      DO 88910 IQ2=1,IM
         S(IAD2+IQ2-1)=S(IAD2+IQ2-1)+YTERM2
88910 CONTINUE
C           FINISH COMPUTATION OF MODIFIED SCALE FACTOR
CMIC$ DO PARALLEL VECTOR
      DO 88920 IQ2=1,IJ
         S(IAD2+IQ2-1)=CSC2*S(IAD2+IQ2-1)
         S(IAD2+IQ2-1)=CSC1+S(IAD2+IQ2-1)
88920 CONTINUE
CMIC$ END PARALLEL
C             1 / ( H**2 TIME SCALE FACTOR)  INTO ARRAY 1
CMIC$ DO ALL VECTOR IF (ABS(IAD1-IAD2).GE.IJ .OR. IAD1-IAD2.EQ.0)
CMIC$1    SHARED(IJ, IAD1, IAD2, S) PRIVATE(IQ2)
      DO 88940 IQ2=1,IJ
         S(IAD1+IQ2-1)=S(IAD1+IQ2-1)/S(IAD2+IQ2-1)
88940 CONTINUE
C            ADDRESSES FOR VARIABLES HU, HV, AND HQ
      IADU = IADDRG(1,NG)
      IADV = IADDRG(2,NG)
      IADQ = IADDRG(4,NG)
C
        DO 160 K = L1,L2
        KADD = (K-1)*IJ
        IADUU = IADU + KADD
        IADVV = IADV + KADD
        IADQQ = IADQ + KADD
CMIC$ DO ALL VECTOR IF (ABS(IAD3-IAD1).GE.IJ .OR. IAD3-IAD1.EQ.0)
CMIC$1    SHARED(IJ, IADUU, IM, IAD3, IADQQ, IAD1, VBL, S) PRIVATE(IQ2)
      DO 88950 IQ2=1,IJ
         S(IAD3+IQ2-1)=VBL(IADUU+IQ2-1)+VBL(IADUU-IM+IQ2-1)
         S(IAD3+IQ2-1)=S(IAD3+IQ2-1)*VBL(IADQQ+IQ2-1)
         S(IAD3+IQ2-1)=S(IAD3+IQ2-1)*S(IAD1+IQ2-1)
88950 CONTINUE
C          ACCUMULATE MINUS DIVERGENCE IN ARRAY 4
CMIC$ DO ALL VECTOR IF ((ABS(IAD3-1-IAD4).GE.IJ .OR. IAD3-1-IAD4.EQ.0)
CMIC$1    .AND. (ABS(IAD3+1-IAD4).GE.IJ .OR. IAD3+1-IAD4.EQ.0)) SHARED(
CMIC$2   IJ, IAD3, IAD4, S) PRIVATE(IQ2)
      DO 88980 IQ2=1,IJ
         S(IAD4+IQ2-1)=S(IAD3+IQ2-2)-S(IAD3+IQ2)
88980 CONTINUE
C           THE Y TERM
CMIC$ DO ALL VECTOR IF (ABS(IAD3-IAD1).GE.IJ .OR. IAD3-IAD1.EQ.0)
CMIC$1    SHARED(IJ, IADVV, IAD3, IADQQ, IAD1, VBL, S) PRIVATE(IQ2)
      DO 88990 IQ2=1,IJ
         S(IAD3+IQ2-1)=VBL(IADVV+IQ2-1)+VBL(IADVV+IQ2-2)
         S(IAD3+IQ2-1)=S(IAD3+IQ2-1)*VBL(IADQQ+IQ2-1)
         S(IAD3+IQ2-1)=S(IAD3+IQ2-1)*S(IAD1+IQ2-1)
88990 CONTINUE
C           COMBINE
CMIC$ DO ALL VECTOR IF ((ABS(IAD4+IM-IAD3).GE.IJ .OR. IAD4+IM-IAD3.EQ.0)
CMIC$1    .AND. (ABS(IAD4-IM-IAD3).GE.IJ .OR. IAD4-IM-IAD3.EQ.0))
CMIC$2    SHARED(IJ, IAD4, IAD3, IM, S) PRIVATE(IQ2)
      DO 89020 IQ2=1,IJ
         S(IAD4+IQ2-1)=S(IAD4+IQ2-1)+S(IAD3-IM+IQ2-1)
         S(IAD4+IQ2-1)=S(IAD4+IQ2-1)-S(IAD3+IM+IQ2-1)
89020 CONTINUE
C          ACCUMULATE WEIGHTED LEVEL SUM IN INTERPOLATION ARRAY FNGM
        DSKK = DS(K)
        IF( K .EQ. L1 )THEN
CMIC$ DO ALL VECTOR IF (ABS(IAD4-IADF).GE.IJ .OR. IAD4-IADF.EQ.0)
CMIC$1    SHARED(IJ, DSKK, IAD4, IADF, S) PRIVATE(IQ2)
      DO 89040 IQ2=1,IJ
         S(IADF+IQ2-1)=DSKK*S(IAD4+IQ2-1)
89040 CONTINUE
      END IF
        IF( K .GT. L1 )THEN
CMIC$ DO ALL VECTOR IF (ABS(IAD4-IADF).GE.IJ .OR. IAD4-IADF.EQ.0)
CMIC$1    SHARED(IJ, DSKK, IAD4, IADF, S) PRIVATE(IQ2)
      DO 89050 IQ2=1,IJ
         S(IADF+IQ2-1)=DSKK*S(IAD4+IQ2-1)+S(IADF+IQ2-1)
89050 CONTINUE
      END IF
C                END OF K LOOP
  160   CONTINUE
C           MULTIPLY BY M**2 AND PUT INTO ARRAY FNGM
CMIC$ DO ALL VECTOR IF (ABS(IADF-IAD2).GE.IJ .OR. IADF-IAD2.EQ.0)
CMIC$1    SHARED(IJ, IADF, IAD2, S) PRIVATE(IQ2)
      DO 89060 IQ2=1,IJ
         S(IADF+IQ2-1)=S(IADF+IQ2-1)*S(IAD2+IQ2-1)
         S(IADF+IQ2-1)=S(IADF+IQ2-1)*S(IAD2+IQ2-1)
89060 CONTINUE
C
C            END OF DO-LOOP ON THE REQUIRED GRIDS
  170 CONTINUE
C
C            INTERPOLATE TO OUTPUT GRID
        CALL OUTHORIZ(IN(MIILL),IN(MIIUL),S(MSA),S(MSB),S(MSC),
     *                S(MSD),S(MSOUT1),S(MSOUT2))
C
      LABQTYPE = LABMCV
      LABSSUB1 = LABSIG
      LABSSUB2 = LABSIG
      LABMLDIF = 2
C          NOTE THAT THE 1ST SFC IS THE HIGHER OF THE TWO
      S1VALUE = SIGMC2
      S2VALUE = SIGMC1
C
             CALL OUTNULAB
C
C  SET UP PDS INFO
C
      CALL LAB2PDS(LABEL84,IDGRBE)
      IDGRBE(7) =   0
      IDGRBE(8) = 135
      IDGRBE(9) = 108
      ALEV1 = REAL(LABEL84(5))
      ARGL1 = REAL(LABEL84(6))
      XLEV1 = ALEV1 * 10.**ARGL1
      IDGRBE(10) =  INT(XLEV1 * 100.)
      ALEV2 = REAL(LABEL84(12))
      ARGL2 = REAL(LABEL84(13))
      XLEV2 = ALEV2 * 10.**ARGL2
      IDGRBE(11) =  INT(XLEV2 * 100.)
      IDGRBE(18) =  LABEL84(3)
      IDGRBE(19) =  0
      IDGRBE(20) =  0
C
c            CALL OUTPACK(S(MSOUT2),IJOUT,S(MSOUT1),DESCRIPT(NCARD),
c    1         LABEL84, IOUTUNIT )
             CALL GRIBITN (S(MSOUT2),IJOUT,S(MSOUT1),DESCRIPT(NCARD),
     1         IDGRBE,IOUTGRIB,LABEL84 )
C
C             RESTORE SEVERAL NORMAL VALUES
      LABMLDIF = 0
      LABSSUB2 = 0
      S2VALUE = 0.E0
C
      RETURN
      END
