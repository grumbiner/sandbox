      SUBROUTINE OUTFDTUV
CFPP$ NOCONCUR R
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:   OUTFDTUV    COMPUTE TEMP AND WIND COMP AT THE FD HGTS
C   PRGMMR: N PHILLIPS      ORG: W/NMC22    DATE: 84-04-15
C
C ABSTRACT: SIGMA LEVEL OUTPUT GRIDS OF TEMPERATURE, HEIGHT,
C   U VELOCITY COMPONENT AND V VELOCITY COMPONENT ARE STORED IN THE
C   FOUR ARRAYS S( JSCR3OUT(N=1,4,5 AND 3) ) .  THIS CODE, FOR
C   EACH FD HEIGHT LEVEL, LOCATES THIS SURFACE OF FIXED HEIGHT IN
C   SIGMA-SPACE, AND DETERMINES GATHER INTEGERS AND VERTICAL
C   INTERPOLATION COEFFICIENTS TO CALCULATE A VARIABLE AT THIS
C   HEIGHT.  THE 'DATA CARDS' ARE EXAMINED TO SEE IF, IN TURN,
C   TEMPERATURE, U-VELOCITY, AND V-VELOCITY ARE REQUESTED.  IF SO,
C   THE FIELD IS GATHERED AND INTERPOLATED, THE LABEL INFORMATION
C   IS SET UP. AFTER SMOOTHING, THE ARRAY IS SENT TO THE PACKER CODE.
C   THE CODE THEN PROCEEDS TO THE NEXT FD HEIGHT LEVEL.
C   .
C
C PROGRAM HISTORY LOG:
C   84-04-15  N PHILLIPS
C   85-01-10  N PHILLIPS ADDED SMOOTHING
C   88-08-25  B SCHMIDT REVISED THE DOCBLOCK
C
C USAGE:  CALL OUTFDTUV
C   SUBPROGRAMS CALLED:
C     UNIQUE:    - OUTNULAB
C                  OUTPACK
C                  OUTSMOO
C     LIBRARY:
C       COMMON   - COMBLANK
C                  COMCONST
C                  COMOUT
C
C REMARKS:
C   .
C   THIS MUST BE DONE ONLY AFTER THE TEMPERATURE,HEIGHT,U,AND V
C   FIELDS AT SIGMA LEVELS ON THE OUTPUT GRID HAVE BEEN SET UP, AND
C   THE MAIN OUTPUT CODE( SUBROUTINE  OUTPUT  ) HAS DETERMINED THAT
C   AT LEAST ONE OF THE VARIABLES IS WANTED.
C   THE FD HEIGHTS IN METERS ARE PRESUMABLY IN THE ARRAY
C   HTFD(6) IN LABELED COMMON  COMOUT  .  THE CODES ASSUME THERE
C   ARE SIX FD HEIGHTS.
C   .
C   - - - - - - - - I N P U T   V A R I A B L E S  - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   HEIGHT        HEIGHT IN METERS OF SIGMA SURFACES ON      COMMON
C   .             THE OUTPUT GRID: IN S(JSCR3OUT(4) ).
C   .
C   TEMPERATURE   TEMPERATURE (DEG K) AT SIGMA SURFACES ON   COMMON
C   .             THE OUTPUT GRID: IN S(JSCR3OUT(1) ).
C   .
C   U,V           U AND V VELOCITY COMPONENTS(PARALLEL TO    COMMON
C   .             THE OUTPUT GRID AXES) ON SIGMA SURFACES ON
C   .             THE OUTPUT GRID( IN S(JSCR3OUT(5) ) AND
C   .             S( JSCR3OUT(3) ).
C   .
C   HTFD          THE ARRAY OF FD HEIGHTS(METERS)            COMMON
C   .
C   - - - - - - - - O U T P U T   V A R I A B L E S - - - - - - - - - -
C   .
C   NAMES         MEANING/CONTENT/PURPOSE/UNITS/TYPE        INTERFACE
C   -----         ----------------------------------        ---------
C   ALL OUTPUT FROM THIS ROUTINE TAKES PLACE THROUGH CALLS
C   TO THE SUBROUTINES  OUTNULAB  AND OUTPACK
C   .
C   FOR OUTNULAB, THE FOLLOWING LABEL INFORMATION IS PREPARED.
C   .
C   LABSSUB1      =1 FOR HEIGHT SURFACE OUTPUT               COMMON
C   .
C   S1VALUE       = ONE OF THE FD HEIGHTS                    COMMON
C   .
C   LABQTYPE      =16,48, OR 49 FOR TEMPERATURE,U, OR V.     COMMON
C   .
C   FOR OUTPACK THE FOLLOWING INFORMATION IS SUPPLIED.
C   .
C   S(MSOUT2)     THE ARRAY OF TEMPERATURE, U, OR V         ARGUMENT
C   .
C   IJOUT         THE SIZE OF THE OUTPUT GRID               ARGUMENT
C   .
C   S(MSOUT1)     SCRATCH SPACE FOR PACKER CODE(SIZE IJOUT) ARGUMENT
C   .
C   DESCRIPT(NCD) 20 CHARACTER STRING TO DESCRIBE OUTPUT    ARGUMENT
C   .
C   LABEL84       ARRAY IN COMOUT CONTAINING LABEL INFO.    ARGUMENT
C   .
C   IOUTUNIT      DISK UNIT NUMBER FOR PACKER TO WRITE ON.  ARGUMENT
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN
C   MACHINE:  CRAY Y-MP
C
C$$$
C
      INCLUDE 'parmodel'
C...TRANSLATED BY FPP 3.00Z36 11/09/90  14:45:01  
C...SWITCHES: OPTON=I47,OPTOFF=VAE0
C
      COMMON            SCR     (IIJMAX,  INSCR),
     1                  SCRGEOG (IIJMAX,  INSCRGEO),
     2                  SCR3    (IIJKMAX, INSCR3),
     3                  FILLER  (INFILLER),
     4                  VBL     (INVBL),
     5                  BITGRDH (IIJMAX, 2, INGRDUSE),
     6                  BITGRDU (IIJMAX, 2, INGRDUSE),
     7                  BITGRDV (IIJMAX, 2, INGRDUSE),
     8                  BITSEA  (IIJMAX, INGRDUSE),
     9                  BITSNO  (IIJMAX, INGRDUSE),
     1                  BITWVL  (IIJMAX, INGRDUSE)
C
      LOGICAL BITGRDH, BITGRDU, BITGRDV, BITSEA, BITSNO, BITWVL
C
C     COMMON BLOCK /COMCONST/ CONTAINS GRID-RELATED PARAMETERS,
C          AND A FEW OTHER COMMON CONSTANTS.
      COMMON /COMCONST/ IJMAX, KM, LVLTOT, IJRAD, LOFCLDS(2,4),
     1                  ICALLRAD, IPHYSPL, NGRDUSE, NH,
     2                  NTIME, ITIME, NSTEPS,
     3                  IMG(INGRDUSE), JMG(INGRDUSE),
     4                  IAG(INGRDUS1), JAG(INGRDUS1),
     5                  IBG(INGRDUS1), JBG(INGRDUS1),
     6                  IADDRG(INIADDRS, INGRDUSE),
     7                  NPTSFH(2, INGRDUSE),
     8                  KUMULUS, LGRIDPPT, KLIFT1, KLIFT2, IBUCKET,
     9                  XPOLEH(INGRDUSE), YPOLEH(INGRDUSE), RADIUS,
     1                  DELSIG(IKM), PR(IKM), PRESS(IKM),
     2                  SIGINT(IKMP1),
     3                  DTOVDX, ANGVEL,
     4                  SIGMACC, SIGMAGSP, SIGMADHQ, CRITCONV,
     5                  SATDEL, RHFACTOR, QBOUND,
     6                  ANEM, BLKDR, CHARN, CONAUST, DDORF, PKATO,
     7                  SCALEHT, SIGDOT, DLAMNGM
C
C     COMMON BLOCK /COMOUT/ CONTAINS OUTPUT CODE PARAMETERS
C               AND ARRAYS.
C
      CHARACTER*20 DESCRIPT
C
      COMMON /COMOUT/
C
C          THE FOLLOWING ARE STORED BY OUT2FILE FROM DATA CARDS.
C          (THE LAST 6 WILL BE OVERWRITTEN BY  OUTPUT  IF KGTYPE
C          IS 5 OR 26 (I.E. AN LFM GRID DEFINED IN TABLE 7 OF
C          OFFICE NOTE 84.))
C
     1     INUNIT, IOUTUNIT, IOUTGRIB,
     2     KGTYPE, IMOUT, JMOUT, DNPEQOUT, DLAMOUT, XIPOUT, YJPOUT,
C
C          THE FOLLOWING COME FROM  MAIN  READING THE DATA CARDS.
     2   LQTYPE(IMAXOUTV),   LSTYPE(IMAXOUTV),
     3   DESCRIPT(IMAXOUTV), LEVELS(ILMOUT,IMAXOUTV),  NOUTVBLS,
C
C          THE FOLLOWING ARE DERIVED BY   OUTPUT  .
     4       IJOUT, LMOUT, NFILLER, NS2, NS3NGM, NS3OUT,
     5       COSOUT,   SINOUT,    DXOUT,    ZSIGLYR(IKM),
C
C           ARRAYS  PLOUT  AND  HTFD  ARE SET BY DATA STATEMENTS IN
C           THE SR  OUTPUT  .  'PADDER' FILLS OUT TO FULL WORD BNDRY.
     6      PLOUT(ILMOUT),   HTFD( 6),  PADDER,
C
C          THE FOLLOWING ADDRESSES AND ADDRESS ARRAYS ARE SET UP
C          BY   OUTPREP  WHEN IT IS CALLED BY   OUTPUT  .
     7  J1(INGRDUSE),          J2(INGRDUSE),   JADDK2L(INGRDUSE,2),
     8  JADDFNGM(INGRDUSE), JHREC(INGRDUSE),   JHKAP(INGRDUSE),
     9  JSCR2(12),    JSCR3NGM(INGRDUSE,12),   JSCR3OUT(12),
     A  LENGD(INGRDUSE), LTYPE(ILMOUT,INGRDUSE), MB1, MB2, MINT,
     B   MSOUT1,  MSOUT2,  MZGNDOUT,  MNGM3,  MHOUT, MZFR, MZTRO,
     C      MSZGND(INGRDUSE), NGRIDATA(INGRDUSE),
C
C            NUMGDREQ, THE NUMBER OF NGM GRIDS NEEDED TO COVER THE
C            OUTPUT GRID, AND ZLOUT, ARE SET BY  OUTPREP  .
     D                NUMGDREQ,    ZLOUT(ILMOUT),
C
C          OUTPREP ALSO ASSIGNS THE FOLLOWING DESCRIPTORS TO BE
C          USED BY  OUTHORIZ  FOR HORIZONTAL INTERPOLATION.
     E    AHORD,BHORD,CHORD,DHORD, ILLD,IULD,  SCRHORD,  OUTHORD,
C
C
C          THE FOLLOWING ARRAY CONTAINS THE INTEGERS NEEDED TO
C          FORM THE LABEL THAT GOES WITH EACH OUTPUT ARRAY.
     F               LABEL84( 27 ),
C
C          THE FOLLOWING SYMBOLS REPRESENT TEMPORARY VALUES OF
C          INTEGERS TO GO INTO  LABEL84 WHEN THE OUTPUT ARRAY
C          HAS BEEN PREPARED FOR PACKING.
C
     G  LABQTYPE, LABSSUB1, LABTMARK,  S1VALUE,  S2VALUE,
     H  LABMLDIF, LABSSUB2, LABFSUB2, LABKGRID, LABNUMPT
CER
      INTEGER IDGRBE(25)
C
      LOGICAL BITS, BIT1D, BIT2D
C
C          REFERENCE SCRATCH ARRAYS
      DIMENSION S(IIJMAX), IN(IIJMAX), BITS(IIJMAX)
C
      DIMENSION HGTMIN(IKM), HGTMAX(IKM), KSTART(6), KEND(6)
C
      EQUIVALENCE ( SCR(1,1), S(1), IN(1), BITS(1) )
C
      INTEGER I,I1X,I2X,I3X
      DATA LABHGT/1/, LABTEMP/16/, LABUGRD/48/, LABVGRD/49/
C
C          LOCATE THE DATA CARDS TO CHECK THE LEVELS
      NCARDT=0
      NCARDU=0
      NCARDV=0
      DO 10 N=1,NOUTVBLS
      NCARD=N
      IF( LSTYPE(N) .NE. LABHGT ) GO TO 10
      IF( LQTYPE(N) .EQ. LABTEMP) NCARDT=NCARD
      IF( LQTYPE(N) .EQ. LABUGRD) NCARDU=NCARD
      IF( LQTYPE(N) .EQ. LABVGRD) NCARDV=NCARD
   10 CONTINUE
C
C
C          ESTABLISH THE HEIGHT RANGES FOR EACH SIGMA SURFACE
      IAD=JSCR3OUT(4) -IJOUT
      DO 15 K=1,KM
      IAD=IAD+IJOUT
      HMIN =  S(IAD)
      HMAX =  S(IAD)
      DO 1001 IQ2 = 1, IJOUT
         HMIN = AMIN1 ( HMIN, S ( IQ2 + IAD - 1 ) )
         HMAX = AMAX1 ( HMAX, S ( IQ2 + IAD - 1 ) )
1001  CONTINUE
      HGTMIN(K)= HMIN
      HGTMAX(K)= HMAX
   15 CONTINUE
C
C          ARRAY KSTART(L=1,6) WILL CONTAIN THE FIRST K VALUE
C     SUCH THAT HGTMAX(KSTART(L) ) .GE. HTFD(L), WHERE HTFD(L)
C     IS THE FD HEIGHT FOR FD LEVEL L.
C          ARRAY KEND(L=1,6) WILL CONTAIN THE FIRST K VALUE
C     SUCH THAT HGTMIN(KEND(L) ) .GE. HTFD(L) .
C
      DO 35 L=1,6
      H1=HTFD(L)
        DO 20 K=1,KM
        IF( HGTMAX(K) .LT. H1 ) GO TO 20
        KSTART(L)=K
        GO TO 25
   20   CONTINUE
C
   25   DO 30 K=1,KM
        IF( HGTMIN(K) .LT. H1 ) GO TO 30
        KEND(L)=K
        GO TO 35
   30   CONTINUE
C
   35 CONTINUE
C
C          ENTER LOOP ON THE SIX FD LEVELS
C
      LVS = 1
88200 IF ( LVS .GT. 6 ) GOTO 99200
C          THE HEIGHT VALUE
      HGTW=HTFD(LVS)
C          IS THIS LEVEL WANTED?
      IWANT=LEVELS(LVS,NCARDT)+LEVELS(LVS,NCARDU)+LEVELS(LVS,NCARDV)
C          SKIP TO END OF LOOP IF NOT WANTED
      IF( IWANT .EQ. 0 ) GO TO 200
C
C          INITIALIZE THE GATHER ARRAY TO THE GRID POINT NUMBERS
      DO 1002 IQ2 = 1, IJOUT
         IN(MINT+IQ2-1) = IQ2
1002  CONTINUE
C
C          BIT1D WILL = 1 FOR ALL GRID POINTS WHOSE GATHER INTEGER
C          HAS BEEN OBTAINED( THE GATHER INTEGER IS FOR THE POINT
C          IN A THREE-DIMENSIONAL OUTPUT GRID ARRAY THAT IS JUST
C          ABOVE A HEIGHT EQUAL TO HGTW.)
C            BIT2D WILL LOCATE ALL POINTS ON LEVEL K WHOSE HEIGHT
C          EXCEEDS HGTW.
C
C          ARE THERE ANY POINTS FOR WHICH HGTW LIES BELOW HGT(K=1)?
      IAD1=JSCR3OUT(4)
      IF( HGTW .GE. HGTMAX(1) ) GO TO 40
C          YES, THERE ARE SOME POINTS BELOW LEVEL K=1.
C          FOR THESE SET BIT1D = 1 ( SO GATHER INTEGER IS FOR K=1)
      DO 88890 IQ2W6E=1,IJOUT
         BITS(MB1+IQ2W6E-1)=S(IAD1+IQ2W6E-1).GT.HGTW
88890 CONTINUE
      IBELOW=1
      GO TO 45
C
C          THERE ARE NO POINTS BELOW K=1
C            THEREFORE INITIALIZE BIT1D TO ALL ZEROS.
40    CONTINUE
      DO 2001 IQ2 = 1, IJOUT
         BITS(MB1+IQ2-1) = .FALSE.
2001  CONTINUE
      IBELOW = 0
C
   45 CONTINUE
C          ENTER LOOP ON K TO GET REST OF GATHER INTEGERS
      K1=KSTART(LVS)
      K2=KEND(LVS)
C
        DO 100 K=K1,K2
        INC=(K-1)*IJOUT
C          ADDRESS OF I=1,J=1 AT LEVEL K IN ARRAY OF HGT(SIGMA)
        IADH=JSCR3OUT(4)+INC
C          WHICH POINTS HAVE HGT(K) .GE. HGTW?
      DO 88900 IQ2W6E=1,IJOUT
         BITS(MB2+IQ2W6E-1)=S(IADH+IQ2W6E-1).GE.HGTW
88900 CONTINUE
C          WHICH OF THESE ARE NEW POINTS?
      DO 88910 IQ2W6E=1,IJOUT
         BITS(MB2+IQ2W6E-1)=BITS(MB2+IQ2W6E-1).AND..NOT.BITS(MB1+
     *   IQ2W6E-1)
88910 CONTINUE
C          FOR THESE ADD INC TO THE GATHER INTEGERS
      DO 88920 IQ2W6E=1,IJOUT
         IF ( BITS(MB2+IQ2W6E-1) ) THEN
             IN(MINT+IQ2W6E-1)=IN(MINT+IQ2W6E-1)+INC
         END IF
88920 CONTINUE
C
C          RECORD THE NEW POINTS IN BIT1D
      DO 88930 IQ2W6E=1,IJOUT
         BITS(MB1+IQ2W6E-1)=BITS(MB1+IQ2W6E-1).OR.BITS(MB2+IQ2W6E-1)
88930 CONTINUE
C
  100   CONTINUE
C
C          SHOULD NOW HAVE THE COMPLETE ARRAY OF GATHER INTEGERS.
C
C          THE GATHER ORIGIN FOR THE 1ST HGT ABOVE HGTW
      IADH=JSCR3OUT(4)-1
C
C          A NOMINAL LENGTH
      LEN=1
C          LABEL FOR THE SURFACE TYPE
      LABSSUB1=LABHGT
C
C           THE S1VALUE FOR THE LABEL
      S1VALUE=HGTW
C          FIRST THE TEMPERATURE
      IF ( NCARDT .EQ. 0 ) GO TO 120
      IF( LEVELS(LVS,NCARDT) .NE. 1 ) GO TO 120
      LABQTYPE=LABTEMP
      NCD=NCARDT
      IADGET=JSCR3OUT(1)-1
      IRET=1
      GO TO 300
C
C           NEXT THE U VALUES
  120 IF( NCARDU .EQ. 0 ) GO TO 130
      IF( LEVELS(LVS,NCARDU) .NE. 1 ) GO TO 130
      LABQTYPE=LABUGRD
      NCD=NCARDU
      IADGET=JSCR3OUT(5)-1
      IRET=2
      GO TO 300
C
C          FINALLY THE V FIELD
  130 IF( NCARDV .EQ. 0 ) GO TO 140
      IF( LEVELS(LVS,NCARDV) .NE. 1 ) GO TO 140
      LABQTYPE=LABVGRD
      NCD=NCARDV
      IADGET=JSCR3OUT(3)-1
      IRET=3
      GO TO 300
C
  140 CONTINUE
C
C          DONE FOR LEVEL LVS
  200 LVS = LVS + 1
      GOTO 88200
99200 CONTINUE
CW200 CONTINUE
C          DONE WITH ALL FD LEVELS
      RETURN
C
C
C--------------------------------------------------------------
C          COMPUTED GO TO ROUTINE TO DO VERTICAL INTERPOLATION
  300 CONTINUE
C          GATHER VBL ABOVE HGTW INTO S2D
C*****  Code Expanded From Routine:  RDHGATHR
      DO 77055 I = 1, IJOUT
         S(I+JSCR2(2)-1) = S(IN(I+MINT-1)+IADGET)
77055 CONTINUE
C*****  End of Code Expanded From Routine:  RDHGATHR
C*****  Code Expanded From Routine:  RDHGATHR
      DO 77056 I1X = 1, IJOUT
         S(I1X+JSCR2(1)-1) = S(IN(I1X+MINT-1)+IADGET-IJOUT)
77056 CONTINUE
C*****  End of Code Expanded From Routine:  RDHGATHR
C          DIFFERENCE INTO S2D
      DO 88940 IQ2W6E=1,IJOUT
         S(JSCR2(2)+IQ2W6E-1)=S(JSCR2(2)+IQ2W6E-1)-S(JSCR2(1)+IQ2W6E-1
     *   )
88940 CONTINUE
C          HGT VALUE ABOVE HGTW INTO S3D
C*****  Code Expanded From Routine:  RDHGATHR
      DO 77057 I2X = 1, IJOUT
         S(I2X+JSCR2(3)-1) = S(IN(I2X+MINT-1)+IADH)
77057 CONTINUE
C*****  End of Code Expanded From Routine:  RDHGATHR
C*****  Code Expanded From Routine:  RDHGATHR
      DO 77058 I3X = 1, IJOUT
         S(I3X+MSOUT2-1) = S(IN(I3X+MINT-1)+IADH-IJOUT)
77058 CONTINUE
C*****  End of Code Expanded From Routine:  RDHGATHR
C          DIFFERENCE TO S3D
      DO 88950 IQ2W6E=1,IJOUT
         S(JSCR2(3)+IQ2W6E-1)=S(JSCR2(3)+IQ2W6E-1)-S(MSOUT2+IQ2W6E-1)
88950 CONTINUE
C        THE RATIO ( DELTA VBL / DELTA HGT ) TO S2D.
      DO 88960 IQ2W6E=1,IJOUT
         S(JSCR2(2)+IQ2W6E-1)=S(JSCR2(2)+IQ2W6E-1)/S(JSCR2(3)+IQ2W6E-1
     *   )
88960 CONTINUE
C          MULTIPLY WITH HGTW - HGT(BELOW).
      DO 88970 IQ2W6E=1,IJOUT
         S(JSCR2(3)+IQ2W6E-1)=(HGTW-S(MSOUT2+IQ2W6E-1))*S(JSCR2(2
     *   )+IQ2W6E-1)
88970 CONTINUE
C           BUT ARE THERE POINTS BELOW K=1?
      IF( IBELOW .EQ. 1) GO TO 310
C          NO POINTS BELOW K=1
      DO 88980 IQ2W6E=1,IJOUT
         S(MSOUT2+IQ2W6E-1)=S(JSCR2(1)+IQ2W6E-1)+S(JSCR2(3)+IQ2W6E-1)
88980 CONTINUE
      GO TO 320
C
C          THERE ARE POINTS BELOW K=1. FIRST INITIALIZE S4D WITH
C          K=1 VALUES.
  310 CONTINUE
      DO 88990 IQ2W6E=1,IJOUT
         S(MSOUT2+IQ2W6E-1)=S(IADGET+IQ2W6E)
88990 CONTINUE
C          REPLACE WITH COMPUTED VALUES FOR POINTS WITH HGTW .GT.
C          HGT(K=1).
      DO 89000 IQ2W6E=1,IJOUT
         BITS(MB2+IQ2W6E-1)=HGTW.GT.S(IADH+IQ2W6E)
89000 CONTINUE
      DO 89010 IQ2W6E=1,IJOUT
       IF ( BITS(MB2+IQ2W6E-1) ) THEN
         S(MSOUT2+IQ2W6E-1)=S(JSCR2(1)+IQ2W6E-1)+S(JSCR2(3)+IQ2W6E-1)
       END IF
89010 CONTINUE
C
  320 CONTINUE
C
C          SEND TO PACKER AFTER SMOOTHING
C
      CALL OUTSMOO ( MSOUT2)
C SET UP THE LABEL
      CALL OUTNULAB
C
C  SET UP PDS INFO
C
      CALL LAB2PDS(LABEL84,IDGRBE)
      IDGRBE(7) =   0
      IF(LABEL84(1).EQ.16) IDGRBE(8) =  11
      IF(LABEL84(1).EQ.48) IDGRBE(8) =  33
      IF(LABEL84(1).EQ.49) IDGRBE(8) =  34
      IDGRBE(9) =   103
      IDGRBE(10) =  0
      IARG = LABEL84(6)
      IDGRBE(11) =  LABEL84(5) * 10.**IARG
      IDGRBE(18) =  LABEL84(3)
      IDGRBE(19) =  0
      IDGRBE(20) =  0
C
c     CALL OUTPACK( S(MSOUT2),IJOUT,S(MSOUT1), DESCRIPT(NCD),
c    1 LABEL84,IOUTUNIT)
      CALL GRIBITN ( S(MSOUT2),IJOUT,S(MSOUT1), DESCRIPT(NCD),
     1 IDGRBE,IOUTGRIB,LABEL84)
C
      GO TO ( 120,130,140 ) , IRET
C-------------------------------------------------------------
C
      END
