      SUBROUTINE LONLAT(XLON,LON2,XLAT,COLRAD,LAT2)
      PARAMETER (TPI=2.#E0*#PI,HPI=0.5#E0*#PI)
      DIMENSION XLON(LON2,LAT2),XLAT(LON2,LAT2),COLRAD(LAT2)
C....    GET LON,LAT IN RADIANS
C....  GET LONGITUDINAL INCREMENT
      LON = LON2 / 2
      BPHI = TPI / LON
      DO 5 J=1,LAT2
      DO 5 I=1,LON
        XLON(I,J) = (I-1) * BPHI
        XLAT(I,J) = HPI - COLRAD(J)
        XLON(I+LON,J) =  XLON(I,J)
        XLAT(I+LON,J) = -XLAT(I,J)
  5   CONTINUE
      RETURN
      END
      SUBROUTINE BILWGT(COLIN,LATIN2,LONIN2,COLOUT,LATUT2,LONUT2,
     1                  INSLAT,WGTLAT,ILEFT,IRGHT,WGTLON)
      PARAMETER (HALFPI=0.5#E0*#PI)
      DIMENSION COLIN(LATIN2)
      DIMENSION COLOUT(LATUT2),INSLAT(LATUT2),WGTLAT(LATUT2)
      DIMENSION ILEFT(LONUT2),IRGHT(LONUT2),WGTLON(LONUT2)
C===>    PREPARE THREE SFC FIELDS AS INPUT TO RADIATION CALCULATIONS
C         ALSO PREPARE 3 CONVECTIVE ARRAYS FOR INPUT TO CLD SCHEME..
      JB = 1
      DO 19 LAT=1,LATUT2
CCC     PRINT 100,LAT,XLAT
C===>    IF OUTPUT LAT IS POLEWARD OF INPUT LAT=1 ,THEN EXTRAPOLATE..
        IF (COLOUT(LAT).LE.COLIN(1)) GO TO 16
C----    GET UPPER LEFT POINT ON BASE GRDBOX SURROUNDING THE GAUSIAN
C          POINT   --   NEEDED FOR THE INTERPOLATION
        JST = JB + 1
        DO 11 JAK=JST,LATIN2
          JB = JAK - 1
          IF(COLOUT(LAT).LE.COLIN(JAK)) GO TO 14
  11    CONTINUE
        INSLAT(LAT) = LATIN2
        WGTLAT(LAT) = 0.5#E0 * (COLIN(LATIN2) - COLOUT(LAT)) /
     1                (COLIN(LATIN2) - HALFPI)
        GO TO 19
  14    INSLAT(LAT) = JB
C----   NORMALIZED DISTANCE FROM POLEWARD LAT TO GAUSSIAN LAT
        WGTLAT(LAT) = (COLIN(JB) - COLOUT(LAT)) /
     1                (COLIN(JB) - COLIN(JB+1))
        GO TO 19
  16    INSLAT(LAT) = -1
        WGTLAT(LAT) = (COLOUT(LAT) - COLIN(1)) /
     1                (COLIN(1) - COLIN(2))
  19  CONTINUE
C----    GET LEFT POINT ON BASE GRDBOX
      LONIN = LONIN2 / 2
      LONOUT = LONUT2 / 2
      RATLON = FLOAT(LONIN) / FLOAT(LONOUT)
C     RATLON = (360.#E0 / LONOUT) / (360.#E0 / LONIN)
      DO 21 I=1,LONOUT
        WGTLON(I) = FLOAT(I-1) * RATLON + 1.#E0
        ILEFT(I)  = WGTLON(I)
        IRGHT(I) = ILEFT(I) + 1
        IF (IRGHT(I).GT.LONIN) IRGHT(I) = 1
        WGTLON(I) = WGTLON(I) - ILEFT(I)
        ILEFT(I+LONOUT) = ILEFT(I) + LONIN
        IRGHT(I+LONOUT) = IRGHT(I) + LONIN
        WGTLON(I+LONOUT) = WGTLON(I)
  21  CONTINUE
      RETURN
      END
      SUBROUTINE INSURF(ALBEDO,SLMSK,
     1 ILEFTR,IRGHTR,WGRLON,INRLAT,WGRLAT,ALBEDR,SLMSKR)
      DIMENSION ALBEDO(#LONB2,#LATB2),SLMSK(#LONB2,#LATB2)
      DIMENSION ILEFTR(#LONR2),IRGHTR(#LONR2),WGRLON(#LONR2)
      DIMENSION INRLAT(#LATR2),WGRLAT(#LATR2)
      DIMENSION ALBEDR(#LONR2,#LATR2),SLMSKR(#LONR2,#LATR2)
      DIMENSION      FSLMSK(#LONB2,#LATB2),FICMSK(#LONB2,#LATB2),
     1               WORK2(#LONB2),
     2               RSLMSK(#LONR2,#LATR2),RICMSK(#LONR2,#LATR2)
C....
C....  INTEROLATE ALBEDO TO RADIATION GRID
C....
      CALL GGINTF(ALBEDO,#LONB2,#LATB2,#LATB2,
     1            ALBEDR,#LONR2,#LATR2,#LATR2,1,
     2            ILEFTR,IRGHTR,WGRLON,INRLAT,WGRLAT,WORK2,1,1,1)
C....
C....  CREATE LAND(1)SEA(0) MASK ON MODEL GRID IN FSLMSK
C....  CREATE ICE(1)NO-ICE(0) MASK ON MODEL GRID IN FICMSK
C....
      DO 110 J=1,#LATB2
        DO 110 I=1,#LONB2
          FSLMSK(I,J) = 1.#E0
          FICMSK(I,J) = 0.#E0
  110 CONTINUE
      DO 120 J=1,#LATB2
        DO 120 I=1,#LONB2
          IF(SLMSK(I,J).EQ.0.0#E0.OR.SLMSK(I,J).EQ.2.0#E0)
     1    FSLMSK(I,J) = 0.0#E0
          IF(SLMSK(I,J).EQ.2.0#E0) FICMSK(I,J) = 1.0#E0
  120 CONTINUE
      CALL GGINTF(FSLMSK,#LONB2,#LATB2,#LATB2,
     1            RSLMSK,#LONR2,#LATR2,#LATR2,1,
     2            ILEFTR,IRGHTR,WGRLON,INRLAT,WGRLAT,WORK2,1,1,1)
      CALL GGINTF(FICMSK,#LONB2,#LATB2,#LATB2,
     1            RICMSK,#LONR2,#LATR2,#LATR2,1,
     2            ILEFTR,IRGHTR,WGRLON,INRLAT,WGRLAT,WORK2,1,1,1)
C.....    ADJUST INTERPOLATED TSEAR FOR PROPER LAND/SEA/SEAICE
C             DISTRIBUTION,WHICH HAS BEEN INTERPOLATED ABOVE.....
C.....    ALSO CREATE SEA(0),LAND(1),ICE(2) MASK FOR RAD GRID(SLMSKR)
C....
C....  CREATE ICE(2) LAND(1)SEA(0) MASK ON RADIATION GRID IN SLMSKR
C....
      DO 130 J=1,#LATR2
        DO 130 I=1,#LONR2
          SLMSKR(I,J) = 1
          IF (RSLMSK(I,J).LT.0.5#E0) SLMSKR(I,J) = 0
          IF (RSLMSK(I,J).LT.0.5#E0.AND.RICMSK(I,J).GT.0.5#E0)
     1      SLMSKR(I,J) = 2
  130 CONTINUE
      RETURN
      END
      SUBROUTINE GGINTF(XIN,IIN,JTWIDL,JIN,XOUT,IOUT,JPOUT,JOUT,LEVS,
     1                  ILEFT,IRGHT,WGTLON,INSLAT,WGTLAT,WORK,
     2                  LTWIDL,LATRD1,LATINB)
C----    CODE BILINEARLY INTERPOLATES BETWEEN GAUSSIAN GRIDS---
C          J = 1 IS JUST BELO N.POLE, I = 1 IS GREENWICH (THEN GO EAST).
C===>   IIN,JIN ARE I,J DIMENSIONS OF INPUT GRID
C===>   IOUT,JOUT ARE I,J DIMENSIONS OF OUTPUT GRID
C===>   JIN2,JOUT2=JIN/2,JOUT/2
      DIMENSION XIN(IIN,LEVS,JTWIDL)
      DIMENSION XOUT(IOUT,LEVS,JPOUT)
      DIMENSION WORK(IIN,LEVS)
      DIMENSION ILEFT(IOUT),IRGHT(IOUT),WGTLON(IOUT)
      DIMENSION INSLAT(JOUT),WGTLAT(JOUT)
      DO 95 LATOUT=1,JPOUT
        LAT=LATOUT+LATINB-1
CCC     PRINT 100,LAT,XLAT
C.....   IF OUTPUT LAT IS POLEWARD OF INPUT LAT=1 ,THEN EXTRAPOLATE..
      IF (INSLAT(LAT).LT.0) GO TO 70
      INTH = MOD(LTWIDL + INSLAT(LAT) - LATRD1 - 1,JTWIDL) + 1
      IF (INSLAT(LAT).EQ.JIN) GO TO 20
      INTH1 = MOD(INTH,JTWIDL) + 1
      DO 10 K=1,LEVS
       DO 10 I=1,IIN
        WORK(I,K) = XIN(I,K,INTH1)*WGTLAT(LAT) +
     1                     XIN(I,K,INTH) * (1.#E 0 - WGTLAT(LAT))
   10 CONTINUE
      GO TO 40
   20 IINHF = IIN / 2
      DO 30  K=1,LEVS
      DO 30  I=1,IINHF
        WORK(I,K) = XIN(I+IINHF,K,INTH) * WGTLAT(LAT)+
     1              XIN(I,K,INTH) * (1.#E 0 - WGTLAT(LAT))
        WORK(I+IINHF,K) = XIN(I,K,INTH) * WGTLAT(LAT) +
     1                    XIN(I+IINHF,K,INTH) * (1.#E 0 - WGTLAT(LAT))
   30 CONTINUE
   40 DO 50  K=1,LEVS
      DO 50  I=1,IOUT
        XOUT(I,K,LATOUT) = (1.#E 0 - WGTLON(I)) * WORK(ILEFT(I),K) +
     1                     WGTLON(I) * WORK(IRGHT(I),K)
   50 CONTINUE
      GO TO 95
   70 CONTINUE
C....    POLEWARD EXTRAPOLATION
      INLAT = IABS(INSLAT(LAT))
      DO 80 K=1,LEVS
       DO 80 I=1,IIN
        WORK(I,K) = XIN(I,K,INLAT)+WGTLAT(LAT) *
     1                    (XIN(I,K,INLAT) - XIN(I,K,INLAT+1))
   80 CONTINUE
      DO 90  K=1,LEVS
      DO 90  I=1,IOUT
        XOUT(I,K,LATOUT) = (1.#E 0 - WGTLON(I)) * WORK(ILEFT(I),K) +
     1                     WGTLON(I) * WORK(IRGHT(I),K)
   90 CONTINUE
   95 CONTINUE
CK100 FORMAT(1H ,' ROW =',I5,'  LAT =',E15.5)
      RETURN
      END
      SUBROUTINE CDATE(JD,FJD,MUNTH,IM,ID,IYEAR,IHR,XMIN)
CFPP$ NOCONCUR R
 % INCLUDE DBCDATE  ;
C
C    *******************************************************************
C    *                                                                 *
C    *                            C D A T E                            *
C    *                                                                 *
C    *******************************************************************
C
C         STATEMENTS BLOCKED BY ROBERT K. WHITE.......7 JUNE 1977
C
C..... CDATE COMPUTES MONTH, DAY, AND YEAR FROM JULIAN DAY.
C.....ACCURATE ONLY BETWEEN MARCH 1, 1900 AND FEBRUARY 28, 2100
C.....BASED ON JULIAN CALENDER CORRECTED TO CORRESPOND TO GREGORIAN
C.....CALENDER DURING THIS PERIOD
C
                              D I M E N S I O N
     1   DY(13),             MONTH(12)
C
C
                                   D A T A
     1   DY                  /
     2   0.,                 31.,                59.,
     3   90.,                120.,               151.,
     4   181.,               212.,               243.,
     5   273.,               304.,               334.,
     6   365.                /
C
                                   D A T A
     1   MONTH               /
     2   4HJAN.,             4HFEB.,             4HMAR.,
     3   4HAPR.,             4HMAY ,             4HJUNE,
     4   4HJULY,             4HAUG.,             4HSEP.,
     5   4HOCT.,             4HNOV.,             4HDEC.
     6   /
C
C.....JDOR = JD OF DECEMBER 30, 1899 AT 12 HOURS UT
C
                                   D A T A
     1   JDOR                /         2415019             /,
     2   IYR                 /         1900                /
C
C    *******************************************************************
C
      IYEAR=IYR
      NDAY=JD-JDOR
      IF(FJD.GE..5#E0) NDAY=NDAY+1
 61   IF(NDAY.LT.1462) GO TO 62
      NDAY=NDAY-1461
      IYEAR=IYEAR+4
      GO TO 61
 62   NDIY=365
      IF(MOD(IYEAR,4).EQ.0) NDIY=366
      IF(NDAY.LE.NDIY) GO TO 65
      IYEAR=IYEAR+1
      NDAY=NDAY-NDIY
      GO TO 62
 65   IF(NDAY.GT.INT(DY(2))) GO TO 66
      IM=1
      ID=NDAY
      GO TO 67
 66   IF(NDAY.NE.60) GO TO 68
      IF(NDIY.EQ.365) GO TO 68
      IM=2
      ID=29
      GO TO 67
 68   IF(NDAY.GT.(INT(DY(3))+NDIY-365)) GO TO 69
      IM=2
      ID=NDAY-31
      GO TO 67
 69   DO 70 I=3,12
      IF(NDAY.GT.(INT(DY(I+1))+NDIY-365)) GO TO 70
      IM=I
      ID=NDAY-INT(DY(I))-NDIY+365
      GO TO 67
 70   CONTINUE
 67   MUNTH=MONTH(IM)
      HR=24.#E0*FJD
      IHR=HR
      XMIN=60.#E0*(HR-FLOAT(IHR))
      IHR=IHR+12
      IF(IHR.GE.24) IHR=IHR-24
      RETURN
      END
      SUBROUTINE COMPJD(JYR,JMNTH,JDAY,JHR,JMN,JD,FJD)
CFPP$ NOCONCUR R
 % INCLUDE DBCOMPJD  ;
C    *******************************************************************
C    *                           C O M P J D                           *
C    *    STATEMENT BLOCKED BY RAY ORZOL                               *
C    *******************************************************************
C
                               D I M E N S I O N
     1   NDM(12)
C
                                   D A T A
     1   JDOR/2415019/,
     2   JYR19/1900/
C
                                   D A T A
     1   NDM/0,31,59,90,120,151,181,212,243,273,304,334/
C    *******************************************************************
C     COMPUTES JULIAN DAY AND FRACTION FROM YEAR, MONTH, DAY AND TIME UT
C     ACCURATE ONLY BETWEEN MARCH 1, 1900 AND FEBRUARY 28, 2100
C     BASED ON JULIAN CALENDAR CORRECTED TO CORRESPOND TO GREGORIAN
C        CALENDAR DURING THIS PERIOD
C    JDOR=JD OF DECEMBER 30, 1899 AT 12 HOURS UT
C    *******************************************************************
      JD=JDOR
      JYRM9=JYR-JYR19
      LP=JYRM9/4
      IF(LP.LE.0) GO TO 4
      JD=JD+1461*LP
  4   NY=JYRM9-4*LP
      IC=0
      IF(NY.GT.0) GO TO 5
      IF(JMNTH.GT.2) IC=1
      GO TO 6
  5   JD=JD+365*NY+1
  6   JD=JD+NDM(JMNTH)+JDAY+IC
      IF(JHR.GE.12) GO TO 7
      JD=JD-1
      FJD=.5#E0+.041666667#E0*FLOAT(JHR)+.00069444444#E0*FLOAT(JMN)
      RETURN
  7   FJD=.041666667#E0*FLOAT(JHR-12)+.00069444444#E0*FLOAT(JMN)
      RETURN
      END
      SUBROUTINE FCSTIM(FHOUR,IMON,IDAY,IZTIM,JDNMC,FJDNMC,RLAG,YEAR,
     1                  RSIN1,RCOS1,RCOS2,JD,FJD)
      PARAMETER (TPI=2.#E0*#PI)
      DIMENSION JMON(12)
      DATA JMON/31,28,31,30,31,30,31,31,30,31,30,31/
      DATA TWO/2.#E0/
      SAVE JMON,TWO
C....    FIRST GET NUMBER OF DAYS SINCE BEGINNING OF YEAR (NO LEAP YRS)
      NNDAY =0
      IMO = IMON - 1
      IF (IMO.GT.0) THEN
        DO 150 I=1,IMO
          NNDAY = NNDAY + JMON(I)
  150   CONTINUE
      ENDIF
      NNDAY = NNDAY + IDAY
      PRINT 1002,NNDAY
 1002 FORMAT(1H ,'*************** NNDAY OF YEAR = ',I4,'******')
C....    GET NUMBER OF DAYS INTO FCST (DYFCST)
C....   FOLLOWING TWO CARDS CHANGED ON 10 APR 86 TO FIX SLIGHT ERROR
C         IN SOLAR DECLINATION CALC IF INITIAL HR NOT 00Z OR 12Z.....
      DAYINI = NNDAY + FLOAT(IZTIM)/24.#E0
      SOLTIM = FHOUR + IZTIM
C...     RESET TO 24 HOUR CLOCK
      FDAY = SOLTIM / 24.#E0
C>YH  SOLTIM = SOLTIM - INT(FDAY) * 24.#E0
      DYFCST = NNDAY + FDAY
      PRINT 1003,JDNMC,FJDNMC,FHOUR,DAYINI,DYFCST
 1003 FORMAT(1H0,'FROM HEATL3 JDNMC ETC',I9,2X,4(2X,F6.2))
      RANG=TPI*(DYFCST-RLAG)/YEAR
      RSIN1=SIN(RANG)
      RCOS1=COS(RANG)
      RCOS2=COS(TWO*RANG)
C....    UPDATE THE JULIAN DATE (INITIAL IN JDNMC,FJDNMC)
      DYINC = DYFCST - DAYINI
      IDYIN = DYINC
      FDYIN = DYINC - IDYIN
      JD = JDNMC + IDYIN
      FJD = FJDNMC + FDYIN
C.......NEED TO RESET IF FRACTION (FJD) GT 1.
      IFJD = FJD
      IF (IFJD.GT.0) THEN
        JD = JD + IFJD
        FJD = FJD - IFJD
      ENDIF
      RETURN
      END
      SUBROUTINE SOLMRF(JD,FJD,R,DLT,ALP,SLAG,N,ALAT,HANG,TAUDA,COSZ)
CFPP$ NOCONCUR R
 % INCLUDE DBSOLMRF  ;
      PARAMETER (PI=#PI,TPI=2.0*PI,HPI=0.5*PI,RAD=180.0/PI)
C
C
C    *******************************************************************
C    *                            S O L M R F                          *
C... *  ORIGINAL GFDL CODE (EXCEPT FOR PASSING ALAT IN CALL LIST)--    *
C    *    I.E. COMPUTES GAUSSIAN LATITUDE MEAN COSINE SOLAR ZEN ANGLE  *
C    *  UPDATES BY HUALU PAN TO LIMIT ITERATIONS IN NEWTON METHOD AND  *
C    *  ALSO CCR REDUCED FROM(1.3E-7)--BOTH TO AVOID NONCONVERGENCE IN *
C    *  NMC S HALF PRECISION VERSION OF GFDL S CODE   ----  FALL 1988  *
C    *******************************************************************
C
C         STATEMENTS BLOCKED BY ROBERT K. WHITE.......21 JULY 1977
C
C
C.....SOLMRF COMPUTES RADIUS VECTOR, DECLINATION AND RIGHT ASCENSION OF
C.....SUN, EQUATION OF TIME, AND HOUR ANGLE OF SUN AT SUNSET FOR N
C.....EQUALLY SPACED LATITUDES GIVEN JULIAN DAY AND FRACTION.
C
                              D I M E N S I O N
     1   ALAT(N),  HANG(N),    COSZ(N),    TAUDA(N)
C
                                   D A T A
     1   CYEAR/365.25/,      CCR/1.3#E-6/
C
C.....TPP = DAYS BETWEEN EPOCH AND PERIHELION PASSAGE OF 1900
C.....SVT6 = DAYS BETWEEN PERIHELION PASSAGE AND MARCH EQUINOX OF 1900
C.....JDOR = JD OF EPOCH WHICH IS JANUARY 0, 1900 AT 12 HOURS UT
C
                                   D A T A
     1   TPP/1.55/,          SVT6/78.035/,       JDOR/2415020/
C
C    *******************************************************************
C
      DAT=FLOAT(JD-JDOR)-TPP+FJD
C    COMPUTES TIME IN JULIAN CENTURIES AFTER EPOCH
      T=FLOAT(JD-JDOR)/36525.#E0
C    COMPUTES LENGTH OF ANOMALISTIC AND TROPICAL YEARS (MINUS 365 DAYS)
      YEAR=.25964134#E0+.304#E-5*T
      TYEAR=.24219879#E0-.614#E-5*T
C    COMPUTES ORBIT ECCENTRICITY AND ANGLE OF EARTH'S INCLINATION FROM T
      EC=.01675104#E0-(.418#E-4+.126#E-6*T)*T
      ANGIN=23.452294#E0-(.0130125#E0+.164#E-5*T)*T
      ADOR=JDOR
      JDOE=ADOR+(SVT6*CYEAR)/(YEAR-TYEAR)
C    DELEQN=UPDATED SVT6 FOR CURRENT DATE
      DELEQN=FLOAT(JDOE-JD)*(YEAR-TYEAR)/CYEAR
      YEAR=YEAR+365.#E0
      SNI=SIN(ANGIN/RAD)
      TINI=1.#E0/TAN(ANGIN/RAD)
      ER=SQRT((1.#E0+EC)/(1.#E0-EC))
      QQ=DELEQN*TPI/YEAR
C    DETERMINE TRUE ANOMALY AT EQUINOX
      E=1.#E0
      ITER = 0
 32   EP=E-(E-EC*SIN(E)-QQ)/(1.#E0-EC*COS(E))
      CD=ABS(E-EP)
      E=EP
      ITER = ITER + 1
      IF(ITER.GT.10) THEN
        WRITE(6,*) ' ITERATION COUNT FOR LOOP 32 =', ITER
        WRITE(6,*) ' E, EP, CD =', E, EP, CD
      ENDIF
      IF(ITER.GT.10) GOTO 1032
      IF(CD.GT.CCR) GO TO 32
 1032 CONTINUE
      HE=.5#E0*E
      EQ=2.#E0*ATAN(ER*TAN(HE))
C    DATE=DAYS SINCE LAST PERIHELION PASSAGE
      DATE = MOD(DAT,YEAR)
C    SOLVE ORBIT EQUATIONS BY NEWTON'S METHOD
      EM=TPI*DATE/YEAR
      E=1.#E0
      ITER = 0
 31   EP=E-(E-EC*SIN(E)-EM)/(1.#E0-EC*COS(E))
      CR=ABS(E-EP)
      E=EP
      ITER = ITER + 1
      IF(ITER.GT.10) THEN
        WRITE(6,*) ' ITERATION COUNT FOR LOOP 31 =', ITER
      ENDIF
      IF(ITER.GT.10) GOTO 1031
      IF(CR.GT.CCR) GO TO 31
 1031 CONTINUE
      R=1.#E0-EC*COS(E)
      HE=.5#E0*E
      W=2.#E0*ATAN(ER*TAN(HE))
      SIND=SNI*SIN(W-EQ)
      DLT=ASIN(SIND)
      ALP=ASIN(TAN(DLT)*TINI)
      TST=COS(W-EQ)
      IF(TST.LT.0.#E0) ALP=PI-ALP
      IF(ALP.LT.0.#E0) ALP=ALP+TPI
      SUN=TPI*(DATE-DELEQN)/YEAR
      IF(SUN.LT.0.#E0) SUN=SUN+TPI
      SLAG=SUN-ALP-.03255#E0
C    COMPUTE HOUR ANGLE OF SUNSET AT ALL LATITUDES
      IF(DLT.EQ.0.#E0) THEN
        DO 10 I=1,N
        HANG(I)=HPI
        TAUDA(I)=0.5#E0
        COSZ(I)= MAX (COS(ALAT(I)/HPI),0.#E0)
   10   CONTINUE
      ELSE
      DO 1 I=1,N
      SS=SIN(ALAT(I))*SIN(DLT)
      CC=COS(ALAT(I))*COS(DLT)
      AP=ABS(ALAT(I))
      EPS=ABS(AP-HPI)
      IF(EPS.GT.CCR) GO TO 14
      HANG(I)=HPI*ABS(AP/ALAT(I)+ABS(DLT)/DLT)
      GO TO 5
   14 AR=-SS/CC
      AC=ABS(AR)
      IF(AC+CCR.GT.1.#E0) GO TO 3
      IF(AC+CCR.LT.1.#E0) GO TO 4
  2   HANG(I)=(AC-AR)*HPI
      GO TO 5
  3   IF(AR.LT.0.#E0) GO TO 25
      HANG(I)=0.
      GO TO 5
 25   HANG(I)=PI
      GO TO 5
  4   HANG(I)=ACOS(AR)
  5   TAUDA(I)= MAX (HANG(I)/PI,0.#E0)
      IF(HANG(I).EQ.0.#E0) GO TO 100
      COSZ(I)= MAX ((SS+CC*SIN(HANG(I))/HANG(I)),0.#E0)
      GO TO 1
  100 COSZ(I)=0.#E0
    1 CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE SOLAR(JD,FJD,R,DLT,ALP,SLAG,SDEC,CDEC)
C>YH  SUBROUTINE SOLAR(JD,FJD,R,DLT,ALP,SLAG)
CFPP$ NOCONCUR R
 % INCLUDE DBSOLAR  ;
      PARAMETER (PI=#PI,TPI=2.0*PI,HPI=0.5*PI,RAD=180.0/PI)
C
C
C    *******************************************************************
C    *                            S O L A R                            *
C... *  PATTERNED AFTER ORIGINAL GFDL CODE---                          *
C... *     BUT NO CALCULATION OF LATITUDE MEAN COS SOLAR ZENITH ANGLE..*
C... *     ZENITH ANGLE CALCULATIONS DONE IN SUBR ZENITH IN THIS CASE..*
C... *  HR ANGLE,MEAN COSZ,AND MEAN TAUDA CALC REMOVED--K.A.C. MAR 89  *
C    *  UPDATES BY HUALU PAN TO LIMIT ITERATIONS IN NEWTON METHOD AND  *
C    *  ALSO CCR REDUCED FROM(1.3E-7)--BOTH TO AVOID NONCONVERGENCE IN *
C    *  NMC S HALF PRECISION VERSION OF GFDL S CODE   ----  FALL 1988  *
C    *******************************************************************
C
C.....SOLAR COMPUTES RADIUS VECTOR, DECLINATION AND RIGHT ASCENSION OF
C.....SUN, EQUATION OF TIME
C
                                   D A T A
     1   CYEAR/365.25/,      CCR/1.3#E-6/
C
C.....TPP = DAYS BETWEEN EPOCH AND PERIHELION PASSAGE OF 1900
C.....SVT6 = DAYS BETWEEN PERIHELION PASSAGE AND MARCH EQUINOX OF 1900
C.....JDOR = JD OF EPOCH WHICH IS JANUARY 0, 1900 AT 12 HOURS UT
C
                                   D A T A
     1   TPP/1.55/,          SVT6/78.035/,       JDOR/2415020/
C
C    *******************************************************************
C
      DAT=FLOAT(JD-JDOR)-TPP+FJD
C    COMPUTES TIME IN JULIAN CENTURIES AFTER EPOCH
      T=FLOAT(JD-JDOR)/36525.#E0
C    COMPUTES LENGTH OF ANOMALISTIC AND TROPICAL YEARS (MINUS 365 DAYS)
      YEAR=.25964134#E0+.304#E-5*T
      TYEAR=.24219879#E0-.614#E-5*T
C    COMPUTES ORBIT ECCENTRICITY AND ANGLE OF EARTH'S INCLINATION FROM T
      EC=.01675104#E0-(.418#E-4+.126#E-6*T)*T
      ANGIN=23.452294#E0-(.0130125#E0+.164#E-5*T)*T
      ADOR=JDOR
      JDOE=ADOR+(SVT6*CYEAR)/(YEAR-TYEAR)
C    DELEQN=UPDATED SVT6 FOR CURRENT DATE
      DELEQN=FLOAT(JDOE-JD)*(YEAR-TYEAR)/CYEAR
      YEAR=YEAR+365.#E0
      SNI=SIN(ANGIN/RAD)
      TINI=1.#E0/TAN(ANGIN/RAD)
      ER=SQRT((1.#E0+EC)/(1.#E0-EC))
      QQ=DELEQN*TPI/YEAR
C    DETERMINE TRUE ANOMALY AT EQUINOX
      E=1.#E0
      ITER = 0
 32   EP=E-(E-EC*SIN(E)-QQ)/(1.#E0-EC*COS(E))
      CD=ABS(E-EP)
      E=EP
      ITER = ITER + 1
      IF(ITER.GT.10) THEN
        WRITE(6,*) ' ITERATION COUNT FOR LOOP 32 =', ITER
        WRITE(6,*) ' E, EP, CD =', E, EP, CD
      ENDIF
      IF(ITER.GT.10) GOTO 1032
      IF(CD.GT.CCR) GO TO 32
 1032 CONTINUE
      HE=.5#E0*E
      EQ=2.#E0*ATAN(ER*TAN(HE))
C    DATE=DAYS SINCE LAST PERIHELION PASSAGE
      DATE = MOD(DAT,YEAR)
C    SOLVE ORBIT EQUATIONS BY NEWTON'S METHOD
      EM=TPI*DATE/YEAR
      E=1.#E0
      ITER = 0
 31   EP=E-(E-EC*SIN(E)-EM)/(1.#E0-EC*COS(E))
      CR=ABS(E-EP)
      E=EP
      ITER = ITER + 1
      IF(ITER.GT.10) THEN
        WRITE(6,*) ' ITERATION COUNT FOR LOOP 31 =', ITER
      ENDIF
      IF(ITER.GT.10) GOTO 1031
      IF(CR.GT.CCR) GO TO 31
 1031 CONTINUE
      R=1.#E0-EC*COS(E)
      HE=.5#E0*E
      W=2.#E0*ATAN(ER*TAN(HE))
C>YH  SIND=SNI*SIN(W-EQ)
C>YH  DLT=ASIN(SIND)
      SDEC=SNI*SIN(W-EQ)
      CDEC=SQRT(1.#E0 - SDEC*SDEC)
      DLT=ASIN(SDEC)
      ALP=ASIN(TAN(DLT)*TINI)
      TST=COS(W-EQ)
      IF(TST.LT.0.#E0) ALP=PI-ALP
      IF(ALP.LT.0.#E0) ALP=ALP+TPI
      SUN=TPI*(DATE-DELEQN)/YEAR
      IF(SUN.LT.0.#E0) SUN=SUN+TPI
      SLAG=SUN-ALP-.03255#E0
      RETURN
      END
      SUBROUTINE PRTIME(ID,MUNTH,IYEAR,IHR,XMIN,JD,FJD,
     1                  DLT,ALF,R1,SLAG,SOLC)
      PARAMETER (DEGRAD=180.#E0/#PI,HPI=0.5#E0*#PI)
      DATA       SIGN/1H-/,      SIGB/1H /
      DATA ZERO,SIX,SIXTY,Q22855/0.0,6.0,60.0,228.55735/
      SAVE SIGN,ZERO,SIX,SIXTY,Q22855
      DLTD=DEGRAD*DLT
      LTD=DLTD
      DLTM=SIXTY*(ABS(DLTD)-ABS(FLOAT(LTD)))
      LTM=DLTM
      DLTS=SIXTY*(DLTM-FLOAT(LTM))
      DSIG=SIGB
      IF((DLTD.LT.ZERO).AND.(LTD.EQ.0)) DSIG=SIGN
      HALP=SIX*ALF/HPI
      IHALP=HALP
      YMIN=ABS(HALP-FLOAT(IHALP))*SIXTY
      IYY=YMIN
      ASEC=(YMIN-FLOAT(IYY))*SIXTY
      EQT=Q22855*SLAG
      EQSEC=SIXTY*EQT
      PRINT 1004,    ID,MUNTH,IYEAR,IHR,XMIN,JD,FJD,R1,HALP,IHALP,
     1       IYY,ASEC,DLTD,DSIG,LTD,LTM,DLTS,EQT,EQSEC,SLAG,SOLC
 1004 FORMAT('0 FORECAST DATE',9X,I3,A5,I6,' AT',I3,' HRS',F6.2,' MINS'/
     1       '  JULIAN DAY',12X,I8,2X,'PLUS',F11.6/
     2       '  RADIUS VECTOR',9X,F10.7/
     3       '  RIGHT ASCENSION OF SUN',F12.7,' HRS, OR',I4,' HRS',I4,
     4                                 ' MINS',F6.1,' SECS'/
     5       '  DECLINATION OF THE SUN',F12.7,' DEGS, OR',A2,I3,
     6                                 ' DEGS',I4,' MINS',F6.1,' SECS'/
     7       '  EQUATION OF TIME',6X,F12.7,' MINS, OR',F10.2,' SECS, OR'
     8                           ,F9.6,' RADIANS'/
     9       '  SOLAR CONSTANT',8X,F12.7//)
      RETURN
      END
      SUBROUTINE ZENITH(FJD,DLT,SLAG,RLAT,RLON,HANG,DHR,NLNG,COSZ,FRAC)
CFPP$ NOCONCUR R
 % INCLUDE DBZENITH  ;
      PARAMETER (PI=#PI,TPI=2.0*PI,PID24=PI/24.0,HPI=0.5*PI)
C
C    *******************************************************************
C    *                           Z E N I T H                           *
C    *    STATEMENTS BLOCKED BY ROBERT K. WHITE.......19 OCT. 1977     *
C    *    INPUT LAT/LON DEG(XLAT,XLON),COMPUTE SUNSET HR ANGL KAC MAR89*
C    *******************************************************************
C
                               D I M E N S I O N
     1   COSZ(NLNG),           FRAC(NLNG)
      DIMENSION RLAT(NLNG),RLON(NLNG),HANG(NLNG)
C
                                 L O G I C A L
     1   RISE,               SET
C
                                 D A T A
     1   CCR/1.3#E-6/
C
C    *******************************************************************
C
C     ZENITH COMPUTES EFFECTIVE MEAN COSINE OF ZENITH ANGLE AND DAYLIGHT
C       FRACTION FROM LATITUDE AND COMPUTED HOUR ANGLE OF SUNSET(THE
C       LATTER IS OBTAINED FROM SUBROUTINE SOLAR)..
C---   INPUT ARGUMENTS TO CIRCULAR FUNCTIONS ARE IN RADIANS.
C
      CVPR=TPI/FLOAT(NLNG/2)
      GHA=FJD*TPI+SLAG
      ARG=DHR*PID24
      SINFAC=SIN(ARG)/ARG
      IF(DLT.EQ.0.#E0) THEN
      DO 60 I=1,NLNG
      CC=COS(RLAT(I))
      HANG(I) = HPI
      CONS=CC/HPI
CKAC  XLNG = CVPR * (FLOAT(I) - 1.#E0)
      HLOC=GHA+RLON(I)+ARG
C     LOCAL HOUR ANGLE SHIFTED BY HALF OF THE AVERAGING PERIOD
      HLOC = MOD(HLOC,TPI)
      IF(HLOC.GT.PI) HLOC=HLOC-TPI
      HLPAR=HLOC+ARG
      ARMHL=ARG-HLOC
      SET=HLPAR.GT.HPI
      RISE=ARMHL.GT.HPI
      IF(RISE.AND.SET) GO TO 57
      IF(HLPAR.GT.PI) GO TO 58
      IF(ARMHL.GT.PI) GO TO 59
      IF(SET) GO TO 53
      IF(RISE) GO TO 54
      FRAC(I)=1.#E0
      COSZ(I)=CC*COS(HLOC)*SINFAC
      GO TO 52
 53   DELSH=.5#E0*(HPI+ARMHL)
      GO TO 55
 54   DELSH=.5#E0*(HPI+HLPAR)
 55   IF(DELSH.LE.0.#E0) GO TO 56
      FRAC(I)=DELSH/ARG
      COSZ(I)=CC*COS(HPI-DELSH)*SIN(DELSH)/DELSH
      GO TO 52
 57   FRAC(I)=HPI/ARG
      COSZ(I)=CONS
      GO TO 52
 58   DELE=.5#E0 * MAX (HLPAR+HPI-TPI,0.#E0)
      DELW=.5#E0 * MAX (HPI+ARMHL,0.#E0)
      GO TO 70
 59   DELE=.5#E0 * MAX (HPI+HLPAR,0.#E0)
      DELW=.5#E0 * MAX (ARMHL+HPI-TPI,0.#E0)
 70   FRAC(I)=(DELE+DELW)/ARG
      IF(FRAC(I).EQ.0.#E0) GO TO 71
      COSZ(I)=CC*(COS(HPI-DELE)*SIN(DELE)+
     1            COS(HPI-DELW)*SIN(DELW))/(DELE+DELW)
      GO TO 52
 56   FRAC(I)=0.#E0
 71   COSZ(I)=0.#E0
 52   CONTINUE
      COSZ(I) =  MIN (1.#E0,COSZ(I))
      COSZ(I) =  MAX (0.#E0,COSZ(I))
      FRAC(I) =  MIN (1.#E0,FRAC(I))
 60   CONTINUE
      ELSE
      DO 20 I=1,NLNG
C...   COMPUTE HOUR ANGLE OF SUNSET FOR EACH POINT
      SS=SIN(RLAT(I))*SIN(DLT)
      CC=COS(RLAT(I))*COS(DLT)
      IF(DLT.EQ.0.#E0) GO TO 16
      AP=ABS(RLAT(I))
      EPS=ABS(AP-HPI)
      IF(EPS.GT.CCR) GO TO 14
      HANG(I)=HPI*ABS(AP/RLAT(I)+ABS(DLT)/DLT)
      GO TO 35
   14 AR=-SS/CC
      AC=ABS(AR)
      IF(AC+CCR.GT.1.#E0) GO TO 33
      IF(AC+CCR.LT.1.#E0) GO TO 34
   32 HANG(I)=(AC-AR)*HPI
      GO TO 35
   33 IF(AR.LT.0.#E0) GO TO 25
      HANG(I)=0.
      GO TO 35
 25   HANG(I)=PI
      GO TO 35
 16   HANG(I)=HPI
      GO TO 35
   34 HANG(I)=ACOS(AR)
   35 HA=HANG(I)
      IF(HA.GT.0.#E0) CONS=SS+CC*SIN(HA)/HA
CKAC  XLNG = CVPR * (FLOAT(I) - 1.#E0)
      HLOC=GHA+RLON(I)+ARG
C     LOCAL HOUR ANGLE SHIFTED BY HALF OF THE AVERAGING PERIOD
      HLOC = MOD(HLOC,TPI)
      IF(HLOC.GT.PI) HLOC=HLOC-TPI
      HLPAR=HLOC+ARG
      ARMHL=ARG-HLOC
      SET=HLPAR.GT.HA
      RISE=ARMHL.GT.HA
      IF(RISE.AND.SET) GO TO 7
      IF(HLPAR.GT.PI) GO TO 8
      IF(ARMHL.GT.PI) GO TO 9
      IF(SET) GO TO 3
      IF(RISE) GO TO 4
      FRAC(I)=1.#E0
      COSZ(I)=SS+CC*COS(HLOC)*SINFAC
      GO TO 2
  3   DELSH=.5#E0*(HA+ARMHL)
      GO TO 5
  4   DELSH=.5#E0*(HA+HLPAR)
  5   IF(DELSH.LE.0.#E0) GO TO 6
      FRAC(I)=DELSH/ARG
      COSZ(I)=SS+CC*COS(HA-DELSH)*SIN(DELSH)/DELSH
      GO TO 2
  7   IF(HA.LE.0.#E0) GO TO 6
      FRAC(I)=HA/ARG
      COSZ(I)=CONS
      GO TO 2
  8   DELE=.5#E0 * MAX (HLPAR+HA-TPI,0.#E0)
      DELW=.5#E0 * MAX (HA+ARMHL,0.#E0)
      GO TO 10
  9   DELE=.5#E0 * MAX (HA+HLPAR,0.#E0)
      DELW=.5#E0 * MAX (ARMHL+HA-TPI,0.#E0)
 10   FRAC(I)=(DELE+DELW)/ARG
      IF(FRAC(I).EQ.0.#E0) GO TO 11
      COSZ(I)=SS+CC*(COS(HA-DELE)*SIN(DELE)+
     1               COS(HA-DELW)*SIN(DELW))/(DELE+DELW)
      GO TO 2
  6   FRAC(I)=0.#E0
 11   COSZ(I)=0.#E0
  2   CONTINUE
      COSZ(I) =  MIN (1.#E0,COSZ(I))
      COSZ(I) =  MAX (0.#E0,COSZ(I))
      FRAC(I) =  MIN (1.#E0,FRAC(I))
   20 CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE ALBSNO(IDIM2,LAT,JSNO,
     1           ALBDOA,RLAT,ALBEDR,SLMSKR,SSNOW,TGR,TAR)
CFPP$ NOCONCUR R
      DIMENSION ALBDOA(IDIM2),ALBEDR(IDIM2),SLMSKR(IDIM2)
      DIMENSION SSNOW(IDIM2),RLAT(IDIM2)
C     ADDED BY BOB GRUMBINE FOR SEA ICE ALBEDO ALGORITHM
      REAL TGR(IDIM2), TAR(IDIM2)
C MODIFIED BY HMH JUANG FOR SIMPLICITY  AND FOR REGIONAL MODEL USE
      PARAMETER(SNODEG=70.* #PI /180.)
C....
C   THE FOLLOWING DETERMINES SURFACE ALBEDO (ALBDOA),WHERE SNOW EXISTS.
C....
        SNOCHK=#PI
        IF(JSNO.EQ.0) SNOCHK=SNODEG  ! JSNO=0 FOR RSM
C
        DO 350 I=1, IDIM2
C....    LIMIT BACKGROUND ALBEDO (IN CASE SNOW LEAVES GREENLAND)
          ALBDOA(I)=MIN(ALBEDR(I),0.6 E 0)
CKAC.....            IF(TSEAR(I).LE.0. E 0) GO TO 34
          IF(SLMSKR(I).EQ.1.0 E 0) THEN
C... CHECK LAT<JSNO FOR GLOBAL AND ABS(RLAT)>SNODEG FOR REGIONAL
            IF(LAT.LT.JSNO .OR. ABS(RLAT(I)).GT.SNOCHK) THEN
              IF(SSNOW(I).GT.0. E 0) ALBDOA(I)=0.75 E 0
            ELSE
              IF(SSNOW(I).GE.1. E 0) THEN
                ALBDOA(I)=0.6 E 0
              ELSE IF(SSNOW(I).GT.0.0 E 0) THEN
                ALBDOA(I)=ALBDOA(I)+SQRT(SSNOW(I))*(0.6 E 0-ALBDOA(I))
              ENDIF
            ENDIF
CKAC.......34   IF (TSEAR(I).LE.-271.21 E 0) GO TO 35
          ELSE IF(SLMSKR(I).EQ.2.0 E 0) THEN
CKAC            ALBDOA(I)=0.5 E 0
CKAC            IF(SSNOW(I).GT.0. E 0) ALBDOA(I)=0.75 E 0
            IF (SSNOW(I) .GT. 0.0) THEN
              IF (TGR(I) .LT. 273.16 - 5.) THEN
                ALBDOA(I) = 0.8
              ELSE IF (TGR(I) .LE. 273.16) THEN
                ALBDOA(I) = 0.65 + 0.03*(273.16 - TGR(I))
              ELSE
                ALBDOA(I) = 0.65
              ENDIF
             ELSE
              IF (TGR(I) .LT. 271.2 .OR. TAR(I) .LT. 273.16) THEN
                ALBDOA(I) = 0.65
              ELSE IF (TAR(I) .LT. 273.16+5.) THEN
                ALBDOA(I) = 0.65 - 0.04*(TAR(I) -273.16)
              ELSE
                ALBDOA(I) = 0.45
              ENDIF
            ENDIF
          ENDIF
          ALBDOA(I) = MAX(ALBDOA(I),.06 E 0)
350     CONTINUE
      RETURN
      END
      SUBROUTINE ZONGRD(A,ZONA,ZONB)
CFPP$ NOCONCUR R
      DIMENSION A(#LONR2,#LEVS),ZONA(#LEVS),ZONB(#LEVS)
      DO 3 K=1,#LEVS
      ZONA(K)=0.#E0
      ZONB(K)=0.#E0
      DO 2 I=1,#LONR
      ZONA(K)=ZONA(K)+A(I,K)
      ZONB(K)=ZONB(K)+A(I+#LONR,K)
2     CONTINUE
      ZONA(K)=ZONA(K)/#LONR
      ZONB(K)=ZONB(K)/#LONR
3     CONTINUE
C     PRINT 100,J,ZON
C100  FORMAT(1H ,I3,#LEVS(1X,F5.2))
      RETURN
      END
      SUBROUTINE EXTRM1(A,LGTH,IND)
      %INCLUDE DBEXTREM ;
      DIMENSION A(LGTH)
      AMIN = A(1)
      AMAX = A(1)
      DO 25 I=2,LGTH
      IF (A(I).GT.AMAX)  AMAX = A(I)
      IF (A(I).LT.AMIN)  AMIN = A(I)
25    CONTINUE
C
      PRINT 100,IND,AMIN,AMAX
100   FORMAT(1H ,'IND AMIN AMAX ',I4,2X,2(E12.4,2X))
      RETURN
      END
      SUBROUTINE EXTRM2(NGG,NGGS,A,AMIN,AMAX,B,BMIN,BMAX,LGTH,IND)
      %INCLUDE DBEXTREM ;
      DIMENSION A(LGTH), B(LGTH)
      DO 25 I=1,LGTH
      IF (A(I).GT.AMAX)  AMAX = A(I)
      IF (A(I).LT.AMIN)  AMIN = A(I)
25    CONTINUE
C
      DO 50 I=1,LGTH
      IF (B(I).GT.BMAX)  BMAX = B(I)
      IF (B(I).LT.BMIN)  BMIN = B(I)
50    CONTINUE
      IF(NGG.EQ.NGGS) PRINT 100,IND,AMIN,AMAX,BMIN,BMAX
100   FORMAT(1H ,'IND AMIN AMAX BMIN BMAX ',I4,2X,4(E12.4,2X))
      RETURN
      END
CFPP$ EXPAND(FPVS)
      SUBROUTINE CLDJMS(IDIMT,IDIMS,KDIM,NBIN,MCLD,
     1           PS,Q,T,VVEL,CV,CVT,CVB,SI,SL,
     1           SLMSK,CLD,MTOP,MBOT,CLDARY,IVVA,INVR,RHMAX,
     2           XLATRD,RHCLD,ISTRAT)
CTUNE
CFPP$ NOCONCUR R
C....    FROM YH.RAD.MDL93(CLDNEW28).......
C....     LATER UPDATED FROM YH.RAD.MDL94(CLDMUL28)...22JAN94
C....     LATER UPDATED FROM YH.RAD.MDL94(CLDML28A)... 1FEB94
C....     LATER UPDATED FROM YH.RAD.MDL94(CLDML28B)... 5FEB94
C.               SUBR CLDPRP REPLACED
C.               ADDED VERTICAL INTERP OF CLD-RH RELATIONS(ISTRAT GT 1)
C....     LATER UPDATED FROM YH.RAD.MDL94(CLDML28E)... 11MAR94
C.               SUBR CLDPRP REPLACED,GCL ADJUSTED
C....     LATER UPDATED FROM CLOUD6................... 24MAR94
C.               SUBR CLDPRP , LOW ENHANCED TO OLD VALUE..0.14..
C.               SUBR GCLNEW , LLYR CALCULATION ADJ TO OLD VALU(KL-1)
C.                             LLYRL WAS OK.. IVE REMOVED IT AND
C.                             REPLACED IT BY ITS EQUIVALENT, KLOWB
C....     LATER UPDATED FROM CLOUD6................... 30MAR94
C.               SUBR CLDPRP , LOW AND MIDDLE (NOT CV) ENHANCED=0.10
C---------------------------------------------------------------------
C     NOV., 1992 - Y.H., K.A.C., AND A.K.
C        CLOUD PARAMETERIZATION PATTERNED AFTER SLINGO AND SLINGO'S
C        WORK (JGR, 1991).
C     STRATIFORM CLOUDS ARE ALLOWED IN ANY LAYER EXCEPT THE SURFACE
C        AND UPPER STRATOSPHERE.  THE RELATIVE HUMIDITY CRITERION MAY
C        VARY IN DIFFERENT MODEL LAYERS.
CYH94
C     OUTPUT CLOUD AMOUNTS ARE IN CLDARY(I,K), K=1 IS THE LOWEST
C        MODEL LAYER, STRATIFORM (STR) AND CONVECTIVE (CNV) TYPES OF
C        CLOUD ARE COMPRESSED INTO ONE WORD: CAMT = STR + 1.0E4*CNV
C        LOW MARINE STRATUS AMT'S ARE FLAGED BY ADDING 2.
CYH94
CTUNE
C..   FOR ISTRAT = 0, THERE IS RH-CLD RELATION FOR EACH LAYER..
C                      CRIT RH COMPUTED WITHIN..
C..   FOR ISTRAT = 1, RH-CLD RELATION FROM TABLES CREATED USING
C                     MITCHELL-HAHN TUNING TECHNIQUE (A.F. RTNEPH OBS)
C                  ...STRATUS COMPUTED SIMILAR TO OLD OPNL CLDJMS.....
C                      EXCEPT NO CLOUD BELOW LAYER=KLOWB..APPROX 955MB
CTUNE
C     CONVECTIVE CLOUDS ARE FROM MODEL CONVECTIVE SCHEME AND ARE
C        NO LONGER BROKEN INTO .75,.25,.25..RATHER CC ITSELF IS USED..
C        CONVECTIVE STILL TAKES PRECEDENCE OVER STRATIFORM IN RADFS
C         BUT HERE CV+ST MERGE EXITS IN CLDARY...(IN RADIATION USE OF
C        CC GIVES IMPROVEMENT TO TROPICAL MIDDLE CLD (AS DID ST+CV))
C
C     CLOUDS ARE ALSO DIVIDED INTO 3 ATMOSPHERIC DOMAINS (L,M,H) FOR
C        DIAGNOSTIC PURPOSES.  THEY ARE COMPUTED FROM RANDOM OVERLAP
C        ASSUMPTION FOR SEPARATED CLOUD LAYERS AND MAXIMUM OVERLAP
C        FOR ADJACENT CLOUD LAYERS.  A TOTAL CLOUD FRACTION IS ALSO
C        COMPUTED.
C
C     H,M,L DOMAIN PRESSURE TOPS 'PTOP1(K)' VARY LINEARLY FROM
C        'PTOPC(K,1)' AT 45DEG TO 'PTOPC(K,2)' AT THE POLE
C
C--------------------------------------------------------------------
C     INPUT VARIABLES:
C        PS (CB)       - SURFACE PRESSURE
C        Q  (KG/KG)    - SPECIFIC HUMIDITY
C        T  (DEG K)    - ABSOLUTE TEMPERATURE
C        VVEL(CB/SEC)  - VERTICAL VELOCITY
C        CV,CVT,CVB    - CONV CLD FRACTION, TOP, BOTTOM LAYER FROM
C                        KUO SCHEME
C        SI,SL         - MDL SIGMA INTERFACE AND LAYER MEAN
C        SLMSK         - SEA/LAND MASK ARRAY(SEA:0.,LAND:1.,SNOW:2.)
C        IVVA          - FLAG TO CONTROL VERTICAL VELOCITY ADJ.
C                        =1: WITH, =0: WITHOUT
C        INVR          - FLAG TO CONTROL LAPSE RATE INVERSION CLD
C                        =1: WITH, =0: WITHOUT
C        RHMAX         - UPPER LIMIT OF RELATIVE HUMIDITY TO
C                        FORM OVERCAST CLOUD (CLD FRACTN = 1.)
CTUNE
C --------------- MODIFY TO AS AN ARRAY (H.-M. H. JUANG)
C********XLATRD        - CURRENT LATITUDE IN RADIANS (1ST DATA PT)
C********                 FOR MODELS WITH DIFF LAT AT EACH PT, NEED TO
C********                 USE THE LAT OF ALL POINTS....CAREFUL.....
C        RHCLD         - CLOUD-RH RELATIONS FROM MITCHELL+HAHN,
C                        USING A.F. RTNEPH ANALYSES
C        ISTRAT        - 0 OR 1:FOR DEFAULT OR 'RHCLD' TABLES
C                        IN THE STRATIFORM CLOUD CALCULATION
CTUNE
C    OUTPUT VARIABLES:
C       CLDARY         - VERTICAL COLUMN ARRAY OF CLOUD FRACTION
C                        PROFILE
C       CLD            - CLD FRACTION IN 3 TYPES OF DOMAINS (L,M,H)
C                          AND TOTAL IN 4TH LAYER
C       MTOP,MBOT      - TOP, BOTTOM LAYERS OF CLOUDS (L,M,H)
C
C--------------------------------------------------------------------
C
                      P A R A M E T E R
     1 ( RD=#RD, RV=#RV, EPS=RD/RV, EPSM1=RD/RV-1.0, PI=#PI )
                      D I M E N S I O N
     1  PS(IDIMS), CV(IDIMT),  CVT(IDIMT),  CVB(IDIMT)
     2, SLMSK(IDIMT),SI(KDIM+1),  SL (KDIM)
     3, T(IDIMS,KDIM), VVEL(IDIMT,KDIM),   Q(IDIMS,KDIM)
CTOT 4, CLD(IDIMT,3),    MTOP(IDIMT,3),      MBOT(IDIMT,3)
     4, CLD(IDIMT,4),    MTOP(IDIMT,3),      MBOT(IDIMT,3)
CYH945, CLDARY(IDIMT,KDIM), CLSTR(IDIMT)
     5, CLDARY(IDIMT,KDIM),XLATRD(IDIMT)
CTUNE
C...    RH-CLD RELATIONSHIPS FOR EACH POINT
      DIMENSION RHCLD(IDIMT,NBIN,MCLD)
CTUNE
C
C --- PTOPC(K,L): TOP PRESURE OF EACH CLD DOMAIN (K=1-4 ARE SFC,L,M,H;
C       L=1,2 ARE LOW-LAT (<45 DEGREE) AND POLE REGIONS)
      COMMON /COMCD1/ ROCP,PTOPC(4,2),CVTOP,VVCLD(2),CLAPSE
     1,               CRHRH,KLOWT,KLOWB,PSTRT
     2,               LLYR,CLAPKC,DCLPS,CLPSE
C ---  WORKSPACE ---
                        L O G I C A L
CYH941  BITX(IDIMT), BITY(IDIMT), BITZ(IDIMT), BITW(IDIMT), BIT1, BIT2
     1  BITX(IDIMT), BITY(IDIMT), BITZ(IDIMT),              BIT1, BIT2
     2, BITM(IDIMT)
                      D I M E N S I O N
     1  RHRH (IDIMT,KDIM), PRSLY(IDIMT,KDIM),  DTHDP(IDIMT,KDIM)
     2, THETA(IDIMT,KDIM), KCUT (IDIMT),       KBASE(IDIMT)
     3, KBT1 (IDIMT),      KTH1 (IDIMT),       CL1  (IDIMT)
     4, KBT2 (IDIMT),      KTH2 (IDIMT),       CL2  (IDIMT)
     5, KCVB (IDIMT),      KCVT (IDIMT),       OMEG (IDIMT)
CNOT 6, FACV (IDIMT,3),    KSAVE(IDIMT)
     6,                    KSAVE(IDIMT)
     7, PTOP1(IDIMT,4)
CC                    E Q U I V A L E N C E
CC   1  (KBT1, KCVB, THETA(1,1)),   (KBT2, KCUT, THETA(1,2))
CC   2, (KTH1, KCVT, THETA(1,3)),   (KTH2,       THETA(1,4))
CC   3, (CL1 ,       THETA(1,5)),   (CL2 ,       THETA(1,6))
CC   4, (CR1 ,       THETA(1,7)),   (CR2 ,       THETA(1,8))
CC   5, (OMEG,       THETA(1,9)),   (KBASE,      THETA(1,10))
CC   6, (XCRH1,      THETA(1,11)),  (XCRH2,FACV, THETA(1,12))
C===>    BEGIN HERE ................................................
      KDIMP=KDIM+1
      LEVM1=KDIM-1
      LEVM2=KDIM-2
C...  FIND TOP PRESSURE FOR EACH CLOUD DOMAIN
      DO 4 K=1,4
      DO 4 I=1,IDIMT
       FAC = AMAX1(0.0#E0, 4.0#E0*ABS(XLATRD(I))/PI-1.0#E0)
       PTOP1(I,K) = PTOPC(K,1) + (PTOPC(K,2)-PTOPC(K,1)) * FAC
    4 CONTINUE
C --- LOW CLOUD TOP SIGMA LEVEL, COMPUTED FOR EACH LAT CAUSE
C       DOMAIN DEFINITION CHANGES WITH LATITUDE...
      KLOW=KDIM
CBBK  DO 10 I=1,IDIMT
CBBK  SILOW = PTOP1(I,2) * 1.0#E-3
CBBK  DO 6 K=1,KDIM
CBBK    KK=K
CBBK    IF (SI(KK) .LT. SILOW) GO TO 8
C  6  CONTINUE
C  8  KLOW = MIN(KLOW,KK)
C 10  CONTINUE
      DO 10 K=KDIM,1,-1
      DO 10 I=1,IDIMT
        IF (SI(K) .LT. PTOP1(I,2) * 1.0#E-3) KLOW = MIN(KLOW,K)
  10  CONTINUE
C --- POTENTIAL TEMP AND LAYER RELATIVE HUMIDITY
      DO 40 K=1,KDIM
      DO 40 I=1,IDIMT
        CLDARY(I,K) = 0.0#E0
        PRSLY(I,K) = PS(I) * SL(K) * 10.0#E0
        EXNR = (PRSLY(I,K)*0.001#E0) ** (-ROCP)
        THETA(I,K) = EXNR * T(I,K)
        ES = FPVS(T(I,K))
        QS = EPS * ES / (SL(K)*PS(I) + EPSM1*ES)
        RHRH(I,K) = AMAX1(0.0#E0, AMIN1(1.0#E0, Q(I,K)/QS))
  40  CONTINUE
C --- POTENTIAL TEMP LAPSE RATE
      DO 50 K=1,LEVM1
      DO 50 I=1,IDIMT
        DTHDP(I,K) = (THETA(I,K+1) - THETA(I,K)) /
     1               (PRSLY(I,K+1) - PRSLY(I,K))
  50  CONTINUE
C ------------------------------------------------------------------
C     FIND THE STRATOSPHERE CUT OFF LAYER FOR HIGH CLOUD. IT
C      IS ASSUMED TO BE ABOVE THE LAYER WITH DTHDP LESS THAN
C      -0.25 IN THE HIGH CLOUD DOMAIN (FROM LOOKING AT 1 CASE).
C ------------------------------------------------------------------
      DO 60 I=1,IDIMT
        KCUT(I) = LEVM2
  60  CONTINUE
      DO 80 K=KLOW+1,LEVM2
        BIT1 = .FALSE.
        DO 70 I=1,IDIMT
          IF (KCUT(I).EQ.LEVM2 .AND. PRSLY(I,K).LE.PTOP1(I,3) .AND.
     1        DTHDP(I,K).LT.-0.25#E0) THEN
            KCUT(I) = K
          END IF
          BIT1    = BIT1 .OR. KCUT(I).EQ.LEVM2
  70    CONTINUE
        IF (.NOT. BIT1) GO TO 85
  80  CONTINUE
  85  CONTINUE
C ------------------------------------------------------------------
      IF (ISTRAT.LE.0) THEN
C ------------------------------------------------------------------
C       ....DEFAULT SCHEME ....TUNED FOR 28 LYRS BY Y-T HOU.
CYH   CALCULATE STRATIFORM CLOUD AND PUT INTO ARRAY 'CLDARY'
CYH     THE RELATIVE HUMIDITY CRITERIA ARE PRESET FOR EACH MODEL
CYH     SIGMA LEVEL, (1) FOR OCEAN POINTS, AND (2) FOR LAND POINTS.
C ------------------------------------------------------------------
CKAC  DO 130 K=3,LEVM2
      DO 130 K=KLOWB,LEVM2
        BIT1 = .FALSE.
        DO 90 I=1,IDIMT
CYH..     BITX(I) = PRSLY(I,K).LE.PLOW .AND. K.LE.KCUT(I)
          BITX(I) = K.LE.KCUT(I)
          BIT1 = BIT1 .OR. BITX(I)
  90    CONTINUE
        IF (.NOT. BIT1) GO TO 130
        SPNT = AMAX1(0.6#E0, AMIN1(0.85#E0, 0.96#E0-0.6#E0*SL(K)))
        CR1SE1 = (0.41#E0*SL(K) - 0.71#E0)**2 + 0.52#E0
        CR1SL1 = 0.8#E0 - 0.167#E0*SL(K)
        DO 100 I=1,IDIMT
CYH..     CR1 = CRH(K,1)
CYH..     IF (SLMSK(I).EQ.1.0#E0) CR1 = CRH(K,2)
CYH       XCRH1 = 0.67 * (RHMAX - CR1)
          IF (SLMSK(I).EQ.1.0#E0) THEN
            CR1 = CR1SE1
          ELSE
            CR1 = CR1SL1
          END IF
          XCRH1 = SPNT * (RHMAX - CR1)
          CR2 = CR1 + XCRH1
          XCRH2 = RHMAX - CR2
          CL1(I) = AMAX1(0.#E0, (RHRH(I,K)-CR1)/XCRH1) ** 3
CYH       CL1(I) = CL1(I)**4
          IF (CL1(I).GT.1.0#E0)
     1      CL1(I) = 1.#E0 + SQRT((RHRH(I,K)-CR2)/XCRH2)
 100    CONTINUE
        DO 120 I=1,IDIMT
          IF (BITX(I)) THEN
            CLDARY(I,K) = AMIN1(1.0#E0, 0.5#E0*CL1(I))
          END IF
 120    CONTINUE
 130  CONTINUE
C ------------------------------------------------------------------
C     SPECIAL TREATMENT ON LOW CLOUDS
C ------------------------------------------------------------------
      DVVCLD = VVCLD(1) - VVCLD(2)
      RCLAP = 1.0#E0 / (0.8#E0 - CRHRH)
      DO 180 I=1,IDIMT
        KBASE(I) = 0
 180  CONTINUE
C
      DO 350 K=KLOWB,KLOWT
C
        DO 190 I=1,IDIMT
          OMEG(I) = 10.0#E0 * VVEL(I,K)
          CL1 (I) = 0.0#E0
 190    CONTINUE
        IF (IVVA .LE. 0) GO TO 250
C --- VERTICAL VELOCITY ADJUSTMENT ON LOW CLOUDS
        BIT1 = .FALSE.
        DO 210 I=1,IDIMT
          BITX(I) = PRSLY(I,K).GE.PTOP1(I,2) .AND. CLDARY(I,K).GT.0.0#E0
          BIT1 = BIT1 .OR. BITX(I)
 210    CONTINUE
        IF (.NOT. BIT1) GO TO 250
        DO 220 I=1,IDIMT
          IF (BITX(I)) THEN
            IF (OMEG(I).GE.VVCLD(1)) THEN
              CLDARY(I,K) = 0.0#E0
            ELSE IF(OMEG(I).GT.VVCLD(2)) THEN
              CR1 = (VVCLD(1) - OMEG(I)) / DVVCLD
C             CLDARY(I,K) = CLDARY(I,K) * CR1
              CLDARY(I,K) = CLDARY(I,K) * SQRT(CR1)
            ENDIF
          ENDIF
 220    CONTINUE
C --- T INVERSION RELATED STRATUS CLOUDS
 250    IF (INVR .LT. 1) GO TO 350
        BIT1 = .FALSE.
        DO 260 I=1,IDIMT
          BITX(I) = PRSLY(I,K).GE.PSTRT .AND. SLMSK(I).LE.0.0
     1              .AND. DTHDP(I,K).LE.CLAPSE
CYH  2              .AND. OMEG (I).GT.0.0
          BIT1 = BIT1 .OR. BITX(I)
 260    CONTINUE
        IF (.NOT. BIT1) GO TO 350
        DO 270 I=1,IDIMT
          IF ( KBASE(I).EQ.0  .AND. RHRH(I,K).GT.CRHRH .AND. BITX(I) )
     1      KBASE(I) = K
 270    CONTINUE
        DO 300 I=1,IDIMT
          IF (KBASE(I).GT.0 .AND. BITX(I) .AND. CLDARY(I,K+1).LE.0.1#E-1
     1        .AND. CLDARY(I,K+2).LE.0.1#E-1) THEN
            CR1 = AMIN1(1.0#E0,
     1            AMAX1(0.0#E0,  16.67#E0*(CLAPSE-DTHDP(I,K)) ))
            IF(RHRH(I,KBASE(I)).LT.0.8#E0) THEN
              CR1 = CR1 * (RHRH(I,KBASE(I))-CRHRH) * RCLAP
            ENDIF
C --- FOR T INVERSION TYPE CLOUD, ADD FLAG VALUE OF 2.0
            CLDARY(I,K) = AMAX1(CLDARY(I,K), CR1) + 2.0#E0
          ENDIF
 300    CONTINUE
 350  CONTINUE
C ------------------------------------------------------------------
      END IF
C ------------------------------------------------------------------
      IF (ISTRAT.GT.0) THEN
CTUNE
C ------------------------------------------------------------------
C     CALCULATE STRATIFORM CLOUD AND PUT INTO ARRAY 'CLDARY' USING
C       THE CLOUD-REL.HUMIDITY RELATIONSHIP FROM TABLE LOOK-UP..WHERE
C       TABLES OBTAINED USING K.MITCHELL FREQUENCY DISTRIBUTION TUNING
C        (OBSERVATIONS ARE DAILY MEANS FROM US AF RTNEPH).....K.A.C.
C       TABLES CREATED WITHOUT LOWEST 10 PERCENT OF ATMOS.....K.A.C.
C ------------------------------------------------------------------
C  THIS LOOP TO RETRIEVE CLOUD FROM RH REWRITTEN 950113 -MI
      DO KLEV=KLOWB,LEVM2
        DO I=1,IDIMT
          KBASE(I)=0
          BITX(I)=.FALSE.
        ENDDO
        DO KC=MCLD,1,-1
          DO I=1,IDIMT
            IF(PRSLY(I,KLEV).GE.PTOP1(I,KC+1)) KBASE(I)=KC
          ENDDO
        ENDDO
        NX=0
        NHALF=(NBIN+1)/2
        DO I=1,IDIMT
          IF(KBASE(I).LE.0.OR.KLEV.GT.KCUT(I)) THEN
            CLDARY(I,KLEV)=0.
          ELSEIF(RHRH(I,KLEV).LE.RHCLD(I,1,KBASE(I))) THEN
            CLDARY(I,KLEV)=0.
          ELSEIF(RHRH(I,KLEV).GE.RHCLD(I,NBIN,KBASE(I))) THEN
            CLDARY(I,KLEV)=1.
          ELSE
            BITX(I)=.TRUE.
            KSAVE(I)=NHALF
            NX=NX+1
          ENDIF
        ENDDO
        DOWHILE(NX.GT.0)
          NHALF=(NHALF+1)/2
          DO I=1,IDIMT
            IF(BITX(I)) THEN
              CRK=RHRH(I,KLEV)
              CR1=RHCLD(I,KSAVE(I),KBASE(I))
              CR2=RHCLD(I,KSAVE(I)+1,KBASE(I))
              IF(CRK.LE.CR1) THEN
                KSAVE(I)=MAX(KSAVE(I)-NHALF,1)
              ELSEIF(CRK.GT.CR2) THEN
                KSAVE(I)=MIN(KSAVE(I)+NHALF,NBIN-1)
              ELSE
                CLDARY(I,KLEV)=0.01*(KSAVE(I)+(CRK-CR1)/(CR2-CR1))
                BITX(I)=.FALSE.
                NX=NX-1
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C.... CLEAN OUT NOT-SUSPECTED MARINE STRATUS REGIONS...
C      CAUSE TUNING PROCEDURE NOT CARRIED OUT DOWN TO LYR3 AND WE
C      GET TOO MUCH LO CLOUD IF WE DON T CLEAN IT OUT..
      DO 831 I=1,IDIMT
       BITM(I) = .TRUE.
  831 CONTINUE
CKAC  DO 833 K=3,LLYR
      DO 833 K=KLOWB,LLYR
       DO 832 I=1,IDIMT
        IF(BITM(I)) THEN
          BITM(I) = PRSLY(I,K).LT.PSTRT
     1         .OR. SLMSK(I).GT.0.0 .OR. DTHDP(I,K).GT.CLAPKC.OR.
CKC  2        CLDARY(I,K+1).GT.0.005#E0.OR.CLDARY(I,K+2).GT.0.005#E0
CKAC 2        RHRH (I,K+1).GT.0.80#E0.OR.RHRH (I,K+2).GT.0.80#E0
     2        RHRH (I,K+1).GT.0.60#E0.OR.RHRH (I,K+2).GT.0.60#E0
          KBASE(I) = K
        ENDIF
  832  CONTINUE
  833 CONTINUE
      DO 835 K=1,LLYR
       DO 834 I=1,IDIMT
        IF(BITM(I)) CLDARY(I,K) = 0.0#E0
  834  CONTINUE
  835 CONTINUE
C ------------------------------------------------------------------
C     SPECIAL TREATMENT ON LOW CLOUDS
C ------------------------------------------------------------------
      DVVCLD = VVCLD(1) - VVCLD(2)
C
CKAC  DO 950 K=3,KLOW
      DO 950 K=KLOWB,KLOW
C
        DO 904 I=1,IDIMT
          OMEG(I) = 10.0#E0 * VVEL(I,K)
          CL1 (I) = 0.0#E0
 904    CONTINUE
CYH94   IF (IVVA .LT. 1) GO TO 920
        IF (IVVA .LE. 0) GO TO 920
C --- VERTICAL VELOCITY ADJUSTMENT ON LOW CLOUDS
        BIT1 = .FALSE.
        DO 906 I=1,IDIMT
          BITX(I) = PRSLY(I,K).GE.PTOP1(I,2) .AND. CLDARY(I,K).GT.0.0#E0
          BIT1 = BIT1 .OR. BITX(I)
 906    CONTINUE
        IF (.NOT. BIT1) GO TO 920
        IF(K.GT.LLYR) THEN
          DO 910 I=1,IDIMT
            IF (BITX(I)) THEN
              IF(OMEG(I).GE.VVCLD(1)) THEN
                CLDARY(I,K) = 0.0#E0
              ELSE IF(OMEG(I).GT.VVCLD(2)) THEN
                CR1 = (VVCLD(1) - OMEG(I)) / DVVCLD
C               CLDARY(I,K) = CLDARY(I,K) * CR1
                CLDARY(I,K) = CLDARY(I,K) * SQRT(CR1)
              ENDIF
            ENDIF
 910      CONTINUE
        ELSE
          DO 915 I=1,IDIMT
C....    NO VVEL FILTER FOR MARINE STRATUS REGION
            IF (BITM(I)) THEN
              IF (BITX(I)) THEN
                IF(OMEG(I).GE.VVCLD(1)) THEN
                  CLDARY(I,K) = 0.0#E0
                ELSE IF(OMEG(I).GT.VVCLD(2)) THEN
                  CR1 = (VVCLD(1) - OMEG(I)) / DVVCLD
C                 CLDARY(I,K) = CLDARY(I,K) * CR1
                  CLDARY(I,K) = CLDARY(I,K) * SQRT(CR1)
                ENDIF
              ENDIF
            ENDIF
 915      CONTINUE
        ENDIF
C --- T INVERSION RELATED STRATUS CLOUDS
 920    IF (INVR .LT. 1) GO TO 950
        IF (K.GT.LLYR) GO TO 950
        BIT1 = .TRUE.
        DO 930 I=1,IDIMT
          BIT1 = BIT1 .AND. BITM(I)
 930    CONTINUE
        IF (BIT1) GO TO 950
        DO 940 I=1,IDIMT
         IF (.NOT.BITM(I)) THEN
          IF (DTHDP(I,KBASE(I)).GT.CLPSE) THEN
C---   SMOOTH TRANSITION FOR CLOUD WHEN DTHDP BETWEEN
C           CLAPSE AND CLAPSE+DCLPS  (-0.05 AND -0.06)
           CFILTR = 1.0#E0 - ((CLPSE - DTHDP(I,KBASE(I))) / DCLPS)
           CLDARY(I,K) = CLDARY(I,K)*CFILTR
          END IF
C --- FOR T INVERSION TYPE CLOUD, ADD FLAG VALUE OF 2.0
          CLDARY(I,K) = CLDARY(I,K)+2.0#E0
         END IF
 940    CONTINUE
 950  CONTINUE
C ------------------------------------------------------------------
      END IF
CTUNE
C ------------------------------------------------------------------
C     ADD CONVECTIVE CLOUD INTO 'CLDARY', NO MERGE AT THIS POINT..
C     TWO TYPES OF CLOUDS ARE SEPARATED BY A FACTOR OF 1.0E+4
C ------------------------------------------------------------------
 360  BIT1 = .FALSE.
CNOT  DO 370 L=1,3
CNOT  DO 370 I=1,IDIMT
CNOT    FACV(I,L) = 1.0#E0
C370  CONTINUE
      DO 380 I=1,IDIMT
        BITX(I) = CV(I).GT.0.0#E0 .AND. CVT(I).GE.CVB(I)
        BIT1 = BIT1 .OR. BITX(I)
 380  CONTINUE
      IF (.NOT. BIT1) GO TO 550
      DO 390 I=1,IDIMT
        IF (BITX(I)) THEN
          KCVB(I) = NINT(CVB(I))
          KCVT(I) = MIN(LEVM2, NINT(CVT(I)))
        ELSE
          KCVB(I) = 1
          KCVT(I) = 1
        END IF
 390  CONTINUE
CKAC  DO 450 K=KLOWB,LEVM2
      DO 450 K=KLOWB,LEVM2
        BIT2 = .FALSE.
        DO 400 I=1,IDIMT
          BITY(I) = BITX(I) .AND. KCVB(I).LE.K .AND. KCVT(I).GE.K
          BIT2 = BIT2 .OR. BITY(I)
 400    CONTINUE
        IF (.NOT. BIT2) GO TO 450
        DO 420 I=1,IDIMT
          IF (BITY(I)) CLDARY(I,K) = CLDARY(I,K)
     1               + 10.0#E0 * AINT(1.0#E3 * CV(I))
 420    CONTINUE
 450  CONTINUE
C     IF MEAN CVT LAYER HIGHER THAN 400MB ADD ANVIL CIRRUS
      BIT2 = .FALSE.
      DO 460 I=1,IDIMT
        BITZ(I) = BITX(I) .AND. PRSLY(I,KCVT(I)).LE.CVTOP
        BIT2 = BIT2 .OR. BITZ(I)
 460  CONTINUE
      IF (.NOT. BIT2) GO TO 500
      DO 480 I=1,IDIMT
        IF (BITZ(I)) THEN
CKAC      KK = KCVT(I) + 1
          KK = KCVT(I)
          CR1 = AMAX1(0.0#E0, AMIN1(1.0#E0, 2.0#E0*(CV(I)-0.3#E0)))
C....    GET STRATUS BACK BEFORE DOING ANVIL CALCULATION
          CR2 = AMOD(CLDARY(I,KK),10.#E0)
          CLDARY(I,KK) = CR2 + 10.0#E0*AINT(1.0#E3*CR1)
CKAC      CLDARY(I,KK) = CLDARY(I,KK) + 10.0#E0*AINT(1.0#E3*CR1)
        END IF
 480  CONTINUE
C -------------------------------------------------------------------
C     SEPARATE CLOUDS INTO 3 PRESSURE DOMAINS (L,M,H).  WITHIN EACH
C     OF THE DOMAINS, ASSUME SEPARATED CLOUD LAYERS ARE RANDOMLY
C     OVERLAPPED AND ADJACENT CLOUD LAYERS ARE MAXIMUM OVERLAPPED.
C     VERTICAL LOCATION OF EACH TYPE OF CLOUD IS DETERMINED BY
C     THE THICKEST CONTINUING CLOUD LAYERS IN THE DOMAIN.
CNOT  DEEP CONVECTIVE CLOUD SPAN MORE THAN 1 DOMAIN WILL BE MULTIPLIED
CNOT  BY A FACTOR FOR EACH OF THE DOMAINS.
C -------------------------------------------------------------------
 500  CONTINUE
CNOT  DO 520 L=1,2
CNOT  DO 520 I=1,IDIMT
CNOT    IF (BITX(I) .AND. PRSLY(I,KCVB(I)).GE.PTOP1(I,L+1)
CNOT 1              .AND. PRSLY(I,KCVT(I)).LT.PTOP1(I,L+1)) THEN
CYH94     FACV(I,L)   = AMAX1(0.30#E0, 0.80#E0*FACV(I,L))
CNOT      FACV(I,L)   = AMAX1(0.35#E0, 0.80#E0*FACV(I,L))
CYH94     FACV(I,L+1) = 0.30#E0
CNOT      FACV(I,L+1) = 0.35#E0
CNOT    END IF
C520  CONTINUE
 550  CONTINUE
C     DO 552 I=1,64,10
C     WRITE(6,551) I,(CLDARY(I,K),K=1,KDIM)
C551  FORMAT(' IN CLDNEW: I=',I3,' CLDARY(I,K)=',8E10.2/10X,10E10.2)
C552  CONTINUE
CYH94 FOVP = 1.0#E0 / ANINT(FLOAT(KDIM) / 9.0#E0)
C --- LOOP OVER 3 CLOUD DOMAINS (L,M,H)
      DO 750 L=1,3
C
        DO 580 I=1,IDIMT
          CLD (I,L) = 0.0#E0
          MTOP(I,L) = 1
          MBOT(I,L) = 1
          CL1 (I) = 0.0#E0
          CL2 (I) = 0.0#E0
          KBT1(I) = 1
          KBT2(I) = 1
          KTH1(I) = 0
          KTH2(I) = 0
 580    CONTINUE
C
        DO 700 K=2,LEVM2
          BIT1 = .FALSE.
          DO 600 I=1,IDIMT
            BITX(I) = (PRSLY(I,K).GE.PTOP1(I,L+1)) .AND.
     1        (PRSLY(I,K).LT.PTOP1(I,L)) .AND. (CLDARY(I,K).GT.0.0#E0)
            BIT1 = BIT1 .OR. BITX(I)
 600      CONTINUE
          IF (.NOT. BIT1) GO TO 700
          DO 630 I=1,IDIMT
            CR1  = AMOD(CLDARY(I,K), 2.0#E0)
            CR2  = FLOAT(INT(CLDARY(I,K)) / 10) * 1.0#E-3
CNOT        CR3  = (CR1 + CR2 - CR1*CR2) * FACV(I,L)
CNOT        CR3  = (CR1 + CR2 - CR1*CR2)
            IF (BITX(I)) THEN
              IF(KTH2(I).LE.0) THEN
C --- KTH2 LE 0 : 1ST CLD LAYER.
                KBT2(I) = K
                KTH2(I) = 1
              ELSE
C --- KTH2 GT 0 : CONSECUTIVE CLD LAYER.
                KTH2(I) = KTH2(I) + 1
              ENDIF
CNOT          CL2 (I) = AMAX1(CL2(I), CR3)
C ---  PHYSICAL CLOUD AS SEEN BY RADIATION..CONV TAKES PRECEDENCE
C ---    EXCEPT ANVIL CIRRUS NOT RANDOM OVERLAPPED WITH CV TOWER AS
C ...      IN RADIATION CODE(SO HI MAY BE SLIGHT UNDERESTIMATE)....
              IF (CR2.GT.0.0#E0) THEN
               CL2 (I) = AMAX1(CL2(I), CR2)
              ELSE
               CL2 (I) = AMAX1(CL2(I), CR1)
              END IF
            ENDIF
 630      CONTINUE
          BIT2 = .FALSE.
C....  BITY=TRUE IF NEXT LYR=CLEAR OR WE CHANGE CLOUD DOMAINS..
          DO 640 I=1,IDIMT
            BITY(I) = BITX(I) .AND. (CLDARY(I,K+1).LE.0.0#E0
     1                         .OR.  PRSLY(I,K+1).LT.PTOP1(I,L+1) )
            BIT2 = BIT2 .OR. BITY(I)
 640      CONTINUE
          IF (.NOT. BIT2) GO TO 700
C --- AT THE DOMAIN BOUNDARY OR SEPARATED CLD LYRS, RANDOM OVERLAP.
C     CHOOSE THE THICKEST OR THE LARGEST FRACTION AMT AS THE CLD
C     LAYER IN THAT DOMAIN
          DO 650 I=1,IDIMT
            IF (BITY(I)) THEN
              IF (CL1(I).GT.0.0#E0) THEN
                KBT1(I) = INT( (CL1(I)*KBT1(I) + CL2(I)*KBT2(I))
     1                       / (CL1(I) + CL2(I)) )
                KTH1(I) = NINT( (CL1(I)*KTH1(I) + CL2(I)*KTH2(I))
     1                        / (CL1(I) + CL2(I)) ) + 1
                CL1 (I) = CL1(I) + CL2(I) - CL1(I)*CL2(I)
              ELSE
                KBT1(I) = KBT2(I)
                KTH1(I) = KTH2(I)
                CL1 (I) = CL2 (I)
              ENDIF
              KBT2(I) = 1
              KTH2(I) = 0
              CL2 (I) = 0.0#E0
            ENDIF
 650      CONTINUE
 700    CONTINUE
C --- FINISH ONE DOMAIN, SAVE EFFECTIVE CLOUDS
        DO 720 I=1,IDIMT
          CLD(I,L) =  CL1(I)
          MTOP(I,L) = MAX(KBT1(I), KBT1(I)+KTH1(I)-1)
          MBOT(I,L) = KBT1(I)
 720    CONTINUE
 750  CONTINUE
C....  CALCULATE TOTAL CLOUD FROM THE MULTI-LYR CLOUD ARRAY
C  .......IN A MANNER AS SEEN BY THE RADIATION CODE........
C      WHERE, MAX OVERLAP IS USED FOR VERTICALLY ADJACENT CLOUD LAYERS
C      .. A CLEAR LAYER SEPARATES TWO CONTIGUOUSLY LAYERED CLOUD TYPES.
C      WHERE, FOR CONVECTION ANY ANVIL IS CONSIDERED A SEPARATE
C         RANDOMLY OVERLAPPED CLOUD..
C      ILOW=0,1 IF NO,YES PRECEEDING MODEL LAYER WAS CLOUDY..
C      CLOW CONTAINS THE CLOUDINESS OF PRECEEDING SEPARATE LAYERED CLD
      DO 780 I=1,IDIMT
       CLD(I,4) = 0.#E0
       ICVEC = 0
       ILOW = 0
       CLOW = 0.#E0
       DO 780 K=1,KDIM
        CCLDY = AMOD(CLDARY(I,K), 2.0#E0)
        CCVEC = FLOAT(INT(CLDARY(I,K)) / 10) * 1.0#E-3
        IF (CCVEC.GT.0.#E0) THEN
         CCLDY = CCVEC
         ICVEC = 1
        END IF
        IF (CCLDY.GT.0.#E0) THEN
         IF (ILOW.EQ.0) THEN
          CLOW = CCLDY
          ILOW = 1
         ELSE
          IF (ICVEC.GT.0) THEN
           IF (CCLDY.NE.CLOW) THEN
C...  IF CONVECTIVE AND AN ADJACENT LYR=STRATIFORM (IE CCLDY CHANGES),
C.      THEN RANDOM OVERLAP THE PRECEEDING CLOUD TOWER...
            CLD(I,4) = CLD(I,4) + (1.-CLD(I,4))*CLOW
            CLOW = CCLDY
           END IF
          ELSE
C...  MAX OVERLAP FOR NON CONVECTIVE ADJACENT CLD LAYERS...
           CLOW = MAX(CCLDY,CLOW)
          END IF
         END IF
        ELSE
         IF (ILOW.EQ.1) THEN
C...  IF THIS IS FIRST CLEAR LAYER IN A GAP BETWIXT CLDLYRS, THEN
C.      RANDOM OVERLAP THE PRECEEDING CLOUDS WITH THE ONES BELOW..
          CLD(I,4) = CLD(I,4) + (1.-CLD(I,4))*CLOW
          ILOW = 0
         END IF
        END IF
 780  CONTINUE
      RETURN
      END
      SUBROUTINE OMEGAS(NX,NXS,NZ,
     1      DPHI,DLAM,CG,UG,VG,DG,DEL,RCL,VVEL,PS,SL)
CFPP$ NOCONCUR R
C....   CODE LIFTED FROM POST (MCP1840) JUN 88--COMPUTES VVEL (CB/SEC)
C....    INPUT PS IN CB,OUTPUT VVEL IN CB/SEC
C....   DO LOOPS ALTERED FOR BETTER VECTORIZATION POSSIBILITIES..K.A.C.
      DIMENSION DPHI(NXS),DLAM(NXS),
     1 CG(NX,NZ),UG(NXS,NZ),VG(NXS,NZ),
     2 DG(NXS,NZ),DEL(NZ),PS(NXS),SL(NZ)
C...   VVEL CONTAINS OMEGA IN LAYERS ON RETURN FROM SUBROUTINE...
      DIMENSION VVEL(NX,NZ)
      DIMENSION DB(NX,NZ),CB(NX,NZ),DOT(NX,NZ+1)
      DO 1 K=1,NZ+1
        DO 1 LO=1,NX
          DOT(LO,K) = 0.#E0
    1 CONTINUE
C...  COMPUTE C=V(TRUE)*DEL(LN(PS)).DIVIDE BY COS FOR DEL COS FOR V
      DO 3 LO=1,NX
        DPHI(LO)=DPHI(LO)*RCL
        DLAM(LO)=DLAM(LO)*RCL
    3 CONTINUE
      DO 5 LE=1,NZ
        DO 4 LO=1,NX
          CG(LO,LE)=UG(LO,LE)*DLAM(LO)+VG(LO,LE)*DPHI(LO)
    4   CONTINUE
    5 CONTINUE
      DO 10 LO=1,NX
        DB(LO,1)=DEL(1)*DG(LO,1)
        CB(LO,1)=DEL(1)*CG(LO,1)
   10 CONTINUE
      DO 6 LE=1,NZ-1
        DO 6 LO=1,NX
          DB(LO,LE+1)=DB(LO,LE)+DEL(LE+1)*DG(LO,LE+1)
          CB(LO,LE+1)=CB(LO,LE)+DEL(LE+1)*CG(LO,LE+1)
    6 CONTINUE
C...    SIGMA DOT COMPUTED ONLY AT INTERIOR INTERFACES
      DO 7 K=1,NZ-1
        DO 7 LO=1,NX
          DOT(LO,K+1)=DOT(LO,K)+DEL(K)
     1               *(DB(LO,NZ)+CB(LO,NZ)-DG(LO,K)-CG(LO,K))
    7 CONTINUE
      DO 8 K=1,NZ
        DO 8 LO=1,NX
          VVEL(LO,K)=  SL(K)*(CG(LO,K)-CB(LO,NZ)-DB(LO,NZ))-
     1                0.5*(DOT(LO,K+1)+DOT(LO,K))
          VVEL(LO,K)=VVEL(LO,K)*PS(LO)
CCC       VVEL(LO,K)=VVEL(LO,K)*PS(LO)*10.
    8 CONTINUE
      RETURN
      END
      SUBROUTINE CLDIAG(AVECLA,CLDLA,AVECLB,CLDLB,CLD,CLDARY)
CFPP$ NOCONCUR R
      PARAMETER (IDIM=#LONR2,KDIM=#LEVS)
      PARAMETER (IDIMH=IDIM/2)
      DIMENSION AVECLA(KDIM),CLDLA(4)
      DIMENSION AVECLB(KDIM),CLDLB(4)
      DIMENSION CLDARY(IDIM,KDIM),CLDSUM(IDIM,KDIM)
      DIMENSION CLD(IDIM,4)
      DATA NUMPTS / IDIMH /
C...     UNPACK CLDAMT AND CONV CLDAMT FROM CLDARY..(STRATUS IS +2)
C.        RADIATION SEES STRATIFORM OR CONVECTIVE...NOT MERGED.....
C.        SO CLDSUM REFLECTS THIS BELOW
C...  NOTE:CLDARY 2-4 DIGITS TO LEFT OF DECIMAL=CV CLOUD
C.         CLDARY 1 DIGIT TO LEFT OF DECIMAL+FRACTIONAL PART=STRAT CLD
C.              THOUGH ANVIL CI IS CONSIDERED STRATIFORM
      DO 10 K=1,KDIM
        DO 10 I=1,IDIM
          CSTLYR = AMOD(CLDARY(I,K),2.#E0)
          CST    = AMOD(CLDARY(I,K),10.#E0)
          CCVLYR = 1.#E-4 * (CLDARY(I,K)-CST)
          CLDSUM(I,K) = CSTLYR
          IF (CCVLYR.GT.0.#E0) CLDSUM(I,K) = CCVLYR
   10 CONTINUE
      DO 20 K=1,KDIM
        AVECLA(K) = 0.#E0
        AVECLB(K) = 0.#E0
   20 CONTINUE
      DO 30 K=1,4
        CLDLA(K) = 0.#E0
        CLDLB(K) = 0.#E0
   30 CONTINUE
      DO 40 K=1,KDIM
        DO 40 I=1,IDIMH
          AVECLA(K) = AVECLA(K) + CLDSUM(I,K)
          AVECLB(K) = AVECLB(K) + CLDSUM(I+IDIMH,K)
   40 CONTINUE
      DO 50 K=1,4
        DO 50 I=1,IDIMH
          CLDLA(K) = CLDLA(K) + CLD(I,K)
          CLDLB(K) = CLDLB(K) + CLD(I+IDIMH,K)
   50 CONTINUE
      DO 60 K=1,KDIM
        AVECLA(K) = AVECLA(K) / NUMPTS
        AVECLB(K) = AVECLB(K) / NUMPTS
   60 CONTINUE
      DO 70 K=1,4
        CLDLA(K) = CLDLA(K) / NUMPTS
        CLDLB(K) = CLDLB(K) / NUMPTS
   70 CONTINUE
      RETURN
      END
      SUBROUTINE CVDIAG(AVEN,AVES,CV,CVT,CVB)
      DIMENSION CV(#LONR2),CVT(#LONR2),CVB(#LONR2)
      DIMENSION AVEN(3),AVES(3)
      NPTNOR=0
      NPTSOU=0
      DO 10 K=1,3
        AVEN(K)=0.#E0
        AVES(K)=0.#E0
   10 CONTINUE
      DO 2 I=1,#LONR
        AVEN(1)=AVEN(1)+CV(I)
        AVES(1)=AVES(1)+CV(I+#LONR)
        IF(CV(I).LE.0.#E0) GO TO 1
        AVEN(2)=AVEN(2)+CVT(I)
        AVEN(3)=AVEN(3)+CVB(I)
        NPTNOR = NPTNOR + 1
    1   IF(CV(I+#LONR).LE.0.#E0) GO TO 2
        AVES(2)=AVES(2)+CVT(I+#LONR)
        AVES(3)=AVES(3)+CVB(I+#LONR)
        NPTSOU = NPTSOU + 1
    2 CONTINUE
      AVEN(1)=AVEN(1)/#LONR
      AVES(1)=AVES(1)/#LONR
      IF(NPTNOR.GT.0) THEN
        AVEN(2)=AVEN(2)/NPTNOR
        AVEN(3)=AVEN(3)/NPTNOR
      ENDIF
      IF(NPTSOU.GT.0) THEN
        AVES(2)=AVES(2)/NPTSOU
        AVES(3)=AVES(3)/NPTSOU
      ENDIF
      RETURN
      END
      SUBROUTINE PROFZL(Y,YAV,COLRAD,FHOUR,LEV,LPRT)
      PARAMETER (IDIM=#LONR,JDIM=#LATR,KDIM=#LEVS,JDIM2=JDIM/2)
C...   PROGRAM TO TAKE A HEIGHT-LATITUDE ARRAY, Y(K,LA),
C         AND PRODUCE 18 APPROX EQUI-DISTANCE LAT BELT AVE OVER GLOBE
C...   ALSO COMPUTE WEIGHTED GLOBAL MEANS OF CLOUDS (IPRT=3)
      DIMENSION Y(LEV,JDIM),YAV(LEV,18),COLRAD(JDIM2)
      DIMENSION GLOBL(9,KDIM)
      CHARACTER*44 LTITLE(5)
      CHARACTER*20 KTITLE
      DATA NLAT/18/, JJ/JDIM2/ , LATLON/ 0 /
      DATA LTITLE/' LAT MEAN LYR RADI8IVE HEAT(SW HAS TAUDA=1) ',
     1            ' LATITUDE MEAN CLD FRACTION IN MODEL LAYERS ',
     2            ' LATITUDE MEAN LOW(K=1),MID,HI,TOTAL CLDFRAC',
     3            ' LATITUDE MEAN R.H.FRACTION IN MODEL LAYERS ',
     4            ' LATITUDE MEAN CONVEC CLD FRAC,TOP,BOT      '/
      DATA KTITLE/'OPNL-T80-MODEL CLD  '/
      COMMON /PRFSAV/ LATLON,RLAT(JDIM),WGT(JDIM),IB(18),IE(18)
      KK = LEV
      IF (LATLON.GT.0) GO TO 5
C...   COMPUTE BEGIN AND END LATITUDES FOR EACH OF THE 18 BELTS
      LATLON = 10
      IB(1) = 1
      JDF = JDIM/18
      LFTOVR = JDIM - JDF*18
      IADD = -1
      IF (LFTOVR.GT.0) IADD = 18./LFTOVR
      IE(1) = IB(1) + JDF - 1
      LD = 1
      IL = 0
      IF (IADD.NE.1) GO TO 1
      IE(1) = IE(1) + 1
      LD = 0
      IL = IL + 1
    1 DO 2 L=2,18
        IB(L) = IE(L-1) + 1
        IE(L) = IB(L) + JDF - 1
        LD = LD + 1
        IF (LD.NE.IADD) GO TO 2
        IF (IL.GE.LFTOVR) GO TO 2
        IE(L) = IE(L) + 1
        LD = 0
        IL = IL + 1
    2 CONTINUE
    5 CONTINUE
      DO 10 K = 1,KK
        DO 20 LL = 1,NLAT
          YAV(K,LL)=0.#E0
          JB = IB(LL)
          JE = IE(LL)
          DO 30 LA = JB,JE
            YAV(K,LL) =YAV(K,LL)+Y(K,LA)
   30     CONTINUE
        YPTS = JE - JB + 1
        YAV(K,LL) = YAV(K,LL) / YPTS
   20   CONTINUE
   10 CONTINUE
      CALL PRNTLL(YAV,FHOUR,LTITLE(LPRT),KK)
C...     COMPUTE AREA WGTD GLOBAL MEANS..
      IF(LPRT.EQ.3)
     1         CALL GLOBLM(Y,GLOBL,RLAT,WGT,KK,JDIM,COLRAD,KTITLE,FHOUR)
      RETURN
      END
      SUBROUTINE GLOBLM(Y,GLOBL,RLAT,WGT,KD,LD,COLRAD,LTITL,FHOUR)
C...   COMPUTE AREA WEIGHTED MEANS - GLOBAL,HEMISPHERIC,ETCCCC
C..   INPUT:
C          Y      = LATITUDINAL MEANS - LD LATITUDES,KD LAYERS..
C          COLRAD = CO-LATIUDES IN RADIANS (N.H.)
C          LTITL  = PRINTING LABEL (CHARACTER*20)
C          FHOUR  = FORECAST HOUR
C..   OUTPUT:   PRINTED VALUES (FT06F001)
C            GLOBL(1,KD)=GLOBAL MEAN
C            GLOBL(2,KD)=NORTHERN HEMISPHERE MEAN
C            GLOBL(3,KD)=NORTHERN HEMISPHERE POLAR (90-60DEG) MEAN
C            GLOBL(4,KD)=NORTHERN HEMISPHERE MIDLAT(60-30DEG) MEAN
C            GLOBL(5,KD)=NORTHERN HEMISPHERE TROPIC(30-0 DEG) MEAN
C            GLOBL(6,KD)=SOUTHERN HEMISPHERE MEAN
C            GLOBL(7,KD)=SOUTHERN HEMISPHERE POLAR (90-60DEG) MEAN
C            GLOBL(8,KD)=SOUTHERN HEMISPHERE MIDLAT(60-30DEG) MEAN
C            GLOBL(9,KD)=SOUTHERN HEMISPHERE TROPIC(30-0 DEG) MEAN
      DIMENSION Y(KD,LD),COLRAD(LD)
      CHARACTER*20 LTITL
      DIMENSION GLOBL(9,KD),RLAT(LD),WGT(LD)
      DIMENSION GLOBX(9,100)
      COMMON /GLBSAV/ LATLON,WTSUM(5),J30,J60
      DATA LATLON/ 0 /
      JJ = LD / 2
      KK = KD
      IF (LATLON.GT.0) GO TO 30
C...   COMPUTE AREA WGTS AND LATITUDES JUST POLEWARD OF 60DEG (J60)
C         AND JUST POLEWARD OF 30DEG (J30)
      LATLON = 10
      RAD60 = #PI / 3.#E0
      RAD30 = #PI / 6.#E0
C...   LATITUDE IN RADIANS
      DO 5 J=1,JJ
        RLAT(J) =  #PI / 2.#E0 - COLRAD(J)
    5 CONTINUE
      DO 10 J=1,JJ
        IF(RLAT(J).LT.RAD60) GO TO 15
        J60 = J
   10 CONTINUE
      GO TO 200
   15 DO 20 J=1,JJ
        IF(RLAT(J).LT.RAD30) GO TO 25
        J30 = J
   20 CONTINUE
      GO TO 205
   25 DO 26 N=1,5
        WTSUM(N) = 0.
   26 CONTINUE
      RLATS = 0.5#E0 * (RLAT(1)+RLAT(2))
      WGT(1) = 1. - SIN(RLATS)
      RLATN = 0.5#E0 * (RLAT(JJ)+RLAT(JJ-1))
      WGT(JJ) = SIN(RLATN)
      DO 27 LA=2,JJ-1
        RLATN = 0.5#E0 * (RLAT(LA)+RLAT(LA-1))
        RLATS = 0.5#E0 * (RLAT(LA)+RLAT(LA+1))
        WGT(LA) = SIN(RLATN) - SIN(RLATS)
   27 CONTINUE
      PRINT 9,JJ,J60,J30
    9 FORMAT(1H ,' JJ=',I4,'  J60=',I4,'  J30=',I4)
      DO 28 LA=1,JJ
C..    GLOBAL AREA
        WTSUM(1) = WTSUM(1) + 2.#E0 * WGT(LA)
C..    HEMISPHERIC AREA
        WTSUM(2) = WTSUM(2) + WGT(LA)
C..    LATITUDE STRIP AREAS
        IF (LA.GT.J60) GO TO 31
        WTSUM(3) = WTSUM(3) + WGT(LA)
        GO TO 28
   31   IF (LA.GT.J30) GO TO 32
        WTSUM(4) = WTSUM(4) + WGT(LA)
        GO TO 28
   32   WTSUM(5) = WTSUM(5) + WGT(LA)
   28 CONTINUE
C...
   30 CONTINUE
C...
      DO 35 K = 1,KK
        DO 35 J = 1,9
          GLOBL(J,K) = 0.#E0
   35 CONTINUE
      DO 75 LA=1,JJ
       DO 45 K=1,KK
        GLOBL(2,K) = GLOBL(2,K) + WGT(LA)*Y(K,LA)
        GLOBL(6,K) = GLOBL(6,K) + WGT(LA)*Y(K,LD+1-LA)
        GLOBL(1,K) = GLOBL(2,K) + GLOBL(6,K)
   45  CONTINUE
       IF (LA.GT.J60) GO TO 55
       DO 50 K=1,KK
        GLOBL(3,K) = GLOBL(3,K) + WGT(LA)*Y(K,LA)
        GLOBL(7,K) = GLOBL(7,K) + WGT(LA)*Y(K,LD+1-LA)
   50  CONTINUE
       GO TO 75
   55  IF (LA.GT.J30) GO TO 65
       DO 60 K=1,KK
        GLOBL(4,K) = GLOBL(4,K) + WGT(LA)*Y(K,LA)
        GLOBL(8,K) = GLOBL(8,K) + WGT(LA)*Y(K,LD+1-LA)
   60  CONTINUE
       GO TO 75
   65  DO 70 K=1,KK
        GLOBL(5,K) = GLOBL(5,K) + WGT(LA)*Y(K,LA)
        GLOBL(9,K) = GLOBL(9,K) + WGT(LA)*Y(K,LD+1-LA)
   70  CONTINUE
   75 CONTINUE
      DO 85 K=1,KK
        GLOBX(1,K) = GLOBL(1,K) / WTSUM(1)
        GLOBL(1,K) = GLOBL(1,K) / WTSUM(1)
        DO 80 I=2,5
          GLOBX(I,K) = GLOBL(I,K) / WTSUM(1)
          GLOBX(I+4,K) = GLOBL(I+4,K) / WTSUM(1)
          GLOBL(I,K) = GLOBL(I,K) / WTSUM(I)
          GLOBL(I+4,K) = GLOBL(I+4,K) / WTSUM(I)
   80   CONTINUE
   85 CONTINUE
      PRINT 92,LTITL,FHOUR
      PRINT 93
      PRINT 97
      PRINT 95
      DO 90 KEN=1,KK
        K = KK+1-KEN
        PRINT 100,K,(GLOBL(I,K),I=1,9)
   90 CONTINUE
      PRINT 98
      PRINT 95
      DO 11 KEN=1,KK
        K = KK+1-KEN
        PRINT 100,K,(GLOBX(I,K),I=1,9)
   11 CONTINUE
      RETURN
   92 FORMAT (1H ,10X,' AREA WEIGHTED MEANS',2X,A20,' FCSTHR=',F6.1)
   93 FORMAT (1H ,11X,' -------------------------------------')
   95 FORMAT (1H ,4X,'K',5X,'GLOBAL',4X,'N HEMI',4X,'NHPOLR',4X,
     1        'NHMIDL',4X,'NHTRPC',4X,'S HEMI',4X,
     2        'SHPOLR',4X,'SHMIDL',4X,'SHTRPC')
   97 FORMAT (1H ,15X,'====>  WEIGHTED RELATIVE TO SPECIFIED REGION')
   98 FORMAT (1H ,15X,'====>  WEIGHTED RELATIVE TO ENTIRE GLOBE')
  100 FORMAT (1H ,I5,9F10.3)
  200 PRINT 201
      STOP
  205 PRINT 206
      STOP
  201 FORMAT (1H ,' STOP -- CAN T FIND J60')
  206 FORMAT (1H ,' STOP -- CAN T FIND J30')
      END
      SUBROUTINE PRNTLL(Y,THOUR,ITITL,KMAX)
      DIMENSION Y(KMAX,18)
      CHARACTER*44 ITITL
      PRINT 930
      PRINT 910,THOUR,ITITL
      DO 10 K=1,KMAX
        KK = KMAX +1 -K
        PRINT 920,KK,(Y(KK,LAT), LAT = 1,18)
  10  CONTINUE
      PRINT 930
 910  FORMAT(/,' FCST HOUR=',F4.0,' EQUI-DIST LAT BELT AVE=N.POLE TO',
     1 ' S.POLE ',A44)
 920  FORMAT(I3,2X,18F7.3)
 930  FORMAT(1H ,128(1H- ) )
      RETURN
      END
      SUBROUTINE CLINTF(CVIN,IIN,JTWIDL,JIN,
     1                  CVOUT,IOUT,JPOUT,JOUT,LEVS,
     2                  ILEFT,IRGHT,WGTLON,INSLAT,WGTLAT,
     3                  XX,WGT,SUM,NN,
     4                  LTWIDL,LATRD1,LATINB)
C--   *****************************************************************
C     *  CODE BILINEARLY INTERPOLATES CLD AMT BETWEEN GAUSSIAN GRIDS--*
C     *  CLONE OF CVINTF FOR INTERPOLATION..TOPS,BASES NOT DONE       *
C-    *  J = 1 IS JUST BELO N.POLE, I = 1 IS GREENWICH (THEN GO EAST).*
C     * IIN,JIN ARE I,J DIMENSIONS OF INPUT GRID--IOUT,JOUT FOR OUTPUT*
C     * JIN2,JOUT2=JIN/2,JOUT/2                                       *
C     *                                     --K.CAMPANA - SEPT 1994   *
C--   *****************************************************************
      DIMENSION CVIN(IIN,LEVS,JTWIDL)
      DIMENSION CVOUT(IOUT,LEVS,JPOUT)
      DIMENSION ILEFT(IOUT),IRGHT(IOUT),WGTLON(IOUT)
      DIMENSION INSLAT(JOUT),WGTLAT(JOUT)
      DIMENSION XX(IOUT,4),WGT(IOUT,4),SUM(IOUT,2)
      DIMENSION NN(IOUT)
      III = IIN
      JBB = JTWIDL
      JJJ = JIN
      IIIOUT = IOUT
      LBB = LTWIDL
      LR1 = LATRD1
      DO 50 LATOUT=1,JPOUT
       LAT=LATOUT+LATINB-1
CCC     PRINT 100,LAT,XLAT
C===>    IF OUTPUT LAT IS POLEWARD OF INPUT LAT=1 ,THEN SIMPL AVERAGE
C          (SMALL REGION AND CLD AMT WOULDN T EXTRAPOLATE WELL)
       CALL CLDIN(III,JBB,JJJ,IIIOUT,
     1            ILEFT,IRGHT,WGTLON,INSLAT(LAT),WGTLAT(LAT),
     2            CVIN,CVOUT(1,1,LATOUT),LEVS,
     3            XX,WGT,SUM,NN,LBB,LR1)
   50 CONTINUE
CK100 FORMAT(1H ,' ROW =',I5,'  LAT =',E15.5)
      RETURN
      END
      SUBROUTINE CLDIN(IIN,JTWIDL,JIN,IOUT,
     1                 ILEFT,IRGHT,WGTLON,INSLAT,WGTLAT,
     2                 CV,CAMT,LEVS,
     3                 XX,WGT,SUM,NN,LTWIDL,LATRD1)
      DIMENSION CV(IIN,LEVS,JTWIDL)
      DIMENSION CAMT(IOUT,LEVS)
      DIMENSION ILEFT(IOUT),IRGHT(IOUT),WGTLON(IOUT)
      DIMENSION XX(IOUT,4),WGT(IOUT,4),SUM(IOUT,2)
      DIMENSION NN(IOUT)
C...    CLONE OF CINTP WITHOUT DOING CLD TOPS AND BASES.....
C        SIMPL LINEAR INTERPOLATION OF CLDAMT, UNLESS ONLY 1,2 OF THE
C         SURROUNDING PTS HAS CL. THEN,IF OUTPUT GRIDPT NOT CLOSE ENUF
C         DO NOT INTERPOLATE TO IT(PREVENTS SPREADING OF CLDS)..
C           FOR 1 PT CLOUD AMT -INTRP WGT GE (.7)**2 ...
C           FOR 2 PT CLOUD AMT -SUM OF INTRP WGT GE .45...
C              .45 USED RATHER THAN .5 TO GIVE BETTER RESULT FOR
C              DIAGONALLY OPPOSED PTS...
C---     NHSH = 1,-1 FOR NORTHERN,SOUTHERN HEMISPHERE
C         HERE INSTEAD OF AN EXTRAPOLATION,JUST DO A SIMPLE MEAN....
C
C---   POLAR REGIONS,NO EXTRAP (INSLAT < 0)
      IF (INSLAT.LT.0) GO TO 600
      INTH = MOD(LTWIDL + INSLAT - LATRD1 - 1,JTWIDL) + 1
      INTH1 = MOD(INTH,JTWIDL) + 1
      DO 1000 KEN=1,LEVS
       IF (INSLAT.EQ.JIN) GO TO 105
       DO 100 I=1,IOUT
C----   NORMALIZED DISTANCE FROM UPPER LAT TO GAUSSIAN LAT
        XX(I,1) = CV(ILEFT(I),KEN,INTH)
        XX(I,2) = CV(ILEFT(I),KEN,INTH1)
        XX(I,3) = CV(IRGHT(I),KEN,INTH)
        XX(I,4) = CV(IRGHT(I),KEN,INTH1)
        WGT(I,1) = (1.#E 0-WGTLON(I))*(1.#E 0-WGTLAT)
        WGT(I,2) = (1.#E 0-WGTLON(I))*WGTLAT
        WGT(I,3) = WGTLON(I)*(1.#E 0-WGTLAT)
        WGT(I,4) = WGTLON(I)*WGTLAT
  100  CONTINUE
      GO TO 130
  105  DO 110 I=1,IOUT
C----   NORMALIZED DISTANCE FROM UPPER LAT TO GAUSSIAN LAT
        XX(I,1) = CV(ILEFT(I),KEN,INTH)
        XX(I,3) = CV(IRGHT(I),KEN,INTH)
        WGT(I,1) = (1.#E 0-WGTLON(I))*(1.#E 0-WGTLAT)
        WGT(I,2) = (1.#E 0-WGTLON(I))*WGTLAT
        WGT(I,3) = WGTLON(I)*(1.#E 0-WGTLAT)
        WGT(I,4) = WGTLON(I)*WGTLAT
  110  CONTINUE
       IOUT2 = IOUT / 2
       DO 120 I=1,IOUT2
        XX(I,2) = CV(ILEFT(I+IOUT2),KEN,INTH)
        XX(I+IOUT2,2) = CV(ILEFT(I),KEN,INTH)
        XX(I,4) = CV(IRGHT(I+IOUT2),KEN,INTH)
        XX(I+IOUT2,4) = CV(IRGHT(I),KEN,INTH)
  120  CONTINUE
C---      NN WILL BE NUMBER OF SURROUNDING PTS WITH CLD (GT ZERO)
  130  DO 10 I=1,IOUT
        NN(I) = 0
   10  CONTINUE
       DO 12 J=1,2
        DO 12 I=1,IOUT
         SUM(I,J) = 0.#E0
   12  CONTINUE
        DO 150 KPT=1,4
          DO 14 I=1,IOUT
            IF (XX(I,KPT).GT.0.#E0) THEN
              NN(I) = NN(I) + 1
              SUM(I,1) = SUM(I,1) + WGT(I,KPT)
            ENDIF
   14     CONTINUE
          DO 15 I=1,IOUT
            SUM(I,2) = SUM(I,2) + WGT(I,KPT) * XX(I,KPT)
   15     CONTINUE
  150   CONTINUE
        DO 16 I=1,IOUT
          IF (NN(I).EQ.1.AND.SUM(I,1).GT.0.49#E0) GO TO 17
          IF (NN(I).EQ.2.AND.SUM(I,1).GE.0.45#E0) GO TO 17
          IF (NN(I).GE.3) GO TO 17
            CAMT(I,KEN) = 0.#E0
            GO TO 18
   17     CONTINUE
            CAMT(I,KEN) = SUM(I,2)
   18     CONTINUE
   16   CONTINUE
 1000  CONTINUE
      RETURN
C--- POLAR REGION-NO EXTRAPOLATION
  600 CONTINUE
      JA = IABS(INSLAT)
      DO 2000 KEN=1,LEVS
       DO 200 I=1,IOUT
C----    GET LEFT POINT ON NEAREST LATITUDE
        XX(I,1) = CV(ILEFT(I),KEN,JA)
        XX(I,2) = CV(IRGHT(I),KEN,JA)
        WGT(I,1) = 1.#E 0-WGTLON(I)
        WGT(I,2) = WGTLON(I)
  200 CONTINUE
C---      NN WILL BE NUMBER OF SURROUNDING PTS WITH CLD (GT ZERO)
      DO 20 I=1,IOUT
        NN(I) = 0
   20 CONTINUE
      DO 22 J=1,2
       DO 22 I=1,IOUT
        SUM(I,J) = 0.#E0
   22 CONTINUE
        DO 202 KPT=1,2
          DO 24 I=1,IOUT
            IF (XX(I,KPT).GT.0.#E0) THEN
              NN(I) = NN(I) + 1
              SUM(I,1) = SUM(I,1) + WGT(I,KPT)
            ENDIF
   24     CONTINUE
          DO 25 I=1,IOUT
            SUM(I,2) = SUM(I,2) + WGT(I,KPT) * XX(I,KPT)
   25     CONTINUE
  202   CONTINUE
        DO 26 I=1,IOUT
          IF (NN(I).EQ.1.AND.SUM(I,1).GT.0.7#E0) GO TO 27
          IF (NN(I).EQ.2) GO TO 27
            CAMT(I,KEN) = 0.#E0
            GO TO 28
   27     CONTINUE
            CAMT(I,KEN) = SUM(I,2)
   28     CONTINUE
   26   CONTINUE
 2000 CONTINUE
      RETURN
      END
      SUBROUTINE CVINTF(CVIN,CVTIN,CVBIN,IIN,JTWIDL,JIN,
     1                  CVOUT,CVTOUT,CVBOUT,IOUT,JPOUT,JOUT,
     2                  ILEFT,IRGHT,WGTLON,INSLAT,WGTLAT,
     3                  XX,WGT,TT,BB,SUM,NN,
     4                  LTWIDL,LATRD1,LATINB)
C--   *****************************************************************
C     *  CODE BILINEARLY INTERPOLATES CLD AMT BETWEEN GAUSSIAN GRIDS--*
C     *  CLONE OF GGINTP FOR INTERPOLATION OF CONVECTIVE CLD AMT (CV).*
C     *    SPECIAL INTERP PROCEDURE FOR TOPS(CVT) AND BOTS(CVB)...    *
C-    *  J = 1 IS JUST BELO N.POLE, I = 1 IS GREENWICH (THEN GO EAST).*
C     * IIN,JIN ARE I,J DIMENSIONS OF INPUT GRID--IOUT,JOUT FOR OUTPUT*
C     * JIN2,JOUT2=JIN/2,JOUT/2                                       *
C     *                                     --K.CAMPANA - JUNE 1988   *
C--   *****************************************************************
      DIMENSION CVIN(IIN,JTWIDL),CVTIN(IIN,JTWIDL),CVBIN(IIN,JTWIDL)
      DIMENSION CVOUT(IOUT,JPOUT)
      DIMENSION CVTOUT(IOUT,JPOUT),CVBOUT(IOUT,JPOUT)
      DIMENSION ILEFT(IOUT),IRGHT(IOUT),WGTLON(IOUT)
      DIMENSION INSLAT(JOUT),WGTLAT(JOUT)
      DIMENSION XX(IOUT,4),WGT(IOUT,4),TT(IOUT,4),BB(IOUT,4),SUM(IOUT,4)
      DIMENSION NN(IOUT)
      III = IIN
      JBB = JTWIDL
      JJJ = JIN
      IIIOUT = IOUT
      LBB = LTWIDL
      LR1 = LATRD1
      DO 50 LATOUT=1,JPOUT
       LAT=LATOUT+LATINB-1
CCC     PRINT 100,LAT,XLAT
C===>    IF OUTPUT LAT IS POLEWARD OF INPUT LAT=1 ,THEN SIMPL AVERAGE
C          (SMALL REGION AND CLD AMT WOULDN T EXTRAPOLATE WELL)
       CALL CINTP(III,JBB,JJJ,IIIOUT,
     1            ILEFT,IRGHT,WGTLON,INSLAT(LAT),WGTLAT(LAT),
     2            CVIN,CVTIN,CVBIN,CVOUT(1,LATOUT),
     3            CVTOUT(1,LATOUT),CVBOUT(1,LATOUT),
     3            XX,WGT,TT,BB,SUM,NN,LBB,LR1)
   50 CONTINUE
CK100 FORMAT(1H ,' ROW =',I5,'  LAT =',E15.5)
      RETURN
      END
      SUBROUTINE CINTP(IIN,JTWIDL,JIN,IOUT,
     1                 ILEFT,IRGHT,WGTLON,INSLAT,WGTLAT,
     2                 CV,CVT,CVB,CAMT,CTOP,CBOT,
     3                 XX,WGT,TT,BB,SUM,NN,LTWIDL,LATRD1)
      DIMENSION CV(IIN,JTWIDL),CVT(IIN,JTWIDL),CVB(IIN,JTWIDL)
      DIMENSION CAMT(IOUT),CTOP(IOUT),CBOT(IOUT)
      DIMENSION ILEFT(IOUT),IRGHT(IOUT),WGTLON(IOUT)
      DIMENSION XX(IOUT,4),WGT(IOUT,4),TT(IOUT,4),BB(IOUT,4),SUM(IOUT,4)
      DIMENSION NN(IOUT)
C        SIMPL LINEAR INTERPOLATION OF CLDAMT, UNLESS ONLY 1,2 OF THE
C         SURROUNDING PTS HAS CV. THEN,IF OUTPUT GRIDPT NOT CLOSE ENUF
C         DO NOT INTERPOLATE TO IT(PREVENTS SPREADING OF CV CLDS)..
C           FOR 1 PT CONVECTION-INTRP WGT GE (.7)**2 ...
C           FOR 2 PT CONVECTION-SUM OF INTRP WGT GE .45...
C              .45 USED RATHER THAN .5 TO GIVE BETTER RESULT FOR
C              DIAGONALLY OPPOSED PTS...
C===>    FOR TOPS(CVT) AND BOTS(CVB) JUST TAKE AVERAGE OF SURROUNDING
C         NON-ZERO CV POINTS.....
C         NN WILL BE NUMBER OF SURROUNDING PTS WITH CLD (GT ZERO)
C---     NHSH = 1,-1 FOR NORTHERN,SOUTHERN HEMISPHERE
C         HERE INSTEAD OF AN EXTRAPOLATION,JUST DO A SIMPLE MEAN....
C
      IF (INSLAT.LT.0) GO TO 600
      INTH = MOD(LTWIDL + INSLAT - LATRD1 - 1,JTWIDL) + 1
      INTH1 = MOD(INTH,JTWIDL) + 1
      IF (INSLAT.EQ.JIN) GO TO 105
      DO 100 I=1,IOUT
C----   NORMALIZED DISTANCE FROM UPPER LAT TO GAUSSIAN LAT
        XX(I,1) = CV(ILEFT(I),INTH)
        XX(I,2) = CV(ILEFT(I),INTH1)
        XX(I,3) = CV(IRGHT(I),INTH)
        XX(I,4) = CV(IRGHT(I),INTH1)
        WGT(I,1) = (1.#E 0-WGTLON(I))*(1.#E 0-WGTLAT)
        WGT(I,2) = (1.#E 0-WGTLON(I))*WGTLAT
        WGT(I,3) = WGTLON(I)*(1.#E 0-WGTLAT)
        WGT(I,4) = WGTLON(I)*WGTLAT
        TT(I,1) = CVT(ILEFT(I),INTH)
        TT(I,2) = CVT(ILEFT(I),INTH1)
        TT(I,3) = CVT(IRGHT(I),INTH)
        TT(I,4) = CVT(IRGHT(I),INTH1)
        BB(I,1) = CVB(ILEFT(I),INTH)
        BB(I,2) = CVB(ILEFT(I),INTH1)
        BB(I,3) = CVB(IRGHT(I),INTH)
        BB(I,4) = CVB(IRGHT(I),INTH1)
  100 CONTINUE
      GO TO 130
  105 DO 110 I=1,IOUT
C----   NORMALIZED DISTANCE FROM UPPER LAT TO GAUSSIAN LAT
        XX(I,1) = CV(ILEFT(I),INTH)
        XX(I,3) = CV(IRGHT(I),INTH)
        WGT(I,1) = (1.#E 0-WGTLON(I))*(1.#E 0-WGTLAT)
        WGT(I,2) = (1.#E 0-WGTLON(I))*WGTLAT
        WGT(I,3) = WGTLON(I)*(1.#E 0-WGTLAT)
        WGT(I,4) = WGTLON(I)*WGTLAT
        TT(I,1) = CVT(ILEFT(I),INTH)
        TT(I,3) = CVT(IRGHT(I),INTH)
        BB(I,1) = CVB(ILEFT(I),INTH)
        BB(I,3) = CVB(IRGHT(I),INTH)
  110 CONTINUE
      IOUT2 = IOUT / 2
      DO 120 I=1,IOUT2
        XX(I,2) = CV(ILEFT(I+IOUT2),INTH)
        XX(I+IOUT2,2) = CV(ILEFT(I),INTH)
        XX(I,4) = CV(IRGHT(I+IOUT2),INTH)
        XX(I+IOUT2,4) = CV(IRGHT(I),INTH)
        BB(I,2) = CVB(ILEFT(I+IOUT2),INTH)
        BB(I+IOUT2,2) = CVB(ILEFT(I),INTH)
        BB(I,4) = CVB(IRGHT(I+IOUT2),INTH)
        BB(I+IOUT2,4) = CVB(IRGHT(I),INTH)
        TT(I,2) = CVT(ILEFT(I+IOUT2),INTH)
        TT(I+IOUT2,2) = CVT(ILEFT(I),INTH)
        TT(I,4) = CVT(IRGHT(I+IOUT2),INTH)
        TT(I+IOUT2,4) = CVT(IRGHT(I),INTH)
  120 CONTINUE
C---      NN WILL BE NUMBER OF SURROUNDING PTS WITH CLD (GT ZERO)
CKAC    NN(1;IOUT) = 0
CKAC    SUM(1,1;IOUT*4) = 0.#E 0
  130 DO 10 I=1,IOUT
        NN(I) = 0
   10 CONTINUE
      DO 12 J=1,4
       DO 12 I=1,IOUT
        SUM(I,J) = 0.#E0
   12 CONTINUE
        DO 150 KPT=1,4
CKAC      WHERE (XX(1,KPT;IOUT).GT.0.#E 0)
CKAC        NN(1;IOUT) = NN(1;IOUT) + 1
CKAC        SUM(1,1;IOUT) = SUM(1,1;IOUT) + WGT(1,KPT;IOUT)
CKAC        SUM(1,2;IOUT) = SUM(1,2;IOUT) + TT(1,KPT;IOUT)
CKAC        SUM(1,3;IOUT) = SUM(1,3;IOUT) + BB(1,KPT;IOUT)
CKAC      ENDWHERE
CKAC      SUM(1,4;IOUT) = SUM(1,4;IOUT) + WGT(1,KPT;IOUT) *
CKAC 1                    XX(1,KPT;IOUT)
          DO 14 I=1,IOUT
            IF (XX(I,KPT).GT.0.#E0) THEN
              NN(I) = NN(I) + 1
              SUM(I,1) = SUM(I,1) + WGT(I,KPT)
              SUM(I,2) = SUM(I,2) + TT(I,KPT)
              SUM(I,3) = SUM(I,3) + BB(I,KPT)
            ENDIF
   14     CONTINUE
          DO 15 I=1,IOUT
            SUM(I,4) = SUM(I,4) + WGT(I,KPT) * XX(I,KPT)
   15     CONTINUE
  150   CONTINUE
CKAC    WHERE((NN(1;IOUT).EQ.1 .AND. SUM(1,1;IOUT).GT.0.49#E 0) .OR.
CKAC 1        (NN(1;IOUT).EQ.2 .AND. SUM(1,1;IOUT).GE.0.45#E 0) .OR.
CKAC 2         NN(1;IOUT).GE.3)
CKAC      CTOP(1;IOUT) = VAINT(SUM(1,2;IOUT)/NN(1;IOUT)+0.5#E 0;
CKAC 1                         CTOP(1;IOUT))
CKAC      CBOT(1;IOUT) = VAINT(SUM(1,3;IOUT)/NN(1;IOUT)+0.5#E 0;
CKAC 1                         CBOT(1;IOUT))
CKAC      CAMT(1;IOUT) = SUM(1,4;IOUT)
CKAC    OTHERWISE
CKAC      CTOP(1;IOUT) = 0.#E 0
CKAC      CBOT(1;IOUT) = 100.#E 0
CKAC      CAMT(1;IOUT) = 0.#E 0
CKAC    ENDWHERE
        DO 16 I=1,IOUT
          IF (NN(I).EQ.1.AND.SUM(I,1).GT.0.49#E0) GO TO 17
          IF (NN(I).EQ.2.AND.SUM(I,1).GE.0.45#E0) GO TO 17
          IF (NN(I).GE.3) GO TO 17
            CTOP(I) = 0.#E0
            CBOT(I) = 100.#E0
            CAMT(I) = 0.#E0
            GO TO 18
   17     CONTINUE
            LTOP = SUM(I,2)/NN(I) + 0.5#E0
            LBOT = SUM(I,3)/NN(I) + 0.5#E0
            CTOP(I) = LTOP
            CBOT(I) = LBOT
            CAMT(I) = SUM(I,4)
   18     CONTINUE
   16   CONTINUE
      RETURN
C--- POLAR REGION-NO EXTRAPOLATION
  600 CONTINUE
      JA = IABS(INSLAT)
      DO 200 I=1,IOUT
C----    GET LEFT POINT ON NEAREST LATITUDE
        XX(I,1) = CV(ILEFT(I),JA)
        XX(I,2) = CV(IRGHT(I),JA)
        WGT(I,1) = 1.#E 0-WGTLON(I)
        WGT(I,2) = WGTLON(I)
        TT(I,1) = CVT(ILEFT(I),JA)
        TT(I,2) = CVT(IRGHT(I),JA)
        BB(I,1) = CVB(ILEFT(I),JA)
        BB(I,2) = CVB(IRGHT(I),JA)
  200 CONTINUE
C---      NN WILL BE NUMBER OF SURROUNDING PTS WITH CLD (GT ZERO)
CKAC    NN(1;IOUT) = 0
CKAC    SUM(1,1;IOUT*4) = 0.#E 0
      DO 20 I=1,IOUT
        NN(I) = 0
   20 CONTINUE
      DO 22 J=1,4
       DO 22 I=1,IOUT
        SUM(I,J) = 0.#E0
   22 CONTINUE
        DO 202 KPT=1,2
CKAC      WHERE (XX(1,KPT;IOUT).GT.0.#E 0)
CKAC        NN(1;IOUT) = NN(1;IOUT) + 1
CKAC        SUM(1,1;IOUT) = SUM(1,1;IOUT) + WGT(1,KPT;IOUT)
CKAC        SUM(1,2;IOUT) = SUM(1,2;IOUT) + TT(1,KPT;IOUT)
CKAC        SUM(1,3;IOUT) = SUM(1,3;IOUT) + BB(1,KPT;IOUT)
CKAC      ENDWHERE
CKAC      SUM(1,4;IOUT) = SUM(1,4;IOUT) + WGT(1,KPT;IOUT) *
CKAC 1                    XX(1,KPT;IOUT)
          DO 24 I=1,IOUT
            IF (XX(I,KPT).GT.0.#E0) THEN
              NN(I) = NN(I) + 1
              SUM(I,1) = SUM(I,1) + WGT(I,KPT)
              SUM(I,2) = SUM(I,2) + TT(I,KPT)
              SUM(I,3) = SUM(I,3) + BB(I,KPT)
            ENDIF
   24     CONTINUE
          DO 25 I=1,IOUT
            SUM(I,4) = SUM(I,4) + WGT(I,KPT) * XX(I,KPT)
   25     CONTINUE
  202   CONTINUE
CKAC    WHERE((NN(1;IOUT).EQ.1 .AND. SUM(1,1;IOUT).GT.0.7#E 0) .OR.
CKAC 1         NN(1;IOUT).EQ.2)
CKAC      CTOP(1;IOUT) = VAINT(SUM(1,2;IOUT)/NN(1;IOUT)+0.5#E 0;
CKAC 1                         CTOP(1;IOUT))
CKAC      CBOT(1;IOUT) = VAINT(SUM(1,3;IOUT)/NN(1;IOUT)+0.5#E 0;
CKAC 1                         CBOT(1;IOUT))
CKAC      CAMT(1;IOUT) = SUM(1,4;IOUT)
CKAC    OTHERWISE
CKAC      CTOP(1;IOUT) = 0.#E 0
CKAC      CBOT(1;IOUT) = 100.#E 0
CKAC      CAMT(1;IOUT) = 0.#E 0
CKAC    ENDWHERE
        DO 26 I=1,IOUT
          IF (NN(I).EQ.1.AND.SUM(I,1).GT.0.7#E0) GO TO 27
          IF (NN(I).EQ.2) GO TO 27
            CTOP(I) = 0.#E0
            CBOT(I) = 100.#E0
            CAMT(I) = 0.#E0
            GO TO 28
   27     CONTINUE
            LTOP = SUM(I,2)/NN(I) + 0.5#E0
            LBOT = SUM(I,3)/NN(I) + 0.5#E0
            CTOP(I) = LTOP
            CBOT(I) = LBOT
            CAMT(I) = SUM(I,4)
   28     CONTINUE
   26   CONTINUE
      RETURN
      END
      SUBROUTINE COSZMN(DTSWAV,SOLHR,SINLAT,COSLAT,SDEC,CDEC,SLAG,
     1                  XLON,NLON2,NLAT2,COSZEN,LDG,COSZDG)
CFPP$ NOCONCUR R
C
C===>  COMPUTE MEAN COS SOLAR ZEN ANGL OVER DTSWAV HRS
C....   COSINE OF SOLAR ZEN ANGL FOR BOTH N. AND S. HEMISPHERES.
C        SOLHR=TIME(HRS) AFTER 00Z (GREENWICH TIME)..
C        XLON IS EAST LONG(RADIANS)..
C        SINLAT, COSLAT ARE SIN AND COS OF LATITUDE (N. HEMISPHERE)
C        SDEC, CDEC = THE SINE AND COSINE OF THE SOLAR DECLINATION.
C        SLAG = EQUATION OF TIME
      DIMENSION XLON(NLON2,NLAT2),COSZEN(NLON2,NLAT2)
      LOGICAL LDG
      DIMENSION COSZDG(NLON2,NLAT2)
      DIMENSION SINLAT(NLON2,NLAT2),COSLAT(NLON2,NLAT2)
      DIMENSION COSZN(NLON2),ISTSUN(NLON2)
      NSTP = 6
      ISTP = NSTP*DTSWAV
      PID12 = (2.#E0 * ASIN(1.#E0)) / 12.#E0
C----
      DO 2000 J=1,NLAT2
        DO 20 I=1,NLON2
          COSZEN(I,J) = 0.#E0
          ISTSUN(I) = 0
   20   CONTINUE
      DO 1000 IT=1,ISTP
       CNS = PID12 * (SOLHR-12.#E0+(IT-1)*1.#E0/NSTP) +SLAG
       DO 40 I=1,NLON2
         SS=SINLAT(I,J)*SDEC
         CC=COSLAT(I,J)*CDEC
         COSZN(I) = SS + CC * COS(CNS + XLON(I,J))
CX       COSZN(I) = SINLAT(I,J)*SDEC +
CX   1              COSLAT(I,J)*CDEC * COS(CNS + XLON(I,J))
         COSZEN(I,J) = COSZEN(I,J) + AMAX1(0.#E0, COSZN(I))
         IF(COSZN(I).GT.0.#E0) ISTSUN(I) = ISTSUN(I) + 1
   40  CONTINUE
 1000 CONTINUE
       DO 1500 I=1,NLON2
        IF(LDG) COSZDG(I,J) = COSZEN(I,J) / ISTP
        IF(ISTSUN(I).GT.0) COSZEN(I,J) = COSZEN(I,J) / ISTSUN(I)
 1500  CONTINUE
 2000 CONTINUE
      RETURN
      END
      SUBROUTINE GCLJMS (SI)
      PARAMETER (KDIM=#LEVS, KDIMP=KDIM+1)
      COMMON /COMCD1/ ROCP,PTOPC(4,2),CVTOP,VVCLD(2),CLAPSE
     1,               CRHRH,KLOWT,KLOWB,PSTRT
     2,               LLYR,CLAPKC,DCLPS,CLPSE
      DIMENSION SI(KDIMP), PPPTOP(4,2)
C --- PRESSURE LIMITS FOR SFC AND TOP OF EACH CLOUD DOMAIN (L,M,H)
C     IN MB, MODEL LAYERS FOR CLD TOPS ARE L=7,M=11,H=15 AT LOW
C     LATITUDES AND L= ,M= ,H=  , AT POLE REGION.
C....     PTOP ABOVE H CHANGED FROM 150 TO 100, CAUSE
CC    DATA PPPTOP /1050.,642.,350.,150., 1050.,750.,500.,150./
C          CODE WAS TRUNCATING TOPS OF CONVECTIVE CLOUDS
      DATA PPPTOP /1050.,642.,350.,100., 1050.,750.,500.,100./
C
      ROCP = #RD / #CP
C --- INVERSON TYPE CLD CRITICAL VALUE-ISTRAT=0
CYH94 CLAPSE = -0.055#E0
      CLAPSE = -0.06#E0
C --- INVERSON TYPE CLD CRITICAL VALUE-ISTRAT=1
      CLAPKC = -0.05#E0
C....CRITICAL DTHETA/DP FOR OCEAN STRATUS(WGT VARIES 0 TO 1
C                LINEARLY FROM CLAPSE TO CLPSE)
      DCLPS = -0.01#E0
      CLPSE = CLAPKC + DCLPS
      CVTOP = 400.0#E0
      PSTRT = 800.0#E0
C --- LOW CLD BOTTOM (AT SIGMA=0.95) AND TOP SIGMA LEVEL
      DO 5 K=1,KDIM
        KK=K
        IF (SI(KK) .LE. 0.95#E0) GO TO 10
   5  CONTINUE
  10  KLOWB = KK - 1
      SILOW = PPPTOP(2,1) * 1.0#E-3
      DO 20 K=1,KDIM
        KK=K
        IF (SI(KK) .LT. SILOW) GO TO 30
  20  CONTINUE
  30  KLOWT = KK
C --- PRESURE LIMIT AT SFC AND AT TOP OF CLOUD DOMAINS (L,M,H) IN MB
      DO 40 J=1,2
      DO 40 I=1,4
       PTOPC(I,J) = PPPTOP(I,J)
  40  CONTINUE
C --- L CLD VERTICAL VEL ADJ BOUNDARIES
      VVCLD(1) =  0.0003#E0
      VVCLD(2) = -0.0005#E0
      CRHRH = 0.60#E0
C--- COMPUTE LLYR--WHICH IS TOPMOST NON CLD(LOW) LAYER, FOR STRATIFORM
      XTHK = 0.#E0
C....   DEFAULT LLYR
      KL = KDIMP
C....   TOPMOST NONCLOUD LAYER WILL BE THE ONE AT OR ABOVE LOWEST
C         0.1 OF THE ATMOSPHERE..
      DO 202 K=1,KDIM
C       XTHK = XTHK + SI(K) - SI(K+1)
C       IF (XTHK.LT.0.1#E0) GO TO 202
        KL = K
C       GO TO 204
        IF (SI(K).LT.0.9#E0) GO TO 204
  202 CONTINUE
  204 LLYR = KL-1
      PRINT 205,LLYR,KLOWB
  205 FORMAT(1H ,'-------LLYR,KLOWB =',2I5)
      RETURN
      END
      SUBROUTINE CLDPRP(IDIMT,IDIMS,PS,Q,T,SI,CLDARY,IBEG,IPTS,XLATRD,
     1                  CAMT,KTOP,KBTM,NCLDS,EMIS,RRCL,TTCL)
CFPP$ NOCONCUR R
C---------------------------------------------------------------------
C     FEB., 1993 - Y.H.
C        CLOUD RADIATIVE PROPERTIES CALCULATIONS AFTER DAVIS (1982)
C        AND HARSHVARDHAN ET AL. (1987).
C--------------------------------------------------------------------
C     INPUT VARIABLES:
C        PS(I)         - SURFACE PRESSURE (CB)
C        Q (I,K)       - SPECIFIC HUMIDITY, K=1 IS TOP LAYER (KG/KG)
C        T (I,K)       - ABSOLUTE TEMPERATURE, K=1 IS TOP LAYER (K)
C        SI(K)         - MDL SIGMA INTERFACES, K=1 IS THE SURFACE
C        CLDARY(I,K)   - CLOUD ARRAY CONTAINS COMPRESSED CLOUD
C                        FRACTIONS OF 3 TYPES (STRATIFORM, CONV
C                        AND STRATUS), K=1 IS THE MDL SFC LAYER
C        IBEG,IPTS     - INDICES FOR THE BEGINNIG NO. AND THE
C                        TOTAL NO. OF ARRAY ELEMENTS TO BE PROCESSED
C ----- MODIFY XLATRD TO GENERAL FOR REGIONAL AND GLOBAL (H.-M.H. JUANGK
C********XLATRD        - CURRENT LATITUDE IN RADIANS (1ST DATA PT)
C********                 FOR MODELS WITH DIFF LAT AT EACH PT, NEED TO
C********                 USE THE LAT OF EACH POINT....CAREFUL.....
C    OUTPUT VARIABLES:
C    OUTPUT VARIABLES:
C        CAMT(I,K)     - CLOUD FRACTIONS, K=1 IS THE SFC, K=2 IS THE
C                        LOWEST CLOUD LAYER, AND SO ON
C        KTOP,KBTM(I,K)- CLOUD TOP AND BOTTOM INDECES, KTOP AND
C                        KBTM VALUES FROM 1 TO L MODEL LAYERS,
C                        WITH VALUE OF 1 BEING THE TOP MDL LAYER
C        NCLDS(I)      - NO. OF SEPARATED CLOUD LAYERS IN A COLUMN
C        EMIS(I,K)     - CLOUD EMISSIVITY
C  ***   ITYP(I,K)     - TYPE OF CLOUDS, ITYP=1, 2 AND 3 ARE FOR
C                        THE RH, STRATUS, AND CONV TYPES
C        RRCL,TTCL(I,NB,K)
C                      - CLOUD REFLECTTANCES, AND TRANSMITANCES FOR
C                        SW SPECTRAL BANDS
C
C--------------------------------------------------------------------
C
  % INCLUDE RDPARM ;
                      D I M E N S I O N
     1  PS  (IDIMS),     SI  (LP1),       CLDARY(IDIMT,L)
     2, Q   (IMBX,L),      T   (IMBX,LP1),    CAMT(IMBX,LP1)
     3, KTOP(IMBX,LP1),    KBTM(IMBX,LP1),    EMIS(IMBX,LP1)
     4, ITYP(IMBX,LP1),    RRCL(IMBX,NB,LP1), TTCL(IMBX,NB,LP1)
     5, NCLDS(IMAX),     XLATRD(IDIMT)
C
      COMMON /COMCD1/ ROCP,PTOPC(4,2),CVTOP,VVCLD(2),CLAPSE
     1,               CRHRH,KLOWT,KLOWB,PSTRT
     2,               LLYR,CLAPKC,DCLPS,CLPSE
C
C --- ABCFF(NB) : NB BANDS ABSORPTION COEFF FOR WATER VAPOR
C
      COMMON /SWRSAV/ ABCFF(NB),PWTS(NB),CFCO2,CFO3,REFLO3,RRAYAV
C
C ---  WORKSPACE ---
                      D I M E N S I O N
     1  PRSLV(IMBX,LP1),MTYP (IMAX),      XAMT (IMAX)
     2, KCLD (IMAX),    MBTM (IMAX),      CL1  (IMAX)
     3, CL2  (IMAX),    QSUM (IMAX)
     4, MIDK (IMAX),    DELP (IMAX),      TCLD (IMAX)
     5, TAUC (IMAX),    PTOPD(IMAX)
                    E Q U I V A L E N C E
     1  (TCLD, CL1), (DELP, CL2), (TAUC, MBTM), (XAMT, PTOPD)
                        L O G I C A L
     1  BITX(IMAX),   BITW(IMAX),  BIT1,   BIT2
C===>    BEGIN HERE ................................................
      DO 10 K=2,LP1
      DO 10 I=1,IPTS
        IR = I + IBEG - 1
        PRSLV(I,K) = PS(IR) * SI(LP1-K+1) * 10.0#E0
  10  CONTINUE
      DO 20 I=1,IMAX
        PRSLV(I,1) = 0.001#E0
        KCLD(I) = 2
        MBTM(I) = 1
        MTYP(I) = 0
        XAMT(I) = 0.0#E0
        ITYP(I,1) = 0
        CAMT(I,1) = 1.0#E0
        KTOP(I,1) = LP1
        KBTM(I,1) = LP1
        EMIS(I,1) = 1.0#E0
  20  CONTINUE
      DO 30 K=2,LP1
      DO 30 I=1,IMAX
        ITYP(I,K) = 0
        CAMT(I,K) = 0.0#E0
        KTOP(I,K) = 1
        KBTM(I,K) = 1
        EMIS(I,K) = 0.0#E0
  30  CONTINUE
      DO 40 K=1,LP1
      DO 40 J=1,NB
      DO 40 I=1,IMAX
        RRCL(I,J,K) = 0.0#E0
        TTCL(I,J,K) = 1.0#E0
  40  CONTINUE
C
C --- LOOP OVER MDL LAYERS
C
      DO 200 K=2,L
C
        BIT1 = .FALSE.
        DO 60 I=1,IPTS
          IR = I + IBEG - 1
          BITX(I) = CLDARY(IR,K).GT.0.0#E0
          BIT1 = BIT1 .OR. BITX(I)
  60    CONTINUE
        IF (.NOT. BIT1) GO TO 200
C --- DECOMPRESS CLOUD ARRAY
        DO 70 I=1,IPTS
          CL1(I) = 0.0#E0
          CL2(I) = 0.0#E0
          BITW(I) = BITX(I)
  70    CONTINUE
        DO 80 I=1,IPTS
          IF (BITX(I)) THEN
            IR = I + IBEG - 1
            CL1(I) = AMOD(CLDARY(IR,K), 2.0#E0)
            CLTEMP = AMOD(CLDARY(IR,K), 10.0#E0)
            CL2(I) = 1.0#E-4 * (CLDARY(IR,K) - CLTEMP)
C --- MTYP=1,2 FOR RH+STRATUS, AND CONV CLOUD TYPES
            IF (CL2(I) .GT. 0.0#E0) THEN
              MTYP(I) = 2
            ELSE
              MTYP(I) = 1
            END IF
          END IF
  80    CONTINUE
        IF(K.LT.L) THEN
          DO 100 I=1,IPTS
            IR = I + IBEG - 1
            IF(BITW(I)) THEN
              BITW(I) = CLDARY(IR,K+1).LE.0.0#E0
            ENDIF
 100      CONTINUE
        ENDIF
        BIT2 = .FALSE.
        DO 110 I=1,IPTS
          BIT2 = BIT2 .OR. BITW(I)
          IF (BITX(I)) THEN
            IF(ITYP(I,KCLD(I)).EQ.0) THEN
              ITYP(I,KCLD(I)) = MTYP(I)
              XAMT(I) = CL1(I)
              IF (MTYP(I) .EQ. 2) XAMT(I) = CL2(I)
              MBTM(I) = K
            ELSE IF(ITYP(I,KCLD(I)).NE.MTYP(I)) THEN
              CAMT(I,KCLD(I)) = XAMT(I)
              KTOP(I,KCLD(I)) = LP1 - (K - 1)
              KBTM(I,KCLD(I)) = LP1 - MBTM(I)
              ITYP(I,KCLD(I)+1) = MTYP(I)
              MBTM(I) = K
              XAMT(I) = CL1(I)
              IF (MTYP(I).EQ.2) XAMT(I) = CL2(I)
              KCLD(I) = KCLD(I) + 1
            ELSE IF(MTYP(I).EQ.1) THEN
              XAMT(I) = AMAX1(XAMT(I), CL1(I))
            ELSE IF(MTYP(I).EQ.2) THEN
              XAMT(I) = AMAX1(XAMT(I), CL2(I))
            ENDIF
          END IF
 110    CONTINUE
        IF (.NOT. BIT2) GO TO 200
        DO 160 I=1,IPTS
          IF (BITW(I)) THEN
            CAMT(I,KCLD(I)) = XAMT(I)
            KTOP(I,KCLD(I)) = LP1 - K
            KBTM(I,KCLD(I)) = LP1 - MBTM(I)
            KCLD(I) = KCLD(I) + 1
            MTYP(I) = 0
            MBTM(I) = 1
            XAMT(I) = 0.0#E0
          END IF
 160    CONTINUE
C
 200  CONTINUE
C --- RECORD NUM OF CLD LYRS AND FIND MAX NUM OF CLD LYRS
      MCLDS = 0
      DO 220 I=1,IPTS
        NCLDS(I) = KCLD(I) - 2
        MCLDS = MAX(MCLDS, NCLDS(I))
 220  CONTINUE
C     WRITE(6,231) MCLDS
C231  FORMAT(' IN CLDPRP: MAXCLDS =',I4)
C     IF (MCLDS .EQ. 0) RETURN
C
C --- ESTIMATE CLOUD OPTICAL PROPERTIES FROM T AND Q
C ---  THE 240-LOOP FLAGS MID/HI CLD USING PRESSURE DOMAIN BDRY, PTOP
C
C
      DO 500 NC=2,MCLDS+1
C
        DO 230 I=1,IPTS
          TAUC(I) = 0.0#E0
          QSUM(I) = 0.0#E0
          BITX(I) = CAMT(I,NC) .GT. 0.0#E0
 230    CONTINUE
C...  FIND TOP PRESSURE FOR MID CLOUD (3) DOMAIN=FUNCTION OF LATITUDE
        MINKTP=LP1
        MAXKBT=0
        DO 240 I=1,IPTS
          IR = I + IBEG - 1
          FAC = AMAX1(0.0#E0, 4.0#E0*ABS(XLATRD(IR))/#PI-1.0#E0)
          PTOPD(I) = PTOPC(3,1) + (PTOPC(3,2)-PTOPC(3,1)) * FAC
          MINKTP = MIN(MINKTP,KTOP(I,NC))
          MAXKBT = MAX(MAXKBT,KBTM(I,NC))
 240    CONTINUE
C --- CALC CLD THICKNESS DELP, TOTAL H2O PASS, AND MEAN TEMP (CELSIUS)
        DO 260 KK=MINKTP,MAXKBT
        DO 260 I=1,IPTS
          IF (KK.GE.KTOP(I,NC) .AND. KK.LE.KBTM(I,NC) .AND.BITX(I)) THEN
            DELP(I) = PRSLV(I,KK+1) - PRSLV(I,KK)
            TCLD(I) = T(I,KK) - 273.16#E0
            QSUM(I) = QSUM(I) + Q(I,KK) * DELP(I)
     1              * (PRSLV(I,KK+1) + PRSLV(I,KK))
     2              / (120.1612#E0 * SQRT(T(I,KK)))
            IF(PRSLV(I,KTOP(I,NC)+1).LE.PTOPD(I) .OR.
     1         ITYP(I,NC).EQ.2) THEN
C....     TOPS ARE HIGH OR CONVEC CLOUDS
              IF (TCLD(I) .LE. -10.0#E0) THEN
                TAUC(I) = TAUC(I) + DELP(I)
     1                  * AMAX1(0.1#E-3, 2.00#E-6*(TCLD(I)+82.5#E0)**2)
              ELSE
                TAUC(I) = TAUC(I) + DELP(I)
     1                  * AMIN1(0.08#E0, 6.949#E-3*TCLD(I)+0.10#E0)
              END IF
            ELSE
C....     TOPS ARE MID AND LOW NON-CONVEC CLOUDS
              IF (TCLD(I) .LE. -20.0#E0) THEN
                TAUC(I) = TAUC(I) + DELP(I)
     1                  * AMAX1(0.1#E-3,2.56#E-5*(TCLD(I)+82.5#E0)**2)
              ELSE
                TAUC(I) = TAUC(I) + DELP(I) * 0.10#E0
              END IF
            END IF
          END IF
 260    CONTINUE
C --- CALC CLD EMIS
        DO 320 I=1,IPTS
          IF (BITX(I))
     1      EMIS(I,NC) = 1.0#E0 - EXP(-0.75#E0*TAUC(I))
CYH       IF (BITX(I) .AND. ITYP(I,NC).EQ.2) EMIS(I,NC) = 1.0#E0
 320    CONTINUE
        DO 420 NBAND=1,NB
          DO 400 I=1,IPTS
            IF (BITX(I)) THEN
              DD = TAUC(I) / (TAUC(I)+ABCFF(NBAND)*QSUM(I))
              EE = 1.0#E0 - DD
              FF = 1.0#E0 - DD*0.85#E0
              AA = AMIN1( 50.0#E0,SQRT(3.0#E0*EE*FF)*TAUC(I) )
              AA = EXP(-AA)
              BB = FF / EE
              CC = SQRT(BB)
              DD = (CC + 1.0#E0)*(CC + 1.0#E0) -
     1             (CC - 1.0#E0)*(CC - 1.0#E0) * AA*AA
              RRCL(I,NBAND,NC) = AMAX1(0.1#E-5,
     1          (BB-1.0#E0)*(1.0#E0-AA*AA) / DD )
              TTCL(I,NBAND,NC) = AMAX1(0.1#E-5,4.0#E0 * CC * AA / DD )
            END IF
 400      CONTINUE
 420    CONTINUE
C
 500  CONTINUE
      IF (IPTS .EQ. IMAX) GO TO 565
      IPTS1 = IPTS + 1
      DO 520 I=IPTS1,IMAX
        NCLDS(I) = NCLDS(IPTS)
 520  CONTINUE
      DO 540 K=1,LP1
      DO 540 I=IPTS1,IMAX
        CAMT(I,K) = CAMT(IPTS,K)
        KTOP(I,K) = KTOP(IPTS,K)
        KBTM(I,K) = KBTM(IPTS,K)
        EMIS(I,K) = EMIS(IPTS,K)
 540  CONTINUE
      DO 560 K=1,LP1
      DO 560 N=1,NB
      DO 560 I=IPTS1,IMAX
        RRCL(I,N,K) = RRCL(IPTS,N,K)
        TTCL(I,N,K) = TTCL(IPTS,N,K)
 560  CONTINUE
 565  CONTINUE
C     DO 586 K=2,MCLDS+1
C       WRITE(6,581) K-1
C581    FORMAT(' IN CLDPRP: K=',I3,' CLD,EMIS,TOP,BOT:')
C       WRITE(6,582) (CAMT(I,K),EMIS(I,K),KTOP(I,K),KBTM(I,K),I=1,IMAX)
C582    FORMAT(6(2F6.3,2I4))
C       DO 585 N=1,NB
C         WRITE(6,583) N
C583      FORMAT(' NBAND =',I3,' TTCL,RRCL:')
C         WRITE(6,584) (TTCL(I,N,K),RRCL(I,N,K),I=1,IMAX)
C584      FORMAT(6(2E10.3))
C585    CONTINUE
C586  CONTINUE
C
      RETURN
      END
      SUBROUTINE CRHTAB(RHCL,IER)
C---------------------------------------------------------------------
C..  CLD-RH RELATIONS OBTAINED FROM MITCHELL-HAHN PROCEDURE, HERE READ
C     CLD/RH TUNING TABLES FOR DAY 0,1,...,5 AND MERGE INTO 1 FILE..
C                         .............K.A.C.   MAR 93
C     USE ONLY ONE TABLE (DAY 1) FOR ALL FCST HRS....K.A.C. FEB 94
C    OUTPUT:
C        RHCL - TUNING TABLES FOR ALL FORECAST DAYS
C        IER  - =1 IF TABLES AVAILABLE.. =-1 IF NO TABLES
C--------------------------------------------------------------------
CRH1T PARAMETER (MCLD=3,NSEAL=2,IDA=6,
      PARAMETER (MCLD=3,NSEAL=2,IDA=1,
     2           NBIN=100,NLON=2,NLAT=4)
      DIMENSION RHFD(NBIN,NLON,NLAT,MCLD,NSEAL)
      DIMENSION RRHFD(NBIN,NLON,NLAT,MCLD,NSEAL)
      DIMENSION RTNFFD(NBIN,NLON,NLAT,MCLD,NSEAL)
      DIMENSION RRNFFD(NBIN,NLON,NLAT,MCLD,NSEAL)
      DIMENSION RHCF(NBIN,NLON,NLAT,MCLD,NSEAL)
      DIMENSION RTNFCF(NBIN,NLON,NLAT,MCLD,NSEAL)
      DIMENSION KPTS(NLON,NLAT,MCLD,NSEAL)
      DIMENSION KKPTS(NLON,NLAT,MCLD,NSEAL)
      DIMENSION RHC(NLON,NLAT,MCLD,NSEAL)
      DIMENSION RHCL (NBIN,NLON,NLAT,MCLD,NSEAL,IDA)
      DIMENSION ICDAYS(15),IDATE(4)
C...........................  BEGIN HERE  ..............
      IER = 1
      DO 8000 ITIM=1,IDA
      ICFQ = 43 + ITIM-1
      REWIND ICFQ
C       NCLDS=1,2,3 (L,M,H)..JSL=1,2 (LAND,SEA)
      BINSCL = 1./NBIN
      DO 1000 M=1,NSEAL
       DO 1000 L=1,MCLD
        DO 1000 K=1,NLAT
         DO 1000 J=1,NLON
          DO 1000 I=1,NBIN
           RRHFD(I,J,K,L,M) = 0.
           RRNFFD(I,J,K,L,M) = 0.
 1000 CONTINUE
      DO 1001 M=1,NSEAL
       DO 1001 L=1,MCLD
        DO 1001 K=1,NLAT
         DO 1001 J=1,NLON
          KKPTS(J,K,L,M) = 0
 1001 CONTINUE
C....  READ THE DATA OFF THE ROTATING FILE
      READ (ICFQ,ERR=998,END=999) NBDAYI,ICDAYS
      PRINT 11,NBDAYI
      DO 53 LD=1,NBDAYI
       ID = ICDAYS(LD) / 10000
       IM = (ICDAYS(LD)-ID*10000) / 100
       IY = ICDAYS(LD)-ID*10000-IM*100
       PRINT 51,ID,IM,IY
   53 CONTINUE
      READ (ICFQ,ERR=998,END=999) FHOUR,IDATE
      PRINT 3003,IDATE,FHOUR,ITIM
      DO 1300 KD=1,NBDAYI
       READ (ICFQ) RHFD
       READ (ICFQ) RTNFFD
       READ (ICFQ) KPTS
       DO 1002 M=1,NSEAL
        DO 1002 L=1,MCLD
         DO 1002 K=1,NLAT
          DO 1002 J=1,NLON
           DO 1002 I=1,NBIN
            RRHFD(I,J,K,L,M) = RRHFD(I,J,K,L,M) + RHFD(I,J,K,L,M)
            RRNFFD(I,J,K,L,M) = RRNFFD(I,J,K,L,M)+RTNFFD(I,J,K,L,M)
 1002  CONTINUE
       DO 1003 M=1,NSEAL
        DO 1003 L=1,MCLD
         DO 1003 K=1,NLAT
          DO 1003 J=1,NLON
           KKPTS(J,K,L,M) = KKPTS(J,K,L,M) + KPTS(J,K,L,M)
 1003  CONTINUE
 1300 CONTINUE
C
      DO 1004 M=1,NSEAL
       DO 1004 L=1,MCLD
        DO 1004 K=1,NLAT
         DO 1004 J=1,NLON
          DO 1004 I=1,NBIN
           RHCF(I,J,K,L,M) = RRHFD(I,J,K,L,M)
           RTNFCF(I,J,K,L,M) = RRNFFD(I,J,K,L,M)
 1004 CONTINUE
      DO 1005 M=1,NSEAL
       DO 1005 L=1,MCLD
        DO 1005 K=1,NLAT
         DO 1005 J=1,NLON
          KPTS(J,K,L,M) = KKPTS(J,K,L,M)
 1005 CONTINUE
C.....  COMPUTE THE CUMULATIVE FREQUENCY DISTRIBUTION..
      DO 200 N=1,NSEAL
       DO 200 K=1,MCLD
        DO 200 L=1,NLAT
         DO 200 J=1,NLON
          DO 190 I=2,NBIN
           RHCF(I,J,L,K,N) = RHCF(I-1,J,L,K,N) + RHCF(I,J,L,K,N)
           RTNFCF(I,J,L,K,N)=RTNFCF(I-1,J,L,K,N) + RTNFCF(I,J,L,K,N)
  190     CONTINUE
  200 CONTINUE
      DO 300 N=1,NSEAL
       DO 300 L=1,NLAT
        DO 300 J=1,NLON
         DO 300 K=1,MCLD
          DO 300 I=1,NBIN
           IF (KPTS(J,L,K,N).GT.0) THEN
            RHCF(I,J,L,K,N) = RHCF(I,J,L,K,N) / KPTS(J,L,K,N)
            RTNFCF(I,J,L,K,N) = RTNFCF(I,J,L,K,N) / KPTS(J,L,K,N)
           ELSE
            RHCF(I,J,L,K,N) = -0.1
            RTNFCF(I,J,L,K,N) = -0.1
           END IF
  300 CONTINUE
      DO 255 NSL=1,NSEAL
       DO 255 KCL=1,MCLD
        PRINT 264,KCL,NSL
        PRINT 265,((KPTS(I,L,KCL,NSL),I=1,NLON),L=1,NLAT)
  255 CONTINUE
      DO 360 NSL=1,NSEAL
       DO 360 K=1,MCLD
        DO 360 L=1,NLAT
         DO 360 J=1,NLON
          IF (KPTS(J,L,K,NSL).LE.0) GO TO 317
          DO 320 I=1,NBIN
           ICRIT = I
           IF (RHCF(I,J,L,K,NSL).GE.RTNFCF(1,J,L,K,NSL)) GO TO 350
  320     CONTINUE
C... NO CRITICAL RH
  317     ICRIT=-1
          PRINT 210,L,J,NSL
          PRINT 202
          DO 135 I=1,NBIN
           PRINT 203,RHCF(I,J,L,K,NSL),RTNFCF(I,J,L,K,NSL)
  135     CONTINUE
  350     RHC(J,L,K,NSL) = ICRIT * BINSCL
  360 CONTINUE
      DO 1210 NSL=1,NSEAL
       DO 1210 K=1,MCLD
        PRINT 1221,K,NSL
        DO 1210 L=1,NLAT
         PRINT 211,(RHC(J,L,K,NSL),J=1,NLON)
 1210 CONTINUE
      DO 450 NSL=1,NSEAL
       DO 450 KEN=1,MCLD
        DO 450 L=1,NLAT
         DO 450 JL=1,NLON
          DO 400 I=1,NBIN
           RHCL(I,JL,L,KEN,NSL,ITIM) = -0.1
  400     CONTINUE
  450 CONTINUE
      DO 751 NSL=1,NSEAL
       DO 751 KEN=1,MCLD
        DO 751 L=1,NLAT
         DO 751 JL=1,NLON
          IF (KPTS(JL,L,KEN,NSL).LE.0) GO TO 751
          DO 753 I=1,NBIN
           DO 755 J=1,NBIN
            IF (RHCF(J,JL,L,KEN,NSL).GE.RTNFCF(I,JL,L,KEN,NSL)) THEN
             RHCL(I,JL,L,KEN,NSL,ITIM) = J*BINSCL
             GO TO 753
            END IF
  755      CONTINUE
  753     CONTINUE
  751 CONTINUE
      DO 3000 LON=1,NLON
       DO 3000 LAT=1,NLAT
        DO 3000 NC=1,MCLD
         DO 3000 NSL=1,NSEAL
         ISAT = 0
         DO 67 IT=1,NBIN
          CFRAC = BINSCL * (IT-1)
          IF (RHCL(IT,LON,LAT,NC,NSL,ITIM).LT.0.) THEN
           PRINT 1941,IT,NSL,NC,LAT,LON
           STOP
          END IF
          IF (IT.LT.NBIN.AND.RTNFCF(IT,LON,LAT,NC,NSL).GE.1.) THEN
           IF (ISAT.LE.0) THEN
            ISAT = IT
            RHSAT = RHCL(IT,LON,LAT,NC,NSL,ITIM)
            CLSAT = CFRAC
           END IF
           RHCL(IT,LON,LAT,NC,NSL,ITIM) =
     1               RHSAT + (1.-RHSAT)*(CFRAC-CLSAT)/(1.-CLSAT)
          END IF
          IF (IT.EQ.NBIN) RHCL(IT,LON,LAT,NC,NSL,ITIM) = 1.
   67    CONTINUE
 3000 CONTINUE
 8000 CONTINUE
      DO 8001 KEN=1,IDA
       ICFQ = 42 + KEN
       REWIND ICFQ
 8001 CONTINUE
      RETURN
  998 PRINT 988,ITIM
      IER = -1
      RETURN
  999 PRINT 989,ITIM
      IER = -1
      RETURN
   11 FORMAT(1H ,' DAYS ON FILE =',I5)
   51 FORMAT(1H ,' ARCHV DATA FROM DA,MO,YR=',3I4)
  202 FORMAT(1H0,' MODEL RH ',' OBS RTCLD')
  203 FORMAT(2F10.2)
  210 FORMAT(1H ,' NO CRIT RH FOR LAT=',I3,' AND LON BAND=',I3,
     1           ' LAND(=1) SEA=',I3)
  211 FORMAT(1H ,15F6.2)
  264 FORMAT(1H ,' NUMBER OF GG POINTS USED IN EACH AREA..BY LATITUDE',
     1           '..FOR CLOUD TYPE=',I4,'SEALAND=',I2)
  265 FORMAT(1H ,15I8)
  988 FORMAT(1H ,'....ERROR READING TABLES FOR TIME=',I4)
  989 FORMAT(1H ,'....E.O.F READING TABLES FOR TIME=',I4)
 1221 FORMAT(1H0,' CRITICAL RH FOR LON,LAT ARRAYS FOR CLD TYPE=',I3,
     1           ' LAND(=1) SEA=',I3)
 1941 FORMAT(1H ,' NEG RHCL FOR IT,NSL,NC,LAT,LON=',5I4,'...STOPPP..')
 3003 FORMAT(5X,'...LAST DATE/TIME AND CURRENT ITIM',/,10X,
     1       4I15,F7.1,I6)
      END
